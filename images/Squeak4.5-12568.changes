
----STARTUP----{15 January 2014 . 2:16:33 pm} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/15/2014 14:33' prior: 42646392!benchStm	[(1 to: 1000)		do: [:t1 | SPyVM print: 'Thread 1 reporting!!']] parallelFork.	[(1 to: 1000)		do: [:t1 | SPyVM print: 'Thread 2 reporting!!']] parallelFork.	[(1 to: 1000)		do: [:t1 | SPyVM print: 'Thread 3 reporting!!']] parallelFork.	[(1 to: 1000)		do: [:t1 | SPyVM print: 'Thread 4 reporting!!']] parallelFork.	(1 to: 1000)		do: [:x | SPyVM print: '* spinlock *'].	^ 42 printString! !----SNAPSHOT----{15 January 2014 . 2:33:47 pm} Squeak4.5-12568.image priorSource: 9103122!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/15/2014 14:35' prior: 42656801!benchStm3	| t1 t2 |	t1 := [(1 to: 100)				do: [:t3 | SPyVM print: 'Thread 1 reporting!!']] parallelFork.	t2 := [(1 to: 100)				do: [:t3 | SPyVM print: 'Thread 2 reporting!!']] parallelFork.	SPyVM print: 'Waiting for Task 1'.	t1 wait.	SPyVM print: 'Waiting for Task 2'.	t2 wait.	SPyVM print: 'Finished waiting.'! !----SNAPSHOT----{15 January 2014 . 2:36:01 pm} Squeak4.5-12568.image priorSource: 594!!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/15/2014 14:37' prior: 42653846!wait	<primitive: 789>	SPyVM print: ' Failed to wait for process!! '! !----SNAPSHOT----{15 January 2014 . 2:37:09 pm} Squeak4.5-12568.image priorSource: 1091!----STARTUP----{16 January 2014 . 9:13:20 pm} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!BlockClosure methodsFor: 'scheduling' stamp: 'toma 1/16/2014 21:13' prior: 42654183!parallelFork	^ (self newSTMProcess) fork; yourself! !----SNAPSHOT----{16 January 2014 . 9:14:01 pm} Squeak4.5-12568.image priorSource: 1345!!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 21:14'!primWait	<primitive: 789>	SPyVM print: ' Failed to wait for process!! '! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 21:15' prior: 33555705!wait		SPyVM print: '[squeak] wait'	self primWait! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 21:15' prior: 33556450!wait		SPyVM print: '[squeak] wait'.	self primWait! !----SNAPSHOT----{16 January 2014 . 9:15:29 pm} Squeak4.5-12568.image priorSource: 1681!!BasicClassOrganizer methodsFor: 'accessing' stamp: 'toma 1/16/2014 22:18' prior: 17298983!classComment	classComment		ifNil: [^ ''].	^ [classComment text ifNil: ['']] on: Error do: [^ ''].! !Object subclass: #SPySTM	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SPy-Benchmarks'!Object subclass: #SPySTM	instanceVariableNames: ''	classVariableNames: 'Shared'	poolDictionaries: ''	category: 'SPy-Benchmarks'!!SPySTM class methodsFor: 'nil' stamp: 'toma 1/16/2014 22:22'!shared		^self Shared! !!SPySTM class methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:23' prior: 33557264!shared		^Shared! !!SPySTM class methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:23'!shared: aValue		Shared := aValue! !----SNAPSHOT----{16 January 2014 . 10:24:08 pm} Squeak4.5-12568.image priorSource: 2221!Object subclass: #STMAtomic	instanceVariableNames: 'lock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!STMAtomic methodsFor: 'nil' stamp: 'toma 1/16/2014 22:28'!primEnter	<primitive: 790>! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:28' prior: 33557810!primEnter	<primitive: 790>	SPyVM print: 'primEnter failed'.! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:28' prior: 33557933!primEnter	<primitive: 790>		SPyVM print: 'primEnter failed'.! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:29'!primLeave	<primitive: 791>		SPyVM print: 'primLeave failed'.! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:29'!value		self primEnter.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:29' prior: 33558376!value		| result |		self primEnter.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:30' prior: 33558498!value		| result |		self primEnter.	result := self.	self primLeave	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:30' prior: 33558634!value		| result |		self primEnter.	result := self.	self primLeave.	! !Object subclass: #STMAtomic	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:31' prior: 33558803!value		| result |		self primEnter.	result := self block value.	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:31' prior: 33559111!value		| result error |		self primEnter.	result := self block value.	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:32' prior: 33559293!value		| result error |		self primEnter.	[result := self block value.] on: Error do: [:err | error := err]	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:32' prior: 33559481!value		| result error |		self primEnter.	error := nil.		[result := self block value.] on: Error do: [:err | error := err]	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:32' prior: 33559707!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Error do: [:err | error := err]	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:32' prior: 33559950!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Error do: [:err | error := err].	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:33' prior: 33560207!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Error do: [:err | error := err].	self primLeave.	error ifNotNil: [error raise]	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:33' prior: 33560465!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Exception do: [:err | error := err].	self primLeave.	error ifNotNil: [error raise]	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:35' prior: 33560754!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Exception do: [:err | error := err].	self primLeave.	error ifNotNil: [error pass]	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:35' prior: 33561047!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Exception do: [:err | error := err].	self primLeave.	error ifNotNil: [error pass]		! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:35' prior: 33561339!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Exception do: [:err | error := err].	self primLeave.	error ifNotNil: [error pass].	^result	! !!STMAtomic class methodsFor: 'nil' stamp: 'toma 1/16/2014 22:36'!from: aBlock		^ (STMAtomic new)		block: aBlock;		yourself.! !!STMAtomic class methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:36' prior: 33561909!from: aBlock		^ (STMAtomic new)		block: aBlock;		yourself! !!BlockClosure methodsFor: 'nil' stamp: 'toma 1/16/2014 22:37'!atomic		^STMAtomic from: self! !SystemOrganization addCategory: #'Kernel-STM'!SystemOrganization classify: #STMAtomic under: #'Kernel-STM'!SystemOrganization classify: #STMProcess under: #'Kernel-STM'!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:40'!benchStmAtomic	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:40' prior: 33562476!benchStmAtomic		| sum |	sum := 0.	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:40' prior: 33562577!benchStmAtomic		| sum |	sum := 0.	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:40' prior: 33562700!benchStmAtomic		| sum |	sum := 0.		! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:41'!benchStmParallel		| sum |	sum := 0.		! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:41' prior: 33562933!benchStmParallel		| sum |	sum := 0.		(1 to: self) do: [ :i |		[(1 to: 100) do: [ :k | sum := sum + k ]]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:42' prior: 33563060!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[(1 to: 100) do: [ :k | sum := sum + k ]]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:42' prior: 33563258!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[(i to: (i + 1000)) do: [ :k | sum := sum + k ]]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:42' prior: 33563453!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k ]]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:43' prior: 33563655!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k ]] parallelFork		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:43' prior: 33563872!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k. ]] parallelFork.		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:43' prior: 33564102!benchStmParallel		| sum |	sum := 0.		(0 to: 7) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k. ]] parallelFork.		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:43' prior: 33564334!benchStmParallel		| sum |	sum := 0.		(0 to: 7) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k. ]] parallelFork.		]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:46' prior: 33564566!benchStmParallel		| sum t |	sum := 0.		(0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				sum := sum + k. ]			] parallelFork		]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:46' prior: 33564800!benchStmParallel		| sum threads |	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				sum := sum + k. ]			] parallelFork		]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:46' prior: 33565051!benchStmParallel		| sum threads |	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait.]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:46' prior: 33565319!benchStmParallel		| sum threads |	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{16 January 2014 . 10:47:04 pm} Squeak4.5-12568.image priorSource: 3090!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:56' prior: 33562824!benchStmAtomic	| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:57' prior: 33566018!benchStmAtomic	| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000 - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:57' prior: 33565614!benchStmParallel		| sum threads |	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000 - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:57' prior: 33566678!benchStmParallel		| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000 - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{16 January 2014 . 10:58:17 pm} Squeak4.5-12568.image priorSource: 11414!!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:01' prior: 33561633!value		| result  |		self primEnter.	result := self block value.	self primLeave.	^result	! !!STMAtomic methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:02'!block	^ block! !!STMAtomic methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:02'!block: anObject	block := anObject! ![ 1 + 1 ] atomic value![ 1 + 1 ] atomic value!----SNAPSHOT----{16 January 2014 . 11:03:21 pm} Squeak4.5-12568.image priorSource: 12802!----SNAPSHOT----{16 January 2014 . 11:03:41 pm} Squeak4.5-12568.image priorSource: 13325!----SNAPSHOT----{16 January 2014 . 11:03:45 pm} Squeak4.5-12568.image priorSource: 13416!BlockClosure organization addCategory: #STM!BlockClosure organization classify: #atomic under: #STM!!BlockClosure methodsFor: 'STM' stamp: 'toma 1/16/2014 22:37' prior: 33562201!atomic		^STMAtomic from: self! !BlockClosure organization classify: #newSTMProcess under: #STM!!BlockClosure methodsFor: 'STM' stamp: '' prior: 42643259!newSTMProcess	^ STMProcess forContext: [self value] asContext priority: Processor activePriority! !!BlockClosure methodsFor: 'STM' stamp: '' prior: 33568373!newSTMProcess	^ STMProcess forContext: [self value] asContext priority: Processor activePriority! !BlockClosure organization classify: #parallelFork under: #STM!!BlockClosure methodsFor: 'STM' stamp: 'toma 1/16/2014 21:13' prior: 33556059!parallelFork	^ (self newSTMProcess) fork; yourself! !Object subclass: #STMFuture	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMFuture	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:33'!block	^ block! !!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:33'!block: anObject	block := anObject! !!STMFuture methodsFor: 'nil' stamp: 'toma 1/16/2014 23:34'!invoke		! !Object subclass: #STMFuture	instanceVariableNames: 'block process'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:34'!process	^ process! !!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:34'!process: anObject	process := anObject! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:35' prior: 33569341!invoke		self process: (self block parallelFork)! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:35'!value	! !Object subclass: #STMFuture	instanceVariableNames: 'block process result'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:35'!result	^ result! !!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:35'!result: anObject	result := anObject! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:36' prior: 33569785!invoke		self process: ([self result: self block value] parallelFork)! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:36' prior: 33569914!value		self process wait.! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:36' prior: 33570525!value		self process wait.	^self result! !!STMFuture class methodsFor: 'nil' stamp: 'toma 1/16/2014 23:37'!invoke: aBlock		^(STMFuture new)		block: aBlock;		invoke;		yourself! !!BlockClosure methodsFor: 'STM' stamp: 'toma 1/16/2014 23:38'!async	^STMFuture invoke: self! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:38'!benchStmFuture		! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:39' prior: 33570998!benchStmFuture		| futures | 	! !(1 to: 100) sum!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:40' prior: 33571101!benchStmFuture		| futures | 	futures := (0 to: 7) collect: [ :id |		[(1 to: 1000) sum ]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:41' prior: 33571236!benchStmFuture		| futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:41' prior: 33571416!benchStmFuture		| futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async]	! !(1 to: 100) inject: 0 into: [ :i :k | i + k]!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:43' prior: 33571596!benchStmFuture		| sum futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :s :f | s + (f value)]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:44' prior: 33571825!benchStmFuture		| sum futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:44' prior: 33572069!benchStmFuture		| sum futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !----SNAPSHOT----{16 January 2014 . 11:45:18 pm} Squeak4.5-12568.image priorSource: 13507!----SNAPSHOT----{16 January 2014 . 11:45:23 pm} Squeak4.5-12568.image priorSource: 18085!----SNAPSHOT----{16 January 2014 . 11:46:35 pm} Squeak4.5-12568.image priorSource: 18176!Object subclass: #STMWorker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMWorker	instanceVariableNames: 'queue'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:23' prior: 33570359!invoke	self process ifNil: [		self process: ([self result: self block value] parallelFork)		] ifNotNil: [		]! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:23' prior: 33573142!invoke	self process ifNil: [		self process: ([self result: self block value] parallelFork)	] ifNotNil: [			]! !self!!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:23' prior: 33573350!invoke	self process ifNil: [		self process: ([self result: self block value] parallelFork)	] ifNotNil: [		self error: 'Future already invoked'	]! !!STMFuture methodsFor: 'nil' stamp: 'toma 1/17/2014 00:24'!initialize		super initialize.! !STMFuture removeSelector: #initialize!!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:26' prior: 33570648!value		self process ifNotNil: [		self process wait.		^self result	] ifNil: [		self error: 'Future not invoked'	]	! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:26' prior: 33573946!value		self process ifNotNil: [		self wait.		^self result	] ifNil: [		self error: 'Future not invoked'	]	! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:26'!wait		self process wait.! !!STMWorker methodsFor: 'nil' stamp: 'toma 1/17/2014 00:28'!submit: aBlock callback: aUnaryBlock		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:30'!send: aSymbol with: anArgument	! !STMWorker removeSelector: #submit:callback:!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:30'!on: aSymbol do: aBlock	! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:30' prior: 33574724!on: aSymbol do: aBlock		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:31'!onMessage: aSymbol do: aBlock		! !STMWorker removeSelector: #on:do:!Object subclass: #STMWorker	instanceVariableNames: 'queue handlers'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMWorker methodsFor: 'nil' stamp: 'toma 1/17/2014 00:31'!initialize		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:31' prior: 33575225!initialize		handlers := Dictionary new.! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:32'!queue	^ queue! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:32'!queue: anObject	queue := anObject! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:32'!handlers	^ handlers! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:32'!handlers: anObject	handlers := anObject! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:32' prior: 33575335!initialize		self handlers: Dictionary new.! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:32' prior: 33574951!onMessage: aSymbol do: aBlock		self handlers at: aSymbol put: aBlock! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:32' prior: 33574566!send: aSymbol with: anArgument	! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:32' prior: 33576170!send: aSymbol with: anArgument		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:34' prior: 33576299!send: aSymbol with: anArgument		! !Object subclass: #STMMessage	instanceVariableNames: 'queue handlers'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMMessage	instanceVariableNames: 'name arg'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMMessage	instanceVariableNames: 'name args'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!{1. 2.}!{1. 2. World.}![:i :j | i + j]![:i :j | i + j] valueWithArguments: {1. 2.}!!STMMessage class methodsFor: 'nil' stamp: 'toma 1/17/2014 00:39'!named: aSymbol withArgs: anArray		^(self new)		name: aSymbol;		arguments: anArray;		yourself! !Object subclass: #STMMessage	instanceVariableNames: 'name arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:39'!name: anObject	name := anObject! !!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:39'!arguments	^ arguments! !!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:39'!arguments: anObject	arguments := anObject! !Object subclass: #STMMessage	instanceVariableNames: 'messageName arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:40'!messageName	^ messageName! !!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:40'!messageName: anObject	messageName := anObject! !STMMessage removeSelector: #name:!!STMMessage class methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:40' prior: 33577040!named: aSymbol withArgs: anArray		^(self new)		messageName: aSymbol;		arguments: anArray;		yourself! !a := {1. 2. 3.}!a := OrderedCollection new!a add: 5!a!a add: 5!a!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:44' prior: 33576429!send: aSymbol with: anArgument		self queue! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:44' prior: 33575864!initialize		self handlers: Dictionary new.	self queue: Stack new.! !a := Stack new!a := Stack new!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:47' prior: 33578512!initialize		self handlers: Dictionary new.	self queue: LinkedList new.! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:48' prior: 33578372!send: aSymbol with: anArgument		self queue addLast: (STMMessage named: aSymbol with: {anArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:48' prior: 33578879!send: aSymbol with: anArgument		self queue addLast: (STMMessage named: aSymbol withArgs: {anArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:48' prior: 33579075!send: aSymbol with: anArgument		self queue addLast: (		STMMessage named: aSymbol withArgs: {anArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:49'!send: aSymbol with: anArgument with: anotherArgument		self queue addLast: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument.})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:49'!send: aSymbol with: anArgument and: anotherArgument		self queue addLast: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument.})! !STMWorker removeSelector: #send:with:with:!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:49'!send: aSymbol with: anArgument and: anotherArgument and: aThirdArgument		self queue addLast: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument. aThirdArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:50'!loop	! !Object subclass: #STMWorker	instanceVariableNames: 'queue handlers active'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:50'!active	^ active! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:50'!active: anObject	active := anObject! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:50' prior: 33580221!loop		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:51' prior: 33580665!loop		self active: true.	[self active] whileTrue: [	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:51' prior: 33580769!loop		self active: true.	[self active] whileTrue: [			]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:52' prior: 33580922!loop		self active: true.	[self active] whileTrue: [		[self queue isEmpty] ifFalse: [					]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:52' prior: 33581078!loop		self active: true.	[self active] whileTrue: [		[self queue isEmpty] ifFalse: [			| message | 			[message := self queue removeFirst]		]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:52' prior: 33581273!loop		self active: true.	[self active] whileTrue: [		| message | 		[self queue isEmpty] ifFalse: [						[message := self queue removeFirst]		]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:53' prior: 33581519!loop		self active: true.	[self active] whileTrue: [		| message | 		message := nil.		[self queue isEmpty] ifFalse: [						[message := self queue removeFirst]		]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:53' prior: 33581768!loop		self active: true.	[self active] whileTrue: [		| message | 		message := nil.		[ [self queue isEmpty] ifFalse: [				[message := self queue removeFirst]		] ] atomic value.	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:53' prior: 33582035!loop		self active: true.	[self active] whileTrue: [		| message | 		message := nil.		[ [self queue isEmpty] ifFalse: [				[message := self queue removeFirst]		] ] atomic value.			]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:54'!receive		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:54' prior: 33582318!loop		self active: true.	[self active] whileTrue: [					]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:54' prior: 33582587!receive		| message | 		message := nil.		[ [self queue isEmpty] ifFalse: [				[message := self queue removeFirst]		] ] atomic value.! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:54' prior: 33582853!receive		| message | 		message := nil.	[ [self queue isEmpty] ifFalse: [				[message := self queue removeFirst]] 	] atomic value.	^message! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:55' prior: 33575531!queue: aMessage		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:55' prior: 33583328!queue: aMessage		[self queue addLast: aMessage] atomic value! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:56' prior: 33583443!queue: anObject		queue := anObject! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:56'!schedule: aMessage	[self queue addLast: aMessage] atomic value! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:58' prior: 33579275!send: aSymbol with: anArgument		self schedule: (		STMMessage named: aSymbol withArgs: {anArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:58' prior: 33579689!send: aSymbol with: anArgument and: anotherArgument		self schedule: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument.})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:58' prior: 33579960!send: aSymbol with: anArgument and: anotherArgument and: aThirdArgument		self schedule: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument. aThirdArgument})! !STMWorker organization classify: #schedule: under: #'as yet unclassified'!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:56' prior: 33583697!schedule: aMessage	[self queue addLast: aMessage] atomic value! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:00' prior: 33582694!loop		self active: true.	[self active] whileTrue: [		self receive ifNotNilDo: [ :m						]			]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:01' prior: 33584800!loop		self active: true.	[self active] whileTrue: [		self receive ifNotNilDo: [ :m |			(self handlers at: (m messageName))				valueWithArguments: (m arguments)			]			]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:01' prior: 33584997!loop		self active: true.	[self active] whileTrue: [		self receive ifNotNilDo: [ :m |			(self handlers at: (m messageName))				valueWithArguments: (m arguments)			]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:01'!stop	self active: False! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:01'!start		[self loop] parallelFork! !w := STMWorker new!w onMessage: #test do: [:i | Transcript show: i]!w start!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:03' prior: 33583086!receive		| message | 		message := nil.	[ (self queue isEmpty) ifFalse: [				[message := self queue removeFirst]] 	] atomic value.	^message! !w stop!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:04' prior: 33585522!stop	self active: false! !Smalltalk renameClassNamed: #STMWorker as: #STMActor!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:06'!benchStmActor		| a1 a2 |	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:06' prior: 33586238!benchStmActor		| a1 a2 |		a1 := STMActor new.	a2 := STMActor new.	! !1 printString!1 printString!1 printString!'1'!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:14' prior: 33586352!benchStmActor		| a |		a := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		(n < 1) 			ifTrue: [SPyVM print: (sum2 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:14' prior: 33586563!benchStmActor		| a |		a := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:15' prior: 33586879!benchStmActor		| a |		a := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		]	a start.	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:18' prior: 33587197!benchStmActor		| a b |		a := STMActor new.	b := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'a'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [b send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	b onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'b'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	a start.	b start.	a send: #fibonacci with: self and: 1 and: 1.! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:19' prior: 33587525!benchStmActor		| a b |		a := STMActor new.	b := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'a'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [b send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	b onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'b'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	a start.	b start.	a send: #fibonacci with: self and: 1 and: 1.	(1 to: 1000) do: [:i | SPyVM print: '.']! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:19' prior: 33588158!benchStmActor		| a b |		a := STMActor new.	b := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'a'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [b send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	b onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'b'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	a start.	b start.	a send: #fibonacci with: self and: 1 and: 1.	(1 to: 1000) do: [:i | SPyVM print: '.']	a stop.	b stop.! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:19' prior: 33588833!benchStmActor		| a b |		a := STMActor new.	b := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'a'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [b send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	b onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'b'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	a start.	b start.	a send: #fibonacci with: self and: 1 and: 1.	(1 to: 1000) do: [:i | SPyVM print: '.'].	a stop.	b stop.! !----SNAPSHOT----{17 January 2014 . 1:19:41 am} Squeak4.5-12568.image priorSource: 18267!----SNAPSHOT----{17 January 2014 . 1:23 am} Squeak4.5-12568.image priorSource: 35706!10 benchStmActor!----QUIT/NOSAVE----{17 January 2014 . 1:24:53 am} Squeak4.5-12568.image priorSource: 35796!----STARTUP----{17 January 2014 . 5:10:50 pm} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:00' prior: 33566346!benchStmAtomic	| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{17 January 2014 . 7:00:29 pm} Squeak4.5-12568.image priorSource: 35796!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:01' prior: 33566996!benchStmParallel		| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * 1000 - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:01' prior: 33591037!benchStmParallel		| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{17 January 2014 . 7:01:14 pm} Squeak4.5-12568.image priorSource: 36433!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:18' prior: 33591357!benchStmParallel		| sum num threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:20' prior: 33591767!benchStmParallel		| sum num threads |		num := self \\ 100.	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:20' prior: 33592091!benchStmParallel		| sum num threads max |		num := self \\ 100.	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:20' prior: 33592436!benchStmParallel		| sum num threads max |		num := self \\ 100.	max := self - num.	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33592785!benchStmParallel		| sum num threads max |		num := self \\ 100.	max := self - num.	sum := 0.		threads := (0 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33590615!benchStmAtomic	| sum threads max num |		num := self \\ 100.	max := self - num.	sum := 0.		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33593523!benchStmAtomic	| sum threads max num |		num := self \\ 100.	max := self - num.	sum := 0.		sum := 0.		threads := (0 to: num) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33593917!benchStmAtomic	| sum threads max num |		num := self \\ 100.	max := self - num.	sum := 0.		sum := 0.		threads := (0 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33594313!benchStmAtomic	| sum threads max num |		num := self \\ 100.	max := self - num.	sum := 0.		threads := (0 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{17 January 2014 . 7:21:58 pm} Squeak4.5-12568.image priorSource: 37163!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:25' prior: 33572325!benchStmFuture		| sum num threads max futures |		num := self \\ 100.	max := self - num.	sum := 0.		futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:25' prior: 33595178!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := self - num.	sum := 0.		futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:25' prior: 33595523!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := self - num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:25' prior: 33595860!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := self - num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:26' prior: 33596199!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := (self - num) \\ num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:26' prior: 33596537!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := (self - num) // num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:26' prior: 33596884!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := self // num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !----SNAPSHOT----{17 January 2014 . 7:26:27 pm} Squeak4.5-12568.image priorSource: 40574!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:20' prior: 33597231!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.			futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !Time now!Time now!Time now!Time now!Time now asNanoSeconds!Time now asNanoSeconds!Time now asNanoSeconds!Time now asNanoSeconds!Time now asNanoSeconds!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:25' prior: 33597660!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: 'µs'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:25' prior: 33598176!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: 'µs inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:25' prior: 33598657!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] µs inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:26' prior: 33599153!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 3:26:07 pm} Squeak4.5-12568.image priorSource: 43056!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 16:30' prior: 33599946!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 16:31' prior: 33600550!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 16:36' prior: 33601163!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 4:36:36 pm} Squeak4.5-12568.image priorSource: 45946!----SNAPSHOT----{18 January 2014 . 4:36:48 pm} Squeak4.5-12568.image priorSource: 47883!----STARTUP----{18 January 2014 . 10:05:52 pm} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:06' prior: 33593154!benchStmParallel		| sum num threads max start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		threads := (0 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:06' prior: 33602684!benchStmParallel		| sum num threads max start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:07' prior: 33603203!benchStmParallel		| sum num threads max start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:07' prior: 33594707!benchStmAtomic		| sum num threads max start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				[sum := sum + k.] atomic value. ]			] parallelFork		].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^ sum printString! !----SNAPSHOT----{18 January 2014 . 10:07:37 pm} Squeak4.5-12568.image priorSource: 47973!----SNAPSHOT----{18 January 2014 . 10:48:10 pm} Squeak4.5-12568.image priorSource: 50518!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:59' prior: 33601776!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0.  [(1 to: max) do: [:i | s := s + 1] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:59'!benchStmFuture2		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0.  [(1 to: max) do: [:i | s := s + 1] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:59' prior: 33605214!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0.  [(1 to: max) do: [:i | s := s + 1] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:59' prior: 33606505!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0.  [(1 to: max) do: [:i | s := s + 1] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 16:36' prior: 33607158!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 11:01:12 pm} Squeak4.5-12568.image priorSource: 50609!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:13'!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:14' prior: 33608507!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [ (1 to: max) inject: 1 into: [:next :each | (next + each) \\ 1000000 ] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 11:14:38 pm} Squeak4.5-12568.image priorSource: 53918!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:27' prior: 33609129!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s:=0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1] ]  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:27' prior: 33609898!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s:=0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1] ]  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:27' prior: 33610601!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s:=0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33611305!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33612021!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33612739!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33613460!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [			:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33614183!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [			:i | i isPrime ifTrue:[s := s + 1]			]. s yourself.  ]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33614910!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [			:i | i isPrime ifTrue:[s := s + 1]		]. s yourself.  ]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33615641!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [			:i | i isPrime ifTrue:[s := s + 1]			]. s yourself.  		]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 11:28:45 pm} Squeak4.5-12568.image priorSource: 55293!0 isPrime!1 isPrime!2 isPrime!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:33' prior: 33616371!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) do: [			:i | i isPrime ifTrue:[s := s + 1]			]. s yourself.  		]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 11:33:23 pm} Squeak4.5-12568.image priorSource: 62591!----STARTUP----{21 January 2014 . 10:50:25 am} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!SystemOrganization addCategory: #'VM-GameOfLife'!Object subclass: #GameOfLifeField	instanceVariableNames: 'data height width'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #GameOfLifeField
	instanceVariableNames: 'data height width'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VM-GameOfLife'!!GameOfLifeField methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:23'!cellAliveAt: x at: y

	^ (self at: x at: y) = 1! !!GameOfLifeField methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:14'!rows: numberOfRows columns: numberOfColumns

	self height: numberOfRows.
	self width: numberOfColumns.
	self data: (Matrix rows: numberOfRows columns: numberOfColumns element: 0).
	! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:25'!at: x at:y
	
	((x < 1) or: [x > self width]) ifTrue: [ ^ 0 ].
      ((y < 1) or: [y > self height]) ifTrue: [ ^ 0 ].

	^ self data at: y at: x! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:25'!at: x at:y put: aValue

	self data at: y at: x put: aValue.! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:02'!atRow: rowNumber put: aRow

	self data atRow: rowNumber put: aRow! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!data

	^ data! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!data: anObject

	data := anObject! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!height

	^ height! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!height: anObject

	height := anObject! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:52'!print

	| resultString |
	resultString := ''.
	(1 to: self height) do: [:y |
		(1 to: self width) do: [ :x |
			resultString := resultString , (self data at: y at: x).].
		resultString := resultString , Character cr ].
	^ resultString			! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!rowSlice: sliceSize collect: aBlock

	! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:28'!rowwiseFrom: startRow to: endRow collect: aBlock

	| newField |
	newField := GameOfLifeFieldSlice from: startRow to: endRow width: self width.
	(startRow to: endRow) do: [ :y | 
		(1 to: self width) do: [ :x | newField at: x at: y put: (aBlock value: self value: x value: y) ] ].
	^ newField! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!width

	^ width! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!width: anObject

	width := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GameOfLifeField class
	instanceVariableNames: ''!!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:44'!gliderFieldRows: numberOfRows columns: numberOfColumns

	| newField |
	newField := self new rows: numberOfRows columns: numberOfColumns.
	
	newField 
		at: 8 at: 5 put: 1;
		at: 9 at: 5 put: 1;	 
		at: 10 at: 5 put: 1;
		at: 10 at: 4 put: 1;
		at: 9 at: 3 put: 1.
		
	^ newField! !!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 20:43'!rows: numberOfRows columns: numberOfColumns

	^ self new rows: numberOfRows columns: numberOfColumns! !GameOfLifeField subclass: #GameOfLifeFieldSlice	instanceVariableNames: 'startRow endRow'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!GameOfLifeField subclass: #GameOfLifeFieldSlice
	instanceVariableNames: 'startRow endRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VM-GameOfLife'!!GameOfLifeFieldSlice methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 10:22'!from: startRow to: endRow width: width

	self startRow: startRow;
		endRow: endRow;
		width: width;
		height: (endRow - startRow + 1);
		data: (Matrix rows: (endRow - startRow + 1) columns: width).
		
	^ self! !!GameOfLifeFieldSlice methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:31'!rowwiseDo: aBlock

	self startRow to: self endRow do: [ :rowNumber |
		aBlock value: rowNumber value: (self data atRow: (rowNumber - self startRow) + 1).
	].! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:30'!at: x at:y put: aValue

	self data at: y +  1 - self startRow at: x put: aValue.! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11'!endRow

	^ endRow! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11'!endRow: anObject

	endRow := anObject! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11'!startRow

	^ startRow! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11'!startRow: anObject

	startRow := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GameOfLifeFieldSlice class
	instanceVariableNames: ''!!GameOfLifeFieldSlice class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 20:53'!from: startRow to: endRow width: width

	^ self new from: startRow to: endRow width: width! !Object subclass: #STMSimulation	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #STMSimulation
	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VM-GameOfLife'!!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!initialField: aGameOfLifeField

	self field: aGameOfLifeField.
	self fieldNew: (GameOfLifeField rows: (aGameOfLifeField height) columns: (aGameOfLifeField width)).! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:50'!simulateRound: roundNumber 

	self processes: ((1 to: self numberOfProcesses) collect: [ :processNumber |
		[| rows |
		rows := self startProcess: processNumber.
		rows rowwiseDo: [ :rowNumber :aRow | self fieldNew atRow: rowNumber put: aRow ]] parallelFork. ]).
! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		"Transcript show: self fieldNew print.
		Transcript show: Character cr."
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!startProcess: processNumber

	| endOfSlice slice startOfSlice |
	slice := (self field height / self numberOfProcesses).
	startOfSlice := ((processNumber - 1) * slice) + 1.
	endOfSlice := processNumber * slice.

	^ self field rowwiseFrom: startOfSlice
					to: endOfSlice
					collect: [ :tempField :x :y | self thumbUpOrDownAt: x at: y on: tempField ]

	
	! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!thumbUpOrDownAt: x at: y on: tempField 
	| liveCellCount |
	
	liveCellCount := (tempField at: x - 1 at: y - 1)
				+ (tempField at: x + 0 at: y - 1)
				+ (tempField at: x + 1 at: y - 1)
				+ (tempField at: x - 1 at: y + 0)
				+ (tempField at: x + 1 at: y + 0)
				+ (tempField at: x - 1 at: y + 1)
				+ (tempField at: x + 0 at: y + 1)
				+ (tempField at: x + 1 at: y + 1).
	
	(tempField cellAliveAt: x at: y)
		ifTrue: [((2 = liveCellCount)
					or: [liveCellCount = 3])
				ifTrue: [^ 1]
				ifFalse: [^ 0]]
		ifFalse: [(liveCellCount = 3)
				ifTrue: [^ 1]
				ifFalse: [^ 0]]! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!field

	^ field! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!field: anObject

	field := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!fieldNew

	^ fieldNew! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!fieldNew: anObject

	fieldNew := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!fieldSlices

	^ fieldSlices! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!fieldSlices: anObject

	fieldSlices := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!numberOfProcesses

	^ numberOfProcesses! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!numberOfProcesses: aNumber

	numberOfProcesses := aNumber
	! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!processes

	^ processes! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!processes: anObject

	processes := anObject! !!STMSimulation methodsFor: 'initialize-release' stamp: 'pre 1/21/2014 09:44'!initialize

	self processes: OrderedCollection new.
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STMSimulation class
	instanceVariableNames: ''!!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!benchmark

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!benchmark2

	^ (1 to: 5) collect: [ :i |
			[ self standardSimulation2: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!standardSimulation2: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!standardSimulation: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !Object subclass: #Simulation	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #Simulation
	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VM-GameOfLife'!!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:37'!initialField: aGameOfLifeField

	self field: aGameOfLifeField.
	self fieldNew: (GameOfLifeField rows: (aGameOfLifeField height) columns: (aGameOfLifeField width)).! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:44'!simulateRound: roundNumber 

	self processes: ((1 to: self numberOfProcesses) collect: [ :processNumber |
		| semaphore |
		semaphore := Semaphore new.
		[| rows |
		rows := self startProcess: processNumber.
		rows rowwiseDo: [ :rowNumber :aRow | self fieldNew atRow: rowNumber put: aRow ].
		semaphore signal] fork.
		semaphore ]).
! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:00'!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		"Transcript show: self fieldNew print.
		Transcript show: Character cr."
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:34'!startProcess: processNumber

	| endOfSlice slice startOfSlice |
	slice := (self field height / self numberOfProcesses).
	startOfSlice := ((processNumber - 1) * slice) + 1.
	endOfSlice := processNumber * slice.

	^ self field rowwiseFrom: startOfSlice
					to: endOfSlice
					collect: [ :tempField :x :y | self thumbUpOrDownAt: x at: y on: tempField ]

	
	! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 10:48'!thumbUpOrDownAt: x at: y on: tempField 
	| liveCellCount |
	
	liveCellCount := (tempField at: x - 1 at: y - 1)
				+ (tempField at: x + 0 at: y - 1)
				+ (tempField at: x + 1 at: y - 1)
				+ (tempField at: x - 1 at: y + 0)
				+ (tempField at: x + 1 at: y + 0)
				+ (tempField at: x - 1 at: y + 1)
				+ (tempField at: x + 0 at: y + 1)
				+ (tempField at: x + 1 at: y + 1).
	
	(tempField cellAliveAt: x at: y)
		ifTrue: [((2 = liveCellCount)
					or: [liveCellCount = 3])
				ifTrue: [^ 1]
				ifFalse: [^ 0]]
		ifFalse: [(liveCellCount = 3)
				ifTrue: [^ 1]
				ifFalse: [^ 0]]! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04'!field

	^ field! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04'!field: anObject

	field := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:06'!fieldNew

	^ fieldNew! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:06'!fieldNew: anObject

	fieldNew := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:30'!fieldSlices

	^ fieldSlices! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:30'!fieldSlices: anObject

	fieldSlices := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:09'!numberOfProcesses

	^ numberOfProcesses! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:09'!numberOfProcesses: aNumber

	numberOfProcesses := aNumber
	! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04'!processes

	^ processes! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04'!processes: anObject

	processes := anObject! !!Simulation methodsFor: 'initialize-release' stamp: 'pre 1/19/2014 20:04'!initialize

	self processes: OrderedCollection new.
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Simulation class
	instanceVariableNames: ''!!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:08'!benchmark

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:09'!benchmark2

	^ (1 to: 5) collect: [ :i |
			[ self standardSimulation2: (2 raisedTo: i) ] timeToRun ]! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:59'!standardSimulation2: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:59'!standardSimulation: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !----End fileIn of a stream----!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 10:55'!gol		STMSimulation benchmark! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 10:56' prior: 33632815!gol		STMSimulation benchmark printString! !----SNAPSHOT----{21 January 2014 . 10:56:17 am} Squeak4.5-12568.image priorSource: 63448!	^STMSimulation benchmark printString!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 10:59' prior: 33632930!gol		^STMSimulation benchmark printString! !----QUIT/NOSAVE----{21 January 2014 . 11:00:27 am} Squeak4.5-12568.image priorSource: 78543!----STARTUP----{21 January 2014 . 11:00:33 am} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 11:00' prior: 33632930!gol		^ STMSimulation benchmark printString! !----SNAPSHOT----{21 January 2014 . 11:00:44 am} Squeak4.5-12568.image priorSource: 78543!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 11:04'!gol2		^ STMSimulation benchmark2 printString! !Simulation benchmark!----SNAPSHOT----{21 January 2014 . 11:06:45 am} Squeak4.5-12568.image priorSource: 79132!!STMSimulation methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:05'!print		! !!GameOfLifeField methodsFor: 'accessing' stamp: 'toma 1/21/2014 13:09' prior: 33619796!print

	| resultString |
	resultString := ''.
	(1 to: self height) do: [:y |
		(1 to: self width) do: [ :x |
			resultString := resultString , ((self data at: y at: x) = 1) ifTrue: ['[]'] ifFalse: ['. '].].
		resultString := resultString , Character cr ].
	^ resultString			! !!GameOfLifeField methodsFor: 'accessing' stamp: 'toma 1/21/2014 13:09' prior: 33634066!print

	| resultString |
	resultString := ''.
	(1 to: self height) do: [:y |
		(1 to: self width) do: [ :x |
			resultString := resultString , ((self data at: y at: x) > 0) ifTrue: ['[]'] ifFalse: ['. '].].
		resultString := resultString , Character cr ].
	^ resultString			! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:11' prior: 33624205!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		SPyVM print: (self fieldNew print).
		SPyVM print: Character cr.
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !----SNAPSHOT----{21 January 2014 . 1:11:46 pm} Squeak4.5-12568.image priorSource: 79361!!GameOfLifeField methodsFor: 'accessing' stamp: 'toma 1/21/2014 13:12' prior: 33634432!print

	| resultString |
	resultString := ''.
	(1 to: self height) do: [:y |
		(1 to: self width) do: [ :x |
			resultString := resultString , (((self data at: y at: x) > 0) ifTrue: ['[]'] ifFalse: ['. ']).].
		resultString := resultString , Character cr ].
	^ resultString			! !----SNAPSHOT----{21 January 2014 . 1:13:04 pm} Squeak4.5-12568.image priorSource: 80734!!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:32' prior: 33556598!wait		self primWait! !----SNAPSHOT----{21 January 2014 . 1:44:03 pm} Squeak4.5-12568.image priorSource: 81192!!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:48' prior: 33620913!gliderFieldRows: numberOfRows columns: numberOfColumns

	| newField |
	newField := self new rows: numberOfRows columns: numberOfColumns.
	
	newField 
		at: 8 at: 5 put: 1;
		at: 9 at: 5 put: 1;	 
		at: 10 at: 5 put: 1;
		at: 10 at: 4 put: 1;
		at: 9 at: 3 put: 1;		at: 13 at: 13 put: 1;
		at: 13 at: 14 put: 1;	 
		at: 13 at: 15 put: 1;
		at: 14 at: 13 put: 1;
		at: 12 at: 14 put: 1.
		
	^ newField! !----SNAPSHOT----{21 January 2014 . 1:48:18 pm} Squeak4.5-12568.image priorSource: 81400!!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:52' prior: 33627087!benchmark

	^ (1 to: 3) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:52' prior: 33631876!benchmark

	^ (1 to: 3) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:52' prior: 33636825!benchmark

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:52' prior: 33636623!benchmark

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:58' prior: 33627744!standardSimulation: numberOfProcesses
	SPyVM print:'================================================================'.
	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !----SNAPSHOT----{21 January 2014 . 1:58:07 pm} Squeak4.5-12568.image priorSource: 81998!!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:58'!benchmark3

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 13:59' prior: 33637887!benchmark3
	| |
	^ (1 to: 4) collect: [ :i | 
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 14:00' prior: 33638093!benchmark3
	| field |	field := GameOfLifeField gliderFieldRows: 32 columns: 32.
	^ (1 to: 4) collect: [ :i | 
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 14:00' prior: 33638307!benchmark3
	| field |	field := GameOfLifeField gliderFieldRows: 32 columns: 32.
	^ (1 to: 4) collect: [ :i | 
			[ field := self standardSimulation: (2 raisedTo: i) withField: field] timeToRun ]! !STMSimulation class removeSelector: #benchmark3!----SNAPSHOT----{21 January 2014 . 2:00:54 pm} Squeak4.5-12568.image priorSource: 83278!!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 14:04' prior: 33636027!gliderFieldRows: numberOfRows columns: numberOfColumns

	| newField |
	newField := self new rows: numberOfRows columns: numberOfColumns.
	
	newField 
		at: 8 at: 5 put: 1;
		at: 9 at: 5 put: 1;	 
		at: 10 at: 5 put: 1;
		at: 10 at: 4 put: 1;
		at: 9 at: 3 put: 1;		at: 13 at: 13 put: 1;
		at: 13 at: 14 put: 1;	 
		at: 13 at: 15 put: 1;
		at: 14 at: 13 put: 1;
		at: 12 at: 14 put: 1.			numberOfRows > 16 ifTrue: [		newField			at: 20 at: 3 put: 1;			at: 20 at: 4 put: 1;			at: 21 at: 2 put: 1;			at: 21 at: 5 put: 1;			at: 22 at: 3 put: 1;			at: 22 at: 4 put: 1.	].
		
	^ newField! !!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 14:04' prior: 33639032!gliderFieldRows: numberOfRows columns: numberOfColumns

	| newField |
	newField := self new rows: numberOfRows columns: numberOfColumns.
	
	newField 
		at: 8 at: 5 put: 1;
		at: 9 at: 5 put: 1;	 
		at: 10 at: 5 put: 1;
		at: 10 at: 4 put: 1;
		at: 9 at: 3 put: 1;		at: 13 at: 13 put: 1;
		at: 13 at: 14 put: 1;	 
		at: 13 at: 15 put: 1;
		at: 14 at: 13 put: 1;
		at: 12 at: 14 put: 1.			((numberOfRows > 16) and: (numberOfColumns > 16)) ifTrue: [		newField			at: 20 at: 3 put: 1;			at: 20 at: 4 put: 1;			at: 21 at: 2 put: 1;			at: 21 at: 5 put: 1;			at: 22 at: 3 put: 1;			at: 22 at: 4 put: 1.	].
		
	^ newField! !!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'toma 1/21/2014 14:05' prior: 33639731!gliderFieldRows: numberOfRows columns: numberOfColumns

	| newField |
	newField := self new rows: numberOfRows columns: numberOfColumns.
	
	newField 
		at: 8 at: 5 put: 1;
		at: 9 at: 5 put: 1;	 
		at: 10 at: 5 put: 1;
		at: 10 at: 4 put: 1;
		at: 9 at: 3 put: 1;		at: 13 at: 13 put: 1;
		at: 13 at: 14 put: 1;	 
		at: 13 at: 15 put: 1;
		at: 14 at: 13 put: 1;
		at: 12 at: 14 put: 1.			((numberOfRows > 16) and: (numberOfColumns > 16)) ifTrue: [		newField			at: 20 at: 3 put: 1;			at: 20 at: 4 put: 1;			at: 21 at: 2 put: 1;			at: 21 at: 5 put: 1;			at: 22 at: 3 put: 1;			at: 22 at: 4 put: 1;						at: 20 at: 20 put: 1;			at: 20 at: 21 put: 1;			at: 20 at: 22 put: 1.			].
		
	^ newField! !----SNAPSHOT----{21 January 2014 . 2:05:40 pm} Squeak4.5-12568.image priorSource: 84405!----STARTUP----{17 May 2014 . 11:47:50 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!FileStream stdout nextPutAll: 'release.st'; cr; flush.!----SNAPSHOT----{17 May 2014 . 11:48:30 pm} Squeak4.5-12568.image priorSource: 86737!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/17/2014 23:49'!stmBenchmarkTest	FileStream stdout nextPutAll: 'starting stm process.'.	"^ StmProcess new fork"! !----QUIT----{17 May 2014 . 11:49:16 pm} Squeak4.5-12568.image priorSource: 86999!----STARTUP----{17 May 2014 . 11:50:46 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!Process subclass: #StmProcess	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/17/2014 23:53' prior: 33641587!stmBenchmarkTest	FileStream stdout nextPutAll: 'starting stm process.'.	^ StmProcess new fork.! !!StmProcess methodsFor: 'nil' stamp: 'hh 5/17/2014 23:54'!fork	<primitive: 787> 	FileStream stdout nextPutAll: 'Primitive stmFork failed'.	self primitiveFailed! !!StmProcess methodsFor: 'as yet unclassified' stamp: 'hh 5/17/2014 23:55' prior: 33642264!fork		<primitive: 787> 		self primitiveFailed! !----SNAPSHOT----{17 May 2014 . 11:55:14 pm} Squeak4.5-12568.image priorSource: 87255!----QUIT----{17 May 2014 . 11:55:30 pm} Squeak4.5-12568.image priorSource: 88078!----STARTUP----{22 May 2014 . 11:48:49 am} as D:\code\python\spy-vm\lang-smalltalk\images\Squeak4.5-12568.image!!StmProcess methodsFor: 'as yet unclassified' stamp: 'pre 5/22/2014 11:49'!wait		<primitive: 789> 		self primitiveFailed! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 5/22/2014 11:50' prior: 33642105!stmBenchmarkTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := StmProcess new fork.	p join! !!StmProcess methodsFor: 'as yet unclassified' stamp: 'pre 5/22/2014 11:50'!join		<primitive: 789> 		self primitiveFailed! !StmProcess removeSelector: #wait!----QUIT----{22 May 2014 . 11:50:32 am} Squeak4.5-12568.image priorSource: 88165!----STARTUP----{22 May 2014 . 1:53:40 pm} as D:\code\python\spy-vm\lang-smalltalk\images\Squeak4.5-12568.image!!BlockClosure methodsFor: 'STM' stamp: 'pre 5/22/2014 13:58'!newStmProcess	^ StmProcess forContext: [self value] asContext priority: Processor activePriority! !!BlockClosure methodsFor: 'STM' stamp: 'pre 5/22/2014 13:59' prior: 33568777!parallelFork	^ (self newStmProcess) fork; yourself! !BlockClosure removeSelector: #newStmProcess!!BlockClosure methodsFor: 'STM' stamp: 'pre 5/22/2014 13:59' prior: 33643726!parallelFork	^ (self newSTMProcess) fork; yourself! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'pre 5/22/2014 14:00' prior: 33556280!primWait	<primitive: 789>	SPyVM print: ' Failed to wait for process!! '	self primitiveFailed.! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'pre 5/22/2014 14:00' prior: 33644052!primWait	<primitive: 789>	SPyVM print: ' Failed to wait for process!! '.	self primitiveFailed.! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'pre 5/22/2014 14:00' prior: 42636506!fork	<primitive: 787>	Transcript show: '* STM Process did not fork *' , Character cr.	self primitiveFailed.	self resume! !STMProcess removeSelector: #initialize!Process subclass: #STMProcess	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Process subclass: #STMProcess	instanceVariableNames: 'lock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 5/22/2014 14:02' prior: 33643008!stmBenchmarkTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := STMProcess new fork.	p join! !Smalltalk removeClassNamed: #StmProcess!Process subclass: #STMProcess	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Process subclass: #STMProcess	instanceVariableNames: 'lock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 5/22/2014 14:03' prior: 33644952!stmBenchmarkTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := [ 1 + 1. ] parallelFork.	p join! !----SNAPSHOT----{22 May 2014 . 2:03:31 pm} Squeak4.5-12568.image priorSource: 88855!----QUIT----{22 May 2014 . 2:06:55 pm} Squeak4.5-12568.image priorSource: 91148!----STARTUP----{22 May 2014 . 2:12:45 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 2:13:22 pm} Squeak4.5-12568.image priorSource: 91234!----STARTUP----{22 May 2014 . 2:41:04 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 14:41'!paralellForkTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := [ 1 + 1. ] parallelFork.	p join! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 14:42'!stmTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := STMProcess new.	p join! !Integer removeSelector: #stmBenchmarkTest!----QUIT----{22 May 2014 . 2:42:38 pm} Squeak4.5-12568.image priorSource: 91430!----STARTUP----{22 May 2014 . 2:45:49 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 14:46' prior: 33646317!stmTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := STMProcess new.	p wait! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 14:46' prior: 33646745!stmTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := STMProcess new.	p wait.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 14:46' prior: 33646127!paralellForkTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := [ 1 + 1. ] parallelFork.	p wait! !----QUIT----{22 May 2014 . 2:46:59 pm} Squeak4.5-12568.image priorSource: 92032!----STARTUP----{22 May 2014 . 2:47:56 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 14:48'!parallelForkTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := [ 1 + 1. ] parallelFork.	p wait! !Integer removeSelector: #paralellForkTest!----QUIT----{22 May 2014 . 2:48:13 pm} Squeak4.5-12568.image priorSource: 92811!----STARTUP----{22 May 2014 . 3:30:57 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 3:31:15 pm} Squeak4.5-12568.image priorSource: 93241!----STARTUP----{22 May 2014 . 3:31:29 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!Object subclass: #GameOfLifeField	instanceVariableNames: 'data height width'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #GameOfLifeField	instanceVariableNames: 'data height width'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!!GameOfLifeField methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:23' prior: 33618517!cellAliveAt: x at: y

	^ (self at: x at: y) = 1! !!GameOfLifeField methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:14' prior: 33618649!rows: numberOfRows columns: numberOfColumns

	self height: numberOfRows.
	self width: numberOfColumns.
	self data: (Matrix rows: numberOfRows columns: numberOfColumns element: 0).
	! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:25' prior: 33618905!at: x at:y
	
	((x < 1) or: [x > self width]) ifTrue: [ ^ 0 ].
      ((y < 1) or: [y > self height]) ifTrue: [ ^ 0 ].

	^ self data at: y at: x! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:25' prior: 33619122!at: x at:y put: aValue

	self data at: y at: x put: aValue.! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:02' prior: 33619256!atRow: rowNumber put: aRow

	self data atRow: rowNumber put: aRow! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45' prior: 33619396!data

	^ data! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45' prior: 33619484!data: anObject

	data := anObject! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45' prior: 33619592!height

	^ height! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45' prior: 33619684!height: anObject

	height := anObject! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:52' prior: 33635345!print

	| resultString |
	resultString := ''.
	(1 to: self height) do: [:y |
		(1 to: self width) do: [ :x |
			resultString := resultString , (self data at: y at: x).].
		resultString := resultString , Character cr ].
	^ resultString			! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45' prior: 33620108!rowSlice: sliceSize collect: aBlock

	! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:28' prior: 33620221!rowwiseFrom: startRow to: endRow collect: aBlock

	| newField |
	newField := GameOfLifeFieldSlice from: startRow to: endRow width: self width.
	(startRow to: endRow) do: [ :y | 
		(1 to: self width) do: [ :x | newField at: x at: y put: (aBlock value: self value: x value: y) ] ].
	^ newField! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45' prior: 33620587!width

	^ width! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45' prior: 33620677!width: anObject

	width := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GameOfLifeField class	instanceVariableNames: ''!!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:44' prior: 33640462!gliderFieldRows: numberOfRows columns: numberOfColumns

	| newField |
	newField := self new rows: numberOfRows columns: numberOfColumns.
	
	newField 
		at: 8 at: 5 put: 1;
		at: 9 at: 5 put: 1;	 
		at: 10 at: 5 put: 1;
		at: 10 at: 4 put: 1;
		at: 9 at: 3 put: 1.
		
	^ newField! !!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 20:43' prior: 33621282!rows: numberOfRows columns: numberOfColumns

	^ self new rows: numberOfRows columns: numberOfColumns! !GameOfLifeField subclass: #GameOfLifeFieldSlice	instanceVariableNames: 'startRow endRow'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!GameOfLifeField subclass: #GameOfLifeFieldSlice	instanceVariableNames: 'startRow endRow'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!!GameOfLifeFieldSlice methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 10:22' prior: 33621802!from: startRow to: endRow width: width

	self startRow: startRow;
		endRow: endRow;
		width: width;
		height: (endRow - startRow + 1);
		data: (Matrix rows: (endRow - startRow + 1) columns: width).
		
	^ self! !!GameOfLifeFieldSlice methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:31' prior: 33622100!rowwiseDo: aBlock

	self startRow to: self endRow do: [ :rowNumber |
		aBlock value: rowNumber value: (self data atRow: (rowNumber - self startRow) + 1).
	].! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:30' prior: 33622337!at: x at:y put: aValue

	self data at: y +  1 - self startRow at: x put: aValue.! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11' prior: 33622497!endRow

	^ endRow! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11' prior: 33622594!endRow: anObject

	endRow := anObject! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11' prior: 33622711!startRow

	^ startRow! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11' prior: 33622812!startRow: anObject

	startRow := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GameOfLifeFieldSlice class	instanceVariableNames: ''!!GameOfLifeFieldSlice class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 20:53' prior: 33623064!from: startRow to: endRow width: width

	^ self new from: startRow to: endRow width: width! !Object subclass: #STMSimulation	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #STMSimulation	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44' prior: 33623613!initialField: aGameOfLifeField

	self field: aGameOfLifeField.
	self fieldNew: (GameOfLifeField rows: (aGameOfLifeField height) columns: (aGameOfLifeField width)).! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:50' prior: 33623859!simulateRound: roundNumber 

	self processes: ((1 to: self numberOfProcesses) collect: [ :processNumber |
		[| rows |
		rows := self startProcess: processNumber.
		rows rowwiseDo: [ :rowNumber :aRow | self fieldNew atRow: rowNumber put: aRow ]] parallelFork. ]).
! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44' prior: 33634806!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		"Transcript show: self fieldNew print.
		Transcript show: Character cr."
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44' prior: 33624653!startProcess: processNumber

	| endOfSlice slice startOfSlice |
	slice := (self field height / self numberOfProcesses).
	startOfSlice := ((processNumber - 1) * slice) + 1.
	endOfSlice := processNumber * slice.

	^ self field rowwiseFrom: startOfSlice
					to: endOfSlice
					collect: [ :tempField :x :y | self thumbUpOrDownAt: x at: y on: tempField ]

	
	! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44' prior: 33625092!thumbUpOrDownAt: x at: y on: tempField 
	| liveCellCount |
	
	liveCellCount := (tempField at: x - 1 at: y - 1)
				+ (tempField at: x + 0 at: y - 1)
				+ (tempField at: x + 1 at: y - 1)
				+ (tempField at: x - 1 at: y + 0)
				+ (tempField at: x + 1 at: y + 0)
				+ (tempField at: x - 1 at: y + 1)
				+ (tempField at: x + 0 at: y + 1)
				+ (tempField at: x + 1 at: y + 1).
	
	(tempField cellAliveAt: x at: y)
		ifTrue: [((2 = liveCellCount)
					or: [liveCellCount = 3])
				ifTrue: [^ 1]
				ifFalse: [^ 0]]
		ifFalse: [(liveCellCount = 3)
				ifTrue: [^ 1]
				ifFalse: [^ 0]]! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33625748!field

	^ field! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33625836!field: anObject

	field := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33625944!fieldNew

	^ fieldNew! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33626038!fieldNew: anObject

	fieldNew := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33626152!fieldSlices

	^ fieldSlices! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33626252!fieldSlices: anObject

	fieldSlices := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33626372!numberOfProcesses

	^ numberOfProcesses! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33626484!numberOfProcesses: aNumber

	numberOfProcesses := aNumber
	! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33626616!processes

	^ processes! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44' prior: 33626712!processes: anObject

	processes := anObject! !!STMSimulation methodsFor: 'initialize-release' stamp: 'pre 1/21/2014 09:44' prior: 33626837!initialize

	self processes: OrderedCollection new.
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STMSimulation class	instanceVariableNames: ''!!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44' prior: 33637232!benchmark

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44' prior: 33627275!benchmark2

	^ (1 to: 5) collect: [ :i |
			[ self standardSimulation2: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44' prior: 33627465!standardSimulation2: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44' prior: 33637437!standardSimulation: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !Object subclass: #Simulation	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #Simulation	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:37' prior: 33628383!initialField: aGameOfLifeField

	self field: aGameOfLifeField.
	self fieldNew: (GameOfLifeField rows: (aGameOfLifeField height) columns: (aGameOfLifeField width)).! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:44' prior: 33628626!simulateRound: roundNumber 

	self processes: ((1 to: self numberOfProcesses) collect: [ :processNumber |
		| semaphore |
		semaphore := Semaphore new.
		[| rows |
		rows := self startProcess: processNumber.
		rows rowwiseDo: [ :rowNumber :aRow | self fieldNew atRow: rowNumber put: aRow ].
		semaphore signal] fork.
		semaphore ]).
! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:00' prior: 33629039!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		"Transcript show: self fieldNew print.
		Transcript show: Character cr."
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:34' prior: 33629484!startProcess: processNumber

	| endOfSlice slice startOfSlice |
	slice := (self field height / self numberOfProcesses).
	startOfSlice := ((processNumber - 1) * slice) + 1.
	endOfSlice := processNumber * slice.

	^ self field rowwiseFrom: startOfSlice
					to: endOfSlice
					collect: [ :tempField :x :y | self thumbUpOrDownAt: x at: y on: tempField ]

	
	! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 10:48' prior: 33629920!thumbUpOrDownAt: x at: y on: tempField 
	| liveCellCount |
	
	liveCellCount := (tempField at: x - 1 at: y - 1)
				+ (tempField at: x + 0 at: y - 1)
				+ (tempField at: x + 1 at: y - 1)
				+ (tempField at: x - 1 at: y + 0)
				+ (tempField at: x + 1 at: y + 0)
				+ (tempField at: x - 1 at: y + 1)
				+ (tempField at: x + 0 at: y + 1)
				+ (tempField at: x + 1 at: y + 1).
	
	(tempField cellAliveAt: x at: y)
		ifTrue: [((2 = liveCellCount)
					or: [liveCellCount = 3])
				ifTrue: [^ 1]
				ifFalse: [^ 0]]
		ifFalse: [(liveCellCount = 3)
				ifTrue: [^ 1]
				ifFalse: [^ 0]]! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04' prior: 33630573!field

	^ field! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04' prior: 33630658!field: anObject

	field := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:06' prior: 33630763!fieldNew

	^ fieldNew! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:06' prior: 33630854!fieldNew: anObject

	fieldNew := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:30' prior: 33630965!fieldSlices

	^ fieldSlices! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:30' prior: 33631062!fieldSlices: anObject

	fieldSlices := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:09' prior: 33631179!numberOfProcesses

	^ numberOfProcesses! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:09' prior: 33631288!numberOfProcesses: aNumber

	numberOfProcesses := aNumber
	! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04' prior: 33631417!processes

	^ processes! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04' prior: 33631510!processes: anObject

	processes := anObject! !!Simulation methodsFor: 'initialize-release' stamp: 'pre 1/19/2014 20:04' prior: 33631632!initialize

	self processes: OrderedCollection new.
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Simulation class	instanceVariableNames: ''!!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:08' prior: 33637027!benchmark

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:09' prior: 33632061!benchmark2

	^ (1 to: 5) collect: [ :i |
			[ self standardSimulation2: (2 raisedTo: i) ] timeToRun ]! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:59' prior: 33632248!standardSimulation2: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:59' prior: 33632524!standardSimulation: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !----End fileIn of /home/hub/Downloads/VM-GameOfLife.st----!!STMSimulation methodsFor: 'as yet unclassified' stamp: 'hh 5/22/2014 15:32' prior: 33654573!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		SPyVM print self fieldNew print.
		Transcript show: Character cr.
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'hh 5/22/2014 15:33' prior: 33663832!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		SPyVM print: (self fieldNew print).
		SPyVM print: (Character cr).
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !----QUIT----{22 May 2014 . 3:33:07 pm} Squeak4.5-12568.image priorSource: 93437!----STARTUP----{22 May 2014 . 3:33:13 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 15:33'!gameLifeOfLife	STMSimulation benchmark.! !----QUIT----{22 May 2014 . 3:34:03 pm} Squeak4.5-12568.image priorSource: 110218!----STARTUP----{22 May 2014 . 3:34:57 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 15:35'!gameOfLife	STMSimulation benchmark.! !Integer removeSelector: #gameLifeOfLife!----QUIT----{22 May 2014 . 3:35:14 pm} Squeak4.5-12568.image priorSource: 110526!----STARTUP----{22 May 2014 . 3:36:22 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 15:36' prior: 33665224!gameOfLife	STMSimulation benchmark2.! !----QUIT----{22 May 2014 . 3:36:45 pm} Squeak4.5-12568.image priorSource: 110873!----STARTUP----{22 May 2014 . 3:36:49 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 3:36:53 pm} Squeak4.5-12568.image priorSource: 111195!----STARTUP----{22 May 2014 . 3:36:56 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 15:37' prior: 33665587!gameOfLife	SPyVM print: STMSimulation benchmark2.! !----QUIT----{22 May 2014 . 3:37:32 pm} Squeak4.5-12568.image priorSource: 111392!----STARTUP----{22 May 2014 . 3:38:15 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 3:38:35 pm} Squeak4.5-12568.image priorSource: 111727!----STARTUP----{22 May 2014 . 3:48:40 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{22 May 2014 . 3:48:43 pm} Squeak4.5-12568.image priorSource: 111924!----STARTUP----{22 May 2014 . 4:20:56 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:21' prior: 33603722!benchStmParallel		| sum num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:25' prior: 33666837!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i |		| sum |		sum := 0. 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum.			] parallelFork		].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:26' prior: 33667525!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i |		| sum |		sum := 0. 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				 sum := sum + k. ].			localSums at: i put: sum.			] parallelFork		].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:26' prior: 33668262!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i |		| sum |		sum := 0. 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum.			] parallelFork		].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:26' prior: 33669000!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i |		| sum |		sum := 0. 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:26:33 pm} Squeak4.5-12568.image priorSource: 111924!----STARTUP----{22 May 2014 . 4:28:08 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:28' prior: 33669737!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i |		| sum |		sum := 0. 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:28:57 pm} Squeak4.5-12568.image priorSource: 115957!----STARTUP----{22 May 2014 . 4:30:39 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:31' prior: 33670666!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i |		| sum |		sum := 0. 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:31:47 pm} Squeak4.5-12568.image priorSource: 116913!----STARTUP----{22 May 2014 . 4:37:03 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 4:37:21 pm} Squeak4.5-12568.image priorSource: 117878!----STARTUP----{22 May 2014 . 4:37:56 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:38' prior: 33671622!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * max - 1)) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:38' prior: 33672784!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:38:37 pm} Squeak4.5-12568.image priorSource: 118075!----STARTUP----{22 May 2014 . 4:39:37 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!#('1' '2' '3')!#('1' '2' '3') at: 2!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:49' prior: 33673552!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads add: [		| sum |		sum := 0. 		 [((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ]].		localSums at: num put: sum.		 ]parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:49' prior: 33674559!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads add: [		| sum |		sum := 0. 		 [((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ]].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:49:24 pm} Squeak4.5-12568.image priorSource: 119810!----STARTUP----{22 May 2014 . 4:49:54 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:50' prior: 33675489!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.		threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads add: [		| sum |		sum := 0. 		 [((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ]].		localSums at: num put: sum.		] parallelFork.	SPyVM print: 'bar'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:50:32 pm} Squeak4.5-12568.image priorSource: 121907!----STARTUP----{22 May 2014 . 4:50:54 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:52' prior: 33676616!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	SPyVM print: 'bar'.	threads add: [		| sum |		sum := 0. 		 [((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ]].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:52' prior: 33677764!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	SPyVM print: 'bar'.	threads add: [		| sum |		sum := 0. 		 [((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ]].		localSums at: num put: sum.		] parallelFork.		SPyVM print: 'bar2'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:52:16 pm} Squeak4.5-12568.image priorSource: 123055!----STARTUP----{22 May 2014 . 4:52:32 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:52' prior: 33678717!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads add: ([		| sum |		sum := 0. 		 [((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ]].		localSums at: num put: sum.		] parallelFork).		SPyVM print: 'bar2'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:52:57 pm} Squeak4.5-12568.image priorSource: 125181!----STARTUP----{22 May 2014 . 4:53:15 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 4:54:05 pm} Squeak4.5-12568.image priorSource: 126335!----STARTUP----{22 May 2014 . 4:54:23 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:56' prior: 33679890!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].		SPyVM print: self-num-max.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:56' prior: 33681241!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].		SPyVM print: self-num-max.	SPyVM print: self-num.		threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:56:21 pm} Squeak4.5-12568.image priorSource: 126532!----STARTUP----{22 May 2014 . 4:56:41 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:58' prior: 33682201!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:58' prior: 33683383!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ] asOrderedCollection.	threads  add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 16:58' prior: 33684335!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 4:58:37 pm} Squeak4.5-12568.image priorSource: 128674!----STARTUP----{22 May 2014 . 5:20:50 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 5:21:16 pm} Squeak4.5-12568.image priorSource: 131728!----STARTUP----{22 May 2014 . 5:21:29 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:21' prior: 33685288!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	SPyVM print: '1'.	SPyVM print: localSums asString.	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:22' prior: 33686634!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	SPyVM print: '1:'.	SPyVM print: localSums asString.	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '2:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:22:18 pm} Squeak4.5-12568.image priorSource: 131925!----STARTUP----{22 May 2014 . 5:22:42 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:23' prior: 33687638!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	SPyVM print: '1:'.	SPyVM print: threads asString.	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '2:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:23:22 pm} Squeak4.5-12568.image priorSource: 134149!----STARTUP----{22 May 2014 . 5:23:33 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:25' prior: 33688858!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].			SPyVM print: 'xx'.			SPyVM print: sum.		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '2:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----SNAPSHOT----{22 May 2014 . 5:25:10 pm} Squeak4.5-12568.image priorSource: 135367!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:25' prior: 33690076!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].			SPyVM print: 'xx'.			SPyVM print: sum.		localSums at: num put: sum.		] parallelFork.	SPyVM print: threads.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '2:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:25:30 pm} Squeak4.5-12568.image priorSource: 136577!----STARTUP----{22 May 2014 . 5:25:55 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 5:26:05 pm} Squeak4.5-12568.image priorSource: 137699!----STARTUP----{22 May 2014 . 5:26:27 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 5:28:45 pm} Squeak4.5-12568.image priorSource: 137896!----STARTUP----{22 May 2014 . 5:29:05 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{22 May 2014 . 5:29:16 pm} Squeak4.5-12568.image priorSource: 138093!----STARTUP----{22 May 2014 . 5:29:48 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 5:30:10 pm} Squeak4.5-12568.image priorSource: 138093!----STARTUP----{22 May 2014 . 5:30:41 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 5:31 pm} Squeak4.5-12568.image priorSource: 138494!----STARTUP----{22 May 2014 . 5:31:19 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{22 May 2014 . 5:31:35 pm} Squeak4.5-12568.image priorSource: 138691!----STARTUP----{22 May 2014 . 5:32:08 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:32' prior: 33691176!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].		SPyVM print: 'yy'.	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].			SPyVM print: 'xx'.			SPyVM print: sum.		localSums at: num put: sum.		] parallelFork.	SPyVM print: 'sss'.	SPyVM print: threads.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside methodaaaaaaaaaaaaaaaaaa:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '23:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:32:31 pm} Squeak4.5-12568.image priorSource: 138691!----STARTUP----{22 May 2014 . 5:32:45 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:33' prior: 33693601!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].		SPyVM print: 'yy'.	threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		SPyVM print: 'xx'.		SPyVM print: sum.		localSums at: num put: sum.		] parallelFork.	SPyVM print: threads asString, ' threads'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '23:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:34:02 pm} Squeak4.5-12568.image priorSource: 140184!----STARTUP----{22 May 2014 . 5:34:15 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:35' prior: 33694893!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].		SPyVM print: 'yy'.	threads = threads asOrderedCollection add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		SPyVM print: 'xx'.		SPyVM print: sum.		localSums at: num put: sum.		] parallelFork.	SPyVM print: threads asString, ' threads'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '23:'.	SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:35' prior: 33696165!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. ].		localSums at: i put: sum. ] parallelFork ].		SPyVM print: 'yy'.	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		SPyVM print: 'xx'.		SPyVM print: sum.		localSums at: num put: sum.		] parallelFork.	SPyVM print: threads asString, ' threads'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '23:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:35:23 pm} Squeak4.5-12568.image priorSource: 141456!----STARTUP----{22 May 2014 . 5:40:42 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:42' prior: 33697250!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. 				SPyVM print: 'from', ( (i-1) * max) asString, 'to', (i * (max - 1)) asString.				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	SPyVM print: threads asString, ' threads'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '23:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:42:11 pm} Squeak4.5-12568.image priorSource: 143834!----STARTUP----{22 May 2014 . 5:42:33 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:42' prior: 33698543!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * (max - 1))) do: [ :k | 				 sum := sum + k. 				].		SPyVM print: 'from', ( (i-1) * max) asString, 'to', (i * (max - 1)) asString.		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	SPyVM print: threads asString, ' threads'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '23:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:42:55 pm} Squeak4.5-12568.image priorSource: 145152!----STARTUP----{22 May 2014 . 5:43:27 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{22 May 2014 . 5:43:55 pm} Squeak4.5-12568.image priorSource: 146468!----STARTUP----{22 May 2014 . 5:44:27 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:45' prior: 33699861!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: (i * max - 1)) do: [ :k | 				 sum := sum + k. 				].		SPyVM print: 'from', ( (i-1) * max) asString, 'to', ((i * max) - 1) asString.		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	SPyVM print: threads asString, ' threads'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '23:'.	SPyVM print: localSums asString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:45' prior: 33701374!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		SPyVM print: 'from', ( (i-1) * max) asString, 'to', ((i * max) - 1) asString.		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	SPyVM print: threads asString, ' threads'.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '23:'.	SPyVM print: localSums asString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:45:21 pm} Squeak4.5-12568.image priorSource: 146665!----STARTUP----{22 May 2014 . 5:46:08 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 5/22/2014 17:46' prior: 33702491!benchStmParallel		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !----QUIT----{22 May 2014 . 5:46:37 pm} Squeak4.5-12568.image priorSource: 149098!----STARTUP----{2 June 2014 . 11:04:06 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:06'!benchStmParallelWarmed		| num threads max start localSums |		num := self \\ 100.	max := (self - num) // num.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:06' prior: 33704928!benchStmParallelWarmed		! !!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:09' prior: 33705873!benchStmParallelWarmed		3 timesRepeat: [1 benchStmParallel].! !!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:09' prior: 33705981!benchStmParallelWarmed		3 timesRepeat: [SPyVM print: 1 benchStmParallel].! !----SNAPSHOT----{2 June 2014 . 11:09:59 am} Squeak4.5-12568.image priorSource: 150235!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:10' prior: 33706125!benchStmParallelWarmed		3 timesRepeat: [1 benchStmParallel].! !----SNAPSHOT----{2 June 2014 . 11:10:29 am} Squeak4.5-12568.image priorSource: 151771!----QUIT----{2 June 2014 . 11:10:32 am} Squeak4.5-12568.image priorSource: 152003!----STARTUP----{2 June 2014 . 11:20:35 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:20' prior: 33706370!benchStmParallelWarmed		3 timesRepeat: [SPyVM print: (1 benchStmParallel)].! !----QUIT----{2 June 2014 . 11:21:01 am} Squeak4.5-12568.image priorSource: 152091!----STARTUP----{2 June 2014 . 11:21:35 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{2 June 2014 . 11:22:41 am} Squeak4.5-12568.image priorSource: 152449!----STARTUP----{2 June 2014 . 11:23:17 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:23' prior: 33706801!benchStmParallelWarmed		3 timesRepeat: [SPyVM print: (self benchStmParallel)].! !----QUIT----{2 June 2014 . 11:23:36 am} Squeak4.5-12568.image priorSource: 152648!----STARTUP----{2 June 2014 . 11:25:39 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:25' prior: 33707358!benchStmParallelWarmed		10 timesRepeat: [SPyVM print: (self benchStmParallel)].! !----QUIT----{2 June 2014 . 11:25:46 am} Squeak4.5-12568.image priorSource: 153009!----STARTUP----{2 June 2014 . 11:25:48 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{2 June 2014 . 11:25:56 am} Squeak4.5-12568.image priorSource: 153371!----STARTUP----{2 June 2014 . 11:26:31 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:26' prior: 33707719!benchStmParallelWarmed		100 timesRepeat: [SPyVM print: (self benchStmParallel)].! !----QUIT----{2 June 2014 . 11:26:36 am} Squeak4.5-12568.image priorSource: 153570!----STARTUP----{2 June 2014 . 11:26:38 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{2 June 2014 . 11:26:42 am} Squeak4.5-12568.image priorSource: 153933!----STARTUP----{2 June 2014 . 11:27:14 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/2/2014 11:27' prior: 33708280!benchStmParallelWarmed		10 timesRepeat: [SPyVM print: (self benchStmParallel)].! !----QUIT----{2 June 2014 . 11:27:19 am} Squeak4.5-12568.image priorSource: 154132!----STARTUP----{5 June 2014 . 1:39:24 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:45'!benchStmThreadCreation		| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := [(1 to: self)		do: [:t1 | SPyVM print: 'Thread 1 reporting!!']] parallelFork.	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:45' prior: 33709187!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := [(1 to: self)		do: [:t1 | SPyVM print: 'Thread 1 reporting!!']] parallelFork.	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:45' prior: 33709650!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := [(1 to: self)		do: [:t1 | SPyVM print: 'Thread reporting!!']] parallelFork.	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:50' prior: 33710111!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := [(1 to: self)		do: []] parallelFork.	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !----QUIT----{5 June 2014 . 1:50:23 pm} Squeak4.5-12568.image priorSource: 154494!----STARTUP----{5 June 2014 . 1:51:28 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:51' prior: 33710570!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := [(1 to: self)		do: [1+1]] parallelFork.	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !----QUIT----{5 June 2014 . 1:51:37 pm} Squeak4.5-12568.image priorSource: 156479!----STARTUP----{5 June 2014 . 1:52:09 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:53' prior: 33711187!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := [(1 to: self) do: [1+1] parallelFork.]	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !----QUIT----{5 June 2014 . 1:53:31 pm} Squeak4.5-12568.image priorSource: 157099!----STARTUP----{5 June 2014 . 1:53:59 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:54' prior: 33711807!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := [(1 to: self) do: [1+1]] parallelFork.	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:55' prior: 33712425!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := (1 to: self) do: [[1+1] parallelFork].	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !----QUIT----{5 June 2014 . 1:55:56 pm} Squeak4.5-12568.image priorSource: 157717!----STARTUP----{5 June 2014 . 1:55:58 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{5 June 2014 . 1:56:05 pm} Squeak4.5-12568.image priorSource: 158756!----STARTUP----{5 June 2014 . 1:56:36 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:56' prior: 33712846!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := (1 to: self) collect: [[1+1] parallelFork].	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !----QUIT----{5 June 2014 . 1:56:46 pm} Squeak4.5-12568.image priorSource: 158953!----STARTUP----{5 June 2014 . 1:57:51 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:58' prior: 33713661!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := (1 to: self) collect: [[SPyVM print: 'hello'.] parallelFork].	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !----QUIT----{5 June 2014 . 1:58:24 pm} Squeak4.5-12568.image priorSource: 159576!----STARTUP----{5 June 2014 . 1:58:49 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:59' prior: 33714284!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := (1 to: self) collect: [:t | [] parallelFork].	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 13:59' prior: 33714925!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := (1 to: self) collect: [:t | [1+1] parallelFork].	threads do: [:t | t wait].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.! !----QUIT----{5 June 2014 . 1:59:39 pm} Squeak4.5-12568.image priorSource: 160217!----STARTUP----{5 June 2014 . 2:03:19 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'hh 6/5/2014 14:03' prior: 33715353!benchStmThreadCreation	| threads start |		SPyVM print: ('Threads:', (self printString)).		start := Time now asNanoSeconds.		threads := (1 to: self) collect: [:t | [1+1] parallelFork].	threads do: [:t | t wait].		SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	SPyVM print: '[squeak] milliseconds inside method:'.! !----QUIT----{5 June 2014 . 2:03:37 pm} Squeak4.5-12568.image priorSource: 161273!----STARTUP----{5 June 2014 . 2:07:05 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{5 June 2014 . 2:09:13 pm} Squeak4.5-12568.image priorSource: 161902!----STARTUP----{11 June 2014 . 8:00:13 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!SystemOrganization addCategory: #SMark!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 0!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59'!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00'!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper'!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper'!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper'!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper'!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper'!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper'!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper'!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults'!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults'!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults'!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41'!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking'!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19'!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 0!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59'!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20'!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20'!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper'!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper'!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults'!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06'!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38'!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26'!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing'!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29'!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27'!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17'!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing'!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing'!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31'!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 0!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting'!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting'!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting'!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting'!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13'!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization'!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing'!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing'!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing'!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults'!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults'!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting'!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting'!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 0!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing'!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing'!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing'!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing'!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing'!suite
	^ suite! !!SMarkResult methodsFor: 'accessing'!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing'!total
	^ time! !!SMarkResult methodsFor: 'accessing'!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28'!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01'!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05'!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10'!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20'!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20'!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08'!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44'!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08'!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08'!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46'!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41'!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45'!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14'!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50'!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42'!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13'!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50'!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47'!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43'!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09'!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56'!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51'!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51'!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59'!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27'!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49'!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18'!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18'!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17'!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 0!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51'!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26'!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57'!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 0!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24'!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28'!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28'!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34'!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34'!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19'!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31'!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59'!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49'!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46'!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08'!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03'!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08'!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41'!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02'!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40'!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23'!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 0!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper'!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper'!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running'!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running'!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running'!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking'!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17'!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31'!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking'!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking'!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking'!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking'!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing'!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing'!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults'!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43'!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking'!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking'!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking'!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20'!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22'!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30'!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21'!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17'!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24'!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54'!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24'!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25'!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32'!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54'!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 0!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46'!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13'!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17'!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43'!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43'!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54'!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53'!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43'!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50'!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42'!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20'!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20'!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21'!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21'!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22'!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33'!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34'!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15'!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-BinaryTrees'!SMarkSuite subclass: #CPBBinaryTreeBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-BinaryTrees'!SMarkSuite subclass: #CPBBinaryTreeBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-BinaryTrees'!!CPBBinaryTreeBenchmark methodsFor: 'testing' stamp: 'MP 1/27/2014 14:10'!benchBinaryTree
	"starts the binary tree benchmark"
	
	self binarytrees: 10 .! !!CPBBinaryTreeBenchmark methodsFor: 'testing' stamp: 'MP 1/15/2014 14:58'!binarytrees: n
   | minDepth maxDepth stretchDepth check longLivedTree iterations |
   minDepth := 4.
   maxDepth := minDepth + 2 max: n.
   stretchDepth := maxDepth + 1.

   check := (CPBTreeNode bottomUpTree: 0 depth: stretchDepth) itemCheck.
  
   longLivedTree := CPBTreeNode bottomUpTree: 0 depth: maxDepth.
   minDepth to: maxDepth by: 2 do: [:depth|
      iterations := 1 bitShift: maxDepth - depth + minDepth.

      check := 0.
      1 to: iterations do: [:i|
         check := check + (CPBTreeNode bottomUpTree: i depth: depth) itemCheck.
         check := check + (CPBTreeNode bottomUpTree: -1*i depth: depth) itemCheck
         ].
      ].! !Object subclass: #CPBTreeNode	instanceVariableNames: 'left right item'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-BinaryTrees'!Object subclass: #CPBTreeNode
	instanceVariableNames: 'left right item'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-BinaryTrees'!!CPBTreeNode methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:54'!itemCheck
   ^left isNil 
      ifTrue: [item] ifFalse: [item + (left itemCheck - right itemCheck)]! !!CPBTreeNode methodsFor: 'initialize-release' stamp: 'MP 12/11/2013 21:52'!left: leftChild right: rightChild item: anItem
   left := leftChild.
   right := rightChild.
   item := anItem! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBTreeNode class
	instanceVariableNames: ''!!CPBTreeNode class methodsFor: 'instance creation' stamp: 'MP 12/11/2013 21:54'!bottomUpTree: anItem depth: anInteger
   ^(anInteger > 0) 
      ifTrue: [
         self 
            left: (self bottomUpTree: 2*anItem - 1 depth: anInteger - 1) 
            right: (self bottomUpTree: 2*anItem depth: anInteger - 1)  
            item: anItem
         ]
      ifFalse: [self left: nil right: nil item: anItem]! !!CPBTreeNode class methodsFor: 'instance creation' stamp: 'MP 12/11/2013 21:55'!left: leftChild right: rightChild item: anItem      
   ^(super new) left: leftChild right: rightChild item: anItem! !----QUIT/NOSAVE----{11 June 2014 . 8:01:04 pm} Squeak4.5-12568.image priorSource: 162099!----STARTUP----{11 June 2014 . 8:02:40 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'hh 6/11/2014 20:03' prior: 40899561!snapshot: t1 andQuit: t2       """	^ self		snapshot: t1		andQuit: t2		embedded: false """! !SystemOrganization addCategory: #SMark!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 0!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59'!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00'!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper'!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper'!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper'!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper'!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper'!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper'!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper'!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults'!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults'!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults'!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41'!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking'!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19'!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 0!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59'!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20'!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20'!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper'!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper'!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults'!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06'!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38'!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26'!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing'!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29'!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27'!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17'!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing'!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing'!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31'!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 0!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting'!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting'!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting'!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting'!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13'!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization'!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing'!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing'!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing'!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults'!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults'!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting'!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting'!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 0!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing'!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing'!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing'!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing'!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing'!suite
	^ suite! !!SMarkResult methodsFor: 'accessing'!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing'!total
	^ time! !!SMarkResult methodsFor: 'accessing'!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28'!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01'!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05'!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10'!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20'!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20'!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08'!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44'!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08'!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08'!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46'!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41'!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45'!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14'!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50'!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42'!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13'!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50'!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47'!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43'!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09'!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56'!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51'!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51'!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59'!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27'!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49'!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18'!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18'!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17'!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 0!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51'!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26'!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57'!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 0!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24'!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28'!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28'!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34'!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34'!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19'!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31'!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59'!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49'!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46'!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08'!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03'!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08'!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41'!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02'!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40'!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23'!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 0!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper'!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper'!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running'!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running'!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running'!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking'!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17'!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31'!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking'!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking'!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking'!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking'!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing'!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing'!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults'!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43'!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking'!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking'!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking'!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20'!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22'!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30'!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21'!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17'!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24'!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54'!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24'!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25'!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32'!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54'!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 0!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46'!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13'!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17'!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43'!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43'!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54'!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53'!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43'!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50'!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42'!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20'!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20'!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21'!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21'!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22'!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33'!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34'!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15'!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-BinaryTrees'!SMarkSuite subclass: #CPBBinaryTreeBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-BinaryTrees'!SMarkSuite subclass: #CPBBinaryTreeBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-BinaryTrees'!!CPBBinaryTreeBenchmark methodsFor: 'testing' stamp: 'MP 1/27/2014 14:10'!benchBinaryTree
	"starts the binary tree benchmark"
	
	self binarytrees: 10 .! !!CPBBinaryTreeBenchmark methodsFor: 'testing' stamp: 'MP 1/15/2014 14:58'!binarytrees: n
   | minDepth maxDepth stretchDepth check longLivedTree iterations |
   minDepth := 4.
   maxDepth := minDepth + 2 max: n.
   stretchDepth := maxDepth + 1.

   check := (CPBTreeNode bottomUpTree: 0 depth: stretchDepth) itemCheck.
  
   longLivedTree := CPBTreeNode bottomUpTree: 0 depth: maxDepth.
   minDepth to: maxDepth by: 2 do: [:depth|
      iterations := 1 bitShift: maxDepth - depth + minDepth.

      check := 0.
      1 to: iterations do: [:i|
         check := check + (CPBTreeNode bottomUpTree: i depth: depth) itemCheck.
         check := check + (CPBTreeNode bottomUpTree: -1*i depth: depth) itemCheck
         ].
      ].! !Object subclass: #CPBTreeNode	instanceVariableNames: 'left right item'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-BinaryTrees'!Object subclass: #CPBTreeNode
	instanceVariableNames: 'left right item'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-BinaryTrees'!!CPBTreeNode methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:54'!itemCheck
   ^left isNil 
      ifTrue: [item] ifFalse: [item + (left itemCheck - right itemCheck)]! !!CPBTreeNode methodsFor: 'initialize-release' stamp: 'MP 12/11/2013 21:52'!left: leftChild right: rightChild item: anItem
   left := leftChild.
   right := rightChild.
   item := anItem! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBTreeNode class
	instanceVariableNames: ''!!CPBTreeNode class methodsFor: 'instance creation' stamp: 'MP 12/11/2013 21:54'!bottomUpTree: anItem depth: anInteger
   ^(anInteger > 0) 
      ifTrue: [
         self 
            left: (self bottomUpTree: 2*anItem - 1 depth: anInteger - 1) 
            right: (self bottomUpTree: 2*anItem depth: anInteger - 1)  
            item: anItem
         ]
      ifFalse: [self left: nil right: nil item: anItem]! !!CPBTreeNode class methodsFor: 'instance creation' stamp: 'MP 12/11/2013 21:55'!left: leftChild right: rightChild item: anItem      
   ^(super new) left: leftChild right: rightChild item: anItem! !| writer runner |
runner := (CPBBinaryTreeBenchmark) run: 10 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'. 
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/BinaryTrees.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 33769851!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 33770675!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 33770809!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33770986!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33771176!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33771759!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33772226!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33772649!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33772885!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33773054!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33773461!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33773635!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33773731!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 33773852!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 33774115!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 33774573!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 33775459!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 33775872!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 33776001!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 33776425!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 33777003!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 33777160!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 33777317!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 33777429!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 33778136!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33778510!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33778877!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33779174!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 33779569!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33779696!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 33780894!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 33781014!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 33781329!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 33782115!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33782484!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33782609!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 33782746!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 33783232!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33783713!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33783791!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33783906!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33783991!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 33784185!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 33784438!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33784540!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33784626!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33784862!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 33785054!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 33785144!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 33785242!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 33785370!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 33785904!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33786336!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33786404!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33786490!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33786552!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33786656!suite
	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33786712!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33786802!total
	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33786857!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 33787373!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 33787650!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 33788041!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 33788180!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 33788426!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 33788531!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 33788658!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 33788762!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 33789053!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 33789308!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 33789535!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 33789671!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 33789767!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 33789859!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 33790010!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 33790356!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 33790766!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 33791204!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 33791317!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 33791642!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 33791911!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 33792024!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 33792136!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 33792249!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 33792384!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 33792984!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 33793147!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 33793870!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 33794711!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 33795140!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 33795281!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 33795583!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 33796164!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 33796439!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 33796576!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 33797184!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 33797684!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 33797965!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 33798131!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 33798293!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 33798440!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 33798692!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 33798958!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 33799219!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 33799825!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 33800328!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 33800556!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 33800811!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 33801127!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 33802342!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 33802721!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 33803492!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 33803711!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 33804187!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 33804582!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 33805108!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 33805350!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33805493!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33805734!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33805865!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33805998!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 33806284!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 33806525!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33806714!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33807201!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33807500!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33807617!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 33807698!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 33807755!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 33807941!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 33808049!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33808173!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33808414!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33808508!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 33808672!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 33808890!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 33809057!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 33809272!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 33809411!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 33809818!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33810131!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 33810246!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 33810359!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 33810638!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33810762!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33810850!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33810958!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33811177!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 33811583!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 33812104!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 33812735!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 33813820!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33814077!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33814285!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 33814515!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 33814632!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 33814763!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33815170!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 33815403!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 33815748!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 33816340!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 33816489!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 33816629!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 33816752!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 33816874!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 33817210!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 33817887!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15' prior: 33818185!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-SplayTree'!SMarkSuite subclass: #CPBSplayTreeBenchmark	instanceVariableNames: 'splayTree kSplayTreeSize kSplayTreeModifications kSplayTreePayloadDepth keyCounter'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!SMarkSuite subclass: #CPBSplayTreeBenchmark
	instanceVariableNames: 'splayTree kSplayTreeSize kSplayTreeModifications kSplayTreePayloadDepth keyCounter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-SplayTree'!!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:48'!benchSplayTree
	"replace a few nodes in the splay tree."
	
	| key greatest |
	
	1 to: kSplayTreeModifications do: [:i|
		key := self insertNewNode.
		greatest := self splayTree findGreatestLessThan: key.
		greatest ifNil: [
			self splayTree remove: key.
		] ifNotNil: [
			self splayTree remove: greatest key.
		].
	].! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:39'!generateKey
	^ (keyCounter := keyCounter + 1)! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:39'!generatePayloadTreeWithDepth: depth andTag: tag
	(depth = 0) ifTrue: [
		^ Dictionary new
			at: #array put: {0. 1. 2. 3. 4. 5. 6. 7. 8. 9};
			at: #string put: 'String for key ', tag, ' in leaf node';
			yourself.
	] ifFalse: [
		^ Dictionary new
			at: #left put: (self generatePayloadTreeWithDepth: depth - 1 andTag: tag);
			at: #right put: (self generatePayloadTreeWithDepth: depth - 1 andTag: tag);
			yourself.
	]! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:23'!insertNewNode
	"insert new node with a unique key"
	
	| key payload | 
	
	key := self generateKey.
	Transcript show: 'entering insertNewNode key: '.
	Transcript show: key.
	Transcript showln: ''.
	
	[ (self splayTree find: key) isNil ] whileFalse:
	[
		key := self generateKey.
	].

	payload := self generatePayloadTreeWithDepth: self splayTreePayloadDepth andTag: key.
	self splayTree insert: key value: payload.
	^ key.! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:24'!setUp	
	splayTree := nil.
	kSplayTreeSize := 100. "8000"
	kSplayTreeModifications := 80. "80."
	kSplayTreePayloadDepth := 5.
	keyCounter := 0.
	
	Transcript showln: 'entering SplayTree setup'.
	
	self splayTree: (CPBSplaytree new).
	
	1 to: self splayTreeSize do: [:i |
		self insertNewNode.
	]! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:40'!splayTree
	^ splayTree! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:40'!splayTree: aSplayTree
	splayTree := aSplayTree.! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:40'!splayTreePayloadDepth
	^ kSplayTreePayloadDepth! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:40'!splayTreeSize
	^ kSplayTreeSize! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:52'!tearDown
	"allow gc to reclaim the memory
	 used by the splay tree no matter how we exit the tear down function"
	
	| keys length |

	keys := self splayTree exportKeys.
	self splayTree: nil.
	
	"Verify that the splay tree has the right size."
	length := keys size.
	Transcript show: length.
	Transcript show: '';cr.
	Transcript show: (self splayTreeSize).
	( length ~= self splayTreeSize ) ifTrue: [
		Error signal: 'Splay tree has wrong size.'.
		Transcript show: 'Splay tree has wrongsize.'; cr .
	].

	"Verify that the splay tree has sorted, unique keys."
	1 to: (length-1) do: [:i|
		( (keys at: i) >= (keys at: ( i + 1) )) ifTrue: [
			Error signal: 'Splay tree not sorted'.
		].
	].
	! !Object subclass: #CPBSplaytree	instanceVariableNames: 'rootNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!Object subclass: #CPBSplaytree
	instanceVariableNames: 'rootNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-SplayTree'!!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:41'!exportKeys
	"Returns an array containing all the keys of tree's nodes"
	
	| result |
	
	result :=  OrderedCollection new.
	
	( self isEmpty ) ifFalse: [
		
		self rootNode traverse: [ :node | result add: node key.].
	].

	^ result.! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:41'!find: aKey
	"Returns the node having the specified key or nil if the tree doesn't contain
	 a node with the specified key.
	
	aKey Key to find in the tree."

	( self isEmpty ) ifTrue: [
		^ nil.
	] ifFalse: [
		self splay: aKey.
		
		( self rootNode key == aKey ) ifTrue: [
			^ self rootNode.
		] ifFalse: [
			^ nil.
		]
	].! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!findGreatestLessThan: aKey
	"Returns the node having the maximum key value 
	 that is less than the specified key value."
	
	( self isEmpty ) ifTrue: [
		^ nil.
	] ifFalse: [
		"splay on the key to move the node with the given key or the last
		 node on the search path to the top of the tree."
		
		self splay: aKey.
		
		"now the result is either the root node or the greatest node in
		 the left subtree."
		
		( self rootNode key < aKey ) ifTrue: [
			^ self rootNode.
		] ifFalse: [
			self rootNode left ifNotNil: [
				^ self findMax: ( self rootNode left ).
			] ifNil: [
				^ nil.
			]
		]
	].! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!findMax
	^self findMax: self rootNode! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:49'!findMax: optStartNode
	"Return the node having the maximum key value."
	
	( self isEmpty ) ifTrue: [
		^ nil.
	] ifFalse: [
		| current |
		current := optStartNode.
		
		[current] whileNotNil: [
			current := current right.
		].
		^ current
	].! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:41'!initialize
	rootNode := nil.
	Transcript show: 'splay tree created'; cr.! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!insert: aKey value: aValue
	"Inserts a node into the tree with the specified key and value if the tree does not already contain
	 a node with the specified key. If the value is inserted, it becomes the root of the tree.
	
	aKey Key to insert into the tree.
	aValue Value to insert into the tree."
		
	( self isEmpty ) ifTrue: [
		 rootNode := CPBSplaytreeNode newWithKey: aKey andValue: aValue.
	] ifFalse: [
		"Splay on the key to move the last node on the search path for the key to the root of the tree."
		| node |
		
		self splay: aKey.
		( self rootNode key = aKey) ifTrue: [
			^ self
		].
		
		node := CPBSplaytreeNode new.
		node key: aKey.
		node value: aValue.
			
		( aKey > self rootNode key ) ifTrue: [
			node left: self rootNode.
			node right: self rootNode right.
			self rootNode right: nil.
		] ifFalse: [
			node right: self rootNode.
			node left: self rootNode left.
			self rootNode left: nil.
		].
	
		self rootNode: node.
	]! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!isEmpty
	"Says whether the tree is empty"
	^ (rootNode isNil).! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:36'!remove: aKey
	"Removes a node with the specified key from the tree if the tree contains a node with this key.
	 The removed node is returned. If the key is not found, an exception is thrown.
	
	 aKey Key to find and remove from the tree.
	 Returns the removed node."
	
	| removed right |
	
	( self isEmpty ) ifTrue: [
		Error signal: 'Key not found.'.
	].

	self splay: aKey.
		
	(self rootNode key ~= aKey) ifTrue: [
		Error signal: 'Key not found.'.
	].
	
	removed := self rootNode.
		
	self rootNode left ifNil: [
		self rootNode: self rootNode right.
	] ifNotNil: [
		right := self rootNode right.
		self rootNode: self rootNode left.
			
		"Splay to make sure that the new root has an empty right child."
		self splay: aKey.
			
		"insert the original right child as the right child of the new root."
		self rootNode right: right.
	].

	^ removed! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!rootNode

	^ rootNode! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!rootNode: anObject

	rootNode := anObject! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:46'!splay: aKey
	"Perform the splay operation for the given key. Moves the node with
	the given key to the top of the tree.  If no node has the given
	key, the last node on the search path is moved to the top of the
	tree. This is the simplified top-down splaying algorithm from:
	'Self-adjusting Binary Search Trees by Sleator and Tarjan'
	
	aKey Key to splay the tree on"
	
	| dummy left right current looping|
	
	"init"
	dummy := CPBSplaytreeNode new.	
	left := dummy.
	right := dummy.
	
	current := self rootNode.
	
	looping := true.
	[looping] whileTrue: [
			( aKey < (current key) ) ifTrue: [	
				( current left isNil ) ifTrue: [
					looping := false.
				] ifFalse: [
					( aKey < current left key) ifTrue: [
						"rotate right"
						| tmp |
						tmp := current left.
						current left: ( tmp right).
						tmp right: current.
						current := tmp.
					
						current left ifNil: [
							looping := false.
						].
					].
					looping ifTrue:[
						"link right"
						right left: current.
						right := current.
						current := current left.
					]
				].
			] ifFalse: [
				( aKey > current key ) ifTrue: [
					( current right isNil ) ifTrue: [
						looping := false.
					] ifFalse: [
				
						( aKey > current right key ) ifTrue: [
							"rotate left"
							| tmp |
							tmp := current right.
							current right: ( tmp left ).
							tmp left: current.
							current := tmp.
						
							current right ifNil: [
								looping := false.
							].
						].
					
						looping ifTrue: [
							"link left"
							left right: current.
							left := current.
							current := current right.
						]
					].
				] ifFalse: [
					looping := false.
				].
			].
	 ].

	"assemble"
	
	left right: ( current left ).
	right left: ( current right ).
	current left: ( dummy right ).
	current right: ( dummy left ).
	self rootNode: current.! !Object subclass: #CPBSplaytreeNode	instanceVariableNames: 'key value left right'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!Object subclass: #CPBSplaytreeNode
	instanceVariableNames: 'key value left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-SplayTree'!!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:36'!initialize
	self left: nil.
	self right: nil.! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!key

	^ key! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!key: anObject

	key := anObject! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!left

	^ left! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!left: anObject

	left := anObject! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!right

	^ right! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!right: anObject

	right := anObject! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:29'!traverse: aBlock

	"Performs an ordered traversal of the subtree starting at this SplaytreeNode
	 aBlock is a visitor function"
	
	| current |
	
	current := self.
	[current] whileNotNil: [
		| left |
		left := current left.
		
		left ifNotNil: [
			left traverse: aBlock.
		].
		aBlock value: current.
		current := current right.
	].! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!value

	^value! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!value: anObject

	value := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBSplaytreeNode class
	instanceVariableNames: ''!!CPBSplaytreeNode class methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:38'!newWithKey: aKey andValue: aValue 
	^ self new key: aKey;
		 value: aValue;
		 yourself! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBSplaytreeNode class
	instanceVariableNames: ''!!CPBSplaytreeNode class methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:38' prior: 33887246!newWithKey: aKey andValue: aValue 
	^ self new key: aKey;
		 value: aValue;
		 yourself! !| writer runner |
runner := (CPBSplayTreeBenchmark) run: 10 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'. 
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/SplayTree.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!"Based on: https://github.com/garduino/Cuis-Smalltalk-Cryptography/blob/master/Blowfish.pck.st"
"Modified to be loadable in Squeak Smalltalk and run a little faster"

Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 33822475!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 33823315!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 33823465!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33823668!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33823884!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33824493!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33824986!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33825435!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33825697!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33825892!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33826325!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33826525!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33826647!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 33826784!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 33827073!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 33827547!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 33828440!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 33828869!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 33829014!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 33829454!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 33830058!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 33830241!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 33830424!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 33830552!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 33831275!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33831675!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33832068!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33832391!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 33832802!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33832955!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 33834179!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 33834315!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 33834646!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 33835448!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33835843!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33835994!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 33836147!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 33836640!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33837147!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33837251!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33837392!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33837503!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 33837713!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 33837992!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33838120!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33838232!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33838494!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 33838712!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 33838828!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 33838952!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 33839106!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 33839647!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33840105!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33840199!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33840311!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33840399!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33840529!suite
	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33840611!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33840727!total
	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33840808!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 33841340!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 33841633!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 33842040!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 33842195!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 33842457!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 33842578!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 33842721!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 33842841!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 33843148!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 33843419!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 33843662!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 33843814!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 33843926!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 33844034!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 33844201!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 33844563!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 33844989!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 33845443!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 33845572!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 33845913!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 33846198!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 33846327!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 33846455!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 33846584!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 33846735!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 33847351!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 33847530!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 33848269!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 33849126!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 33849571!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 33849728!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 33850046!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 33850634!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 33850925!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 33851078!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 33851702!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 33852209!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 33852506!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 33852688!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 33852866!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 33853029!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 33853297!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 33853579!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 33853856!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 33854478!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 33854997!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 33855241!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 33855512!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 33855844!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 33857075!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 33857470!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 33858257!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 33858492!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 33858984!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 33859386!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 33859938!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 33860206!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33860375!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33860642!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33860799!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33860958!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 33861260!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 33861517!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33861732!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33862245!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33862570!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33862713!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 33862820!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 33862903!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 33863115!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 33863239!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33863389!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33863656!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33863776!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 33863956!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 33864190!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 33864373!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 33864604!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 33864759!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 33865182!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33865511!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 33865642!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 33865771!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 33866066!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33866206!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33866310!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33866434!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33866669!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 33867082!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 33867619!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 33868266!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 33869367!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33869640!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33869864!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 33870110!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 33870243!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 33870390!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33870813!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 33871062!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 33871423!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 33872031!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 33872196!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 33872352!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 33872491!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 33872629!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 33872981!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !SystemOrganization addCategory: #'Cross-Plattform-Benchmarks-Blowfish'!Object subclass: #CPBBlowfish	instanceVariableNames: 'rounds piArray s0 s1 s2 s3 xl xr current key data index'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!Object subclass: #CPBBlowfish
	instanceVariableNames: 'rounds piArray s0 s1 s2 s3 xl xr current key data index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Plattform-Benchmarks-Blowfish'!!CPBBlowfish commentStamp: '<historical>' prior: 0!This is just enough of the Blowfish algorithm from 
http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/lib/libc/crypt/blowfish.c

to be able to run BCrypt.  


Instance Variables:
	rounds	<AbstractSound | CalendarDuration | Collection | Color | DateAndTime | DhbDecimalFloatingNumber | DhbMatrix | DhbPolynomial | Duration | InfiniteDuration | Number | PassportNotAMetanumber | Point | ScientificDuration | TemporalInterval | Timespan | TraitComposition | TraitDescription | TraitTransformation>
	piArray	<Object>
	s0	<Matrix>
	s1	<Object>
	s2	<Object>
	s3	<Object>
	s4	<ProtoObject | PseudoContext>
	xl	<Integer>
	xr	<Integer>
	current	<Integer>
	key	<ProtoObject | PseudoContext>
	data	<Object>!!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:53'!blfDec: dataArray for: blocks
	| j newDataArray |
	newDataArray := Array new: dataArray size.
	j := 1.
	(1 to: blocks)
		do: [ :each | 
			xl := dataArray at: j.
			xr := dataArray at: j + 1.
			self decipher.
			newDataArray at: j put: xl.
			newDataArray at: j + 1 put: xr.
			j := j + 2 ].
	^ newDataArray! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 18:48'!blfEcbDecrypt: dataArray for: times

 |  newDataArray |
newDataArray:=dataArray copy.

	(1 to: times by: 8) do:[ :each | 
		
		xl:=((((newDataArray at: 1) bitShift: 24) bitOr: ((newDataArray at: 2) bitShift: 16) )bitOr: ((newDataArray at: 3) bitShift: 8)) bitOr: (newDataArray at: 4).  
		xr:=((((newDataArray at: 5) bitShift: 24) bitOr: ((newDataArray at: 6) bitShift: 16) )bitOr: ((newDataArray at: 7) bitShift: 8)) bitOr: (newDataArray at: 8).
		
		self decipher .
		
		newDataArray at: 1 put: ((xl  bitShift: -24) bitAnd: 16rFF).		
		newDataArray at: 2 put: ((xl  bitShift: -16) bitAnd: 16rFF).	
		newDataArray at: 3 put: ((xl  bitShift: -8) bitAnd: 16rFF).	
		newDataArray at: 4 put: (xl bitAnd: 16rFF).
		newDataArray at: 5 put: ((xr  bitShift: -24) bitAnd: 16rFF).	
		newDataArray at: 6 put: ((xr  bitShift: -16) bitAnd: 16rFF).
		newDataArray at: 7 put: ((xr  bitShift: -8) bitAnd: 16rFF).	
		newDataArray at: 8 put: (xr bitAnd: 16rFF).	
		]	.
		
	^newDataArray ! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 18:50'!blfEcbEncrypt: dataArray for: times

 |  newDataArray |
newDataArray:=dataArray copy.

	(1 to: times by: 8) do:[ :each | 
		
		xl:=((((newDataArray at: 1) bitShift: 24) bitOr: ((newDataArray at: 2) bitShift: 16) )bitOr: ((newDataArray at: 3) bitShift: 8)) bitOr: (newDataArray at: 4).  
		xr:=((((newDataArray at: 5) bitShift: 24) bitOr: ((newDataArray at: 6) bitShift: 16) )bitOr: ((newDataArray at: 7) bitShift: 8)) bitOr: (newDataArray at: 8).
		
		self encipher .
		
		newDataArray at: 1 put: ((xl  bitShift: -24) bitAnd: 16rFF).		
		newDataArray at: 2 put: ((xl  bitShift: -16) bitAnd: 16rFF).	
		newDataArray at: 3 put: ((xl  bitShift: -8) bitAnd: 16rFF).	
		newDataArray at: 4 put: (xl bitAnd: 16rFF).
		newDataArray at: 5 put: ((xr  bitShift: -24) bitAnd: 16rFF).	
		newDataArray at: 6 put: ((xr  bitShift: -16) bitAnd: 16rFF).
		newDataArray at: 7 put: ((xr  bitShift: -8) bitAnd: 16rFF).	
		newDataArray at: 8 put: (xr bitAnd: 16rFF).	
		]	.
		
	^newDataArray ! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:53'!blfEnc: dataArray for: blocks
	| j newDataArray |
	newDataArray := dataArray copy.
	j := 1.
	(1 to: blocks)
		do: [ :each | 
			xl := newDataArray at: j.
			xr := newDataArray at: j + 1.
			self encipher.
			newDataArray at: j put: xl.
			newDataArray at: j + 1 put: xr.
			j := j + 2 ].
	^ newDataArray! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:53'!blfKey: aKey
	index:=0.
	key:= aKey.
	"self initializeLittleEndianBoxes."
	self initializeBoxes.
	self expandZeroState.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!calculateBlfRndFor:oneHalf with: otherHalf andPiAt: n
"#define BLFRND(s,p,i,j,n) (i ^= F(s,j) ^ (p)[n])"

	
^ oneHalf bitXor: ((self feistelWith: otherHalf  ) bitXor: (piArray at: n)) .
! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!decipher
	| xL xR temp |
	xL := xl copy.
	xR := xr copy.
	xL := xL bitXor: (piArray at: 18).
	(17 to: 2 by: -2)
		do: [ :each | 
			xR := self calculateBlfRndFor: xR with: xL andPiAt: each.
			xL := self calculateBlfRndFor: xL with: xR andPiAt: each - 1 ].
	xl := xR bitXor: (piArray at: 1).
	xr := xL! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!decrypt: someData with:   aKeyString

	
	self setRounds: self class defaultRounds .

	self blfKey: aKeyString.
	^self blfDec: someData for: someData size // 2.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!ecbDecrypt: someData with:   aKeyString


	self setRounds: self class defaultRounds .

	self blfKey: aKeyString.
	^self blfEcbDecrypt: someData for: someData size // 2.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!ecbEncrypt: someData with:   aKeyString


	self setRounds: self class defaultRounds .

	self blfKey: aKeyString.
	^self blfEcbEncrypt: someData for: someData size // 2.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:55'!encipher
	| xL xR temp |
	xL := xl copy.
	xR := xr copy.
	xL := xL bitXor: (piArray at: 1).
"	index <= 2
		ifTrue: [ 
			Transcript
				cr;
				show: 'New encipher';
				cr;
				show: 'Left: ';
				show: xL hex greaseString ]."
	(2 to: 17 by: 2)
		do: [ :each | 
			xR := self calculateBlfRndFor: xR with: xL andPiAt: each.
			xL := self calculateBlfRndFor: xL with: xR andPiAt: each + 1.
"			index = 2
				ifTrue: [ 
					Transcript
						cr;
						show: 'Right: ';
						show: xR hex greaseString;
						cr;
						show: 'Left: ';
						show: xL hex greaseString.
					index = 0 ] ]."].
	xR := xR bitXor: (piArray at: 18).
	xl := xR.
	xr := xL! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:55'!encrypt: someData with:   aKeyString


	self setRounds: self class defaultRounds .

	self blfKey: aKeyString.
	
	^self blfEnc: someData  for: someData size // 2.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:55'!expandZeroState
	| dataL dataR s0Test s1Test s2Test s3Test  pTest|
	current := 1.
pTest:=piArray copy.
	(1 to: rounds + 2)
		do: [ :each | piArray at: each put: ((piArray at: each) bitXor: (self stream2word: key)) ].

"xl := 16r0.
xr := 16r0."
xl:=#[0 0 0 0] unsignedLongAt: 1 bigEndian:   true.
xr:=#[0 0 0 0] unsignedLongAt: 1 bigEndian:   true.
pTest:=piArray copy.
		(1 to: rounds + 2 by: 2)
		do: [ :each | 		
			self encipher.
					piArray at: each put: xl copy.
					piArray at: each+1 put: xr copy.].

s0Test :=s0 copy.
s1Test :=s1 copy.
s2Test :=s2 copy.
s3Test :=s3 copy.



		(1 to:256 by:2)
		do: [ :each | self encipher.
					s0 at: each put: xl copy.
					s0 at: each+1 put: xr copy.
					].

		(1 to:256 by:2)
		do: [ :each | self encipher.
					s1 at: each put: xl copy.
					s1 at: each+1 put: xr copy.].

		(1 to:256 by:2)
		do: [ :each | self encipher.
					s2 at: each put: xl copy.
					s2 at: each+1 put: xr copy.].

		(1 to:256 by:2)
		do: [ :each | self encipher.
					s3 at: each put: xl copy.
					s3 at: each+1 put: xr copy.].
			
"	s0Test:= s0 select:[:each | each asByteArray size >4].
	s1Test:= s1 select:[:each | each asByteArray size >4].
	s2Test:= s2 select:[:each | each asByteArray size >4].
	s3Test:= s3 select:[:each | each asByteArray size >4].
	(s0Test size + s1Test size + s2Test size + s3Test size) >0 ifTrue:[self halt]."! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 18:47'!feistelWith: otherHalf
	| a b c d y byteArray |
	a := ((otherHalf bitShift: -24) bitAnd: 16rFF) + 1.
	b := ((otherHalf bitShift: -16) bitAnd: 16rFF) + 1.
	c := ((otherHalf bitShift: -8) bitAnd: 16rFF) + 1.
	d := (otherHalf bitAnd: 16rFF) + 1.
	y := ((s0 at: a) + (s1 at: b)) \\ 4294967296.	" (2 raisedTo: 32)"
	y := y bitXor: (s2 at: c).
	y := (y + (s3 at: d)) \\ 4294967296.	"(2 raisedTo: 32)"
	^ y! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:56'!initializeBoxes
	piArray :=self class pBox copy.
	s0:=self class s0Box copy.
	s1:=self class s1Box copy.
	s2:=self class s2Box copy.
	s3:=self class s3Box copy.

	
	! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:56'!setRounds: anInteger

	rounds:=(anInteger >= self class minRounds and:[anInteger <= self class maxRounds]) ifTrue: [anInteger] ifFalse:[self class defaultRounds ]   ! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:56'!stream2word: someData 


|temp j dataBytes |
temp:=0.

dataBytes := someData size.

1 to: 4 do:  [ :each | 
		temp:=(temp bitShift: 8 ) bitOr: ((someData at: current) bitAnd: 16rFF).

	current := (current \\ dataBytes) +1.

	   ].


^temp.
! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:56'!stream2word: someData length: someBytes


|temp j  |
temp:=0.



1 to: 4 do:  [ :each | 
		temp:=(temp bitShift: 8 ) bitOr: ((someData atWrap: current) bitAnd: 16rFF).

	current := (current \\ someBytes) +1.

	   ].


^temp.
! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBBlowfish class
	instanceVariableNames: ''!!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!blockSize
	^8! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!defaultRounds
^self minRounds! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!maxRounds
^20
! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!maxUserKeyLength
	^448/8! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!minRounds
^16! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!pBox
	^#(		16r243F6A88 16r85A308D3 16r13198A2E 16r03707344 16rA4093822 16r299F31D0
			16r082EFA98 16rEC4E6C89 16r452821E6 16r38D01377 16rBE5466CF 16r34E90C6C
			16rC0AC29B7 16rC97C50DD 16r3F84D5B5 16rB5470917 16r9216D5D9 16r8979FB1B)! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:52'!s0Box
	^#(16rD1310BA6 16r98DFB5AC 16r2FFD72DB 16rD01ADFB7
			16rB8E1AFED 16r6A267E96 16rBA7C9045 16rF12C7F99
			16r24A19947 16rB3916CF7 16r0801F2E2 16r858EFC16
			16r636920D8 16r71574E69 16rA458FEA3 16rF4933D7E
			16r0D95748F 16r728EB658 16r718BCD58 16r82154AEE
			16r7B54A41D 16rC25A59B5 16r9C30D539 16r2AF26013
			16rC5D1B023 16r286085F0 16rCA417918 16rB8DB38EF
			16r8E79DCB0 16r603A180E 16r6C9E0E8B 16rB01E8A3E
			16rD71577C1 16rBD314B27 16r78AF2FDA 16r55605C60
			16rE65525F3 16rAA55AB94 16r57489862 16r63E81440
			16r55CA396A 16r2AAB10B6 16rB4CC5C34 16r1141E8CE
			16rA15486AF 16r7C72E993 16rB3EE1411 16r636FBC2A
			16r2BA9C55D 16r741831F6 16rCE5C3E16 16r9B87931E
			16rAFD6BA33 16r6C24CF5C 16r7A325381 16r28958677
			16r3B8F4898 16r6B4BB9AF 16rC4BFE81B 16r66282193
			16r61D809CC 16rFB21A991 16r487CAC60 16r5DEC8032
			16rEF845D5D 16rE98575B1 16rDC262302 16rEB651B88
			16r23893E81 16rD396ACC5 16r0F6D6FF3 16r83F44239
			16r2E0B4482 16rA4842004 16r69C8F04A 16r9E1F9B5E
			16r21C66842 16rF6E96C9A 16r670C9C61 16rABD388F0
			16r6A51A0D2 16rD8542F68 16r960FA728 16rAB5133A3
			16r6EEF0B6C 16r137A3BE4 16rBA3BF050 16r7EFB2A98
			16rA1F1651D 16r39AF0176 16r66CA593E 16r82430E88
			16r8CEE8619 16r456F9FB4 16r7D84A5C3 16r3B8B5EBE
			16rE06F75D8 16r85C12073 16r401A449F 16r56C16AA6
			16r4ED3AA62 16r363F7706 16r1BFEDF72 16r429B023D
			16r37D0D724 16rD00A1248 16rDB0FEAD3 16r49F1C09B
			16r075372C9 16r80991B7B 16r25D479D8 16rF6E8DEF7
			16rE3FE501A 16rB6794C3B 16r976CE0BD 16r04C006BA
			16rC1A94FB6 16r409F60C4 16r5E5C9EC2 16r196A2463
			16r68FB6FAF 16r3E6C53B5 16r1339B2EB 16r3B52EC6F
			16r6DFC511F 16r9B30952C 16rCC814544 16rAF5EBD09
			16rBEE3D004 16rDE334AFD 16r660F2807 16r192E4BB3
			16rC0CBA857 16r45C8740F 16rD20B5F39 16rB9D3FBDB
			16r5579C0BD 16r1A60320A 16rD6A100C6 16r402C7279
			16r679F25FE 16rFB1FA3CC 16r8EA5E9F8 16rDB3222F8
			16r3C7516DF 16rFD616B15 16r2F501EC8 16rAD0552AB
			16r323DB5FA 16rFD238760 16r53317B48 16r3E00DF82
			16r9E5C57BB 16rCA6F8CA0 16r1A87562E 16rDF1769DB
			16rD542A8F6 16r287EFFC3 16rAC6732C6 16r8C4F5573
			16r695B27B0 16rBBCA58C8 16rE1FFA35D 16rB8F011A0
			16r10FA3D98 16rFD2183B8 16r4AFCB56C 16r2DD1D35B
			16r9A53E479 16rB6F84565 16rD28E49BC 16r4BFB9790
			16rE1DDF2DA 16rA4CB7E33 16r62FB1341 16rCEE4C6E8
			16rEF20CADA 16r36774C01 16rD07E9EFE 16r2BF11FB4
			16r95DBDA4D 16rAE909198 16rEAAD8E71 16r6B93D5A0
			16rD08ED1D0 16rAFC725E0 16r8E3C5B2F 16r8E7594B7
			16r8FF6E2FB 16rF2122B64 16r8888B812 16r900DF01C
			16r4FAD5EA0 16r688FC31C 16rD1CFF191 16rB3A8C1AD
			16r2F2F2218 16rBE0E1777 16rEA752DFE 16r8B021FA1
			16rE5A0CC0F 16rB56F74E8 16r18ACF3D6 16rCE89E299
			16rB4A84FE0 16rFD13E0B7 16r7CC43B81 16rD2ADA8D9
			16r165FA266 16r80957705 16r93CC7314 16r211A1477
			16rE6AD2065 16r77B5FA86 16rC75442F5 16rFB9D35CF
			16rEBCDAF0C 16r7B3E89A0 16rD6411BD3 16rAE1E7E49
			16r00250E2D 16r2071B35E 16r226800BB 16r57B8E0AF
			16r2464369B 16rF009B91E 16r5563911D 16r59DFA6AA
			16r78C14389 16rD95A537F 16r207D5BA2 16r02E5B9C5
			16r83260376 16r6295CFA9 16r11C81968 16r4E734A41
			16rB3472DCA 16r7B14A94A 16r1B510052 16r9A532915
			16rD60F573F 16rBC9BC6E4 16r2B60A476 16r81E67400
			16r08BA6FB5 16r571BE91F 16rF296EC6B 16r2A0DD915
			16rB6636521 16rE7B9F9B6 16rFF34052E 16rC5855664
			16r53B02D5D 16rA99F8FA1 16r08BA4799 16r6E85076A	)! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:52'!s1Box
	^#(16r4B7A70E9 16rB5B32944 16rDB75092E 16rC4192623
			16rAD6EA6B0 16r49A7DF7D 16r9CEE60B8 16r8FEDB266
			16rECAA8C71 16r699A17FF 16r5664526C 16rC2B19EE1
			16r193602A5 16r75094C29 16rA0591340 16rE4183A3E
			16r3F54989A 16r5B429D65 16r6B8FE4D6 16r99F73FD6
			16rA1D29C07 16rEFE830F5 16r4D2D38E6 16rF0255DC1
			16r4CDD2086 16r8470EB26 16r6382E9C6 16r021ECC5E
			16r09686B3F 16r3EBAEFC9 16r3C971814 16r6B6A70A1
			16r687F3584 16r52A0E286 16rB79C5305 16rAA500737
			16r3E07841C 16r7FDEAE5C 16r8E7D44EC 16r5716F2B8
			16rB03ADA37 16rF0500C0D 16rF01C1F04 16r0200B3FF
			16rAE0CF51A 16r3CB574B2 16r25837A58 16rDC0921BD
			16rD19113F9 16r7CA92FF6 16r94324773 16r22F54701
			16r3AE5E581 16r37C2DADC 16rC8B57634 16r9AF3DDA7
			16rA9446146 16r0FD0030E 16rECC8C73E 16rA4751E41
			16rE238CD99 16r3BEA0E2F 16r3280BBA1 16r183EB331
			16r4E548B38 16r4F6DB908 16r6F420D03 16rF60A04BF
			16r2CB81290 16r24977C79 16r5679B072 16rBCAF89AF
			16rDE9A771F 16rD9930810 16rB38BAE12 16rDCCF3F2E
			16r5512721F 16r2E6B7124 16r501ADDE6 16r9F84CD87
			16r7A584718 16r7408DA17 16rBC9F9ABC 16rE94B7D8C
			16rEC7AEC3A 16rDB851DFA 16r63094366 16rC464C3D2
			16rEF1C1847 16r3215D908 16rDD433B37 16r24C2BA16
			16r12A14D43 16r2A65C451 16r50940002 16r133AE4DD
			16r71DFF89E 16r10314E55 16r81AC77D6 16r5F11199B
			16r043556F1 16rD7A3C76B 16r3C11183B 16r5924A509
			16rF28FE6ED 16r97F1FBFA 16r9EBABF2C 16r1E153C6E
			16r86E34570 16rEAE96FB1 16r860E5E0A 16r5A3E2AB3
			16r771FE71C 16r4E3D06FA 16r2965DCB9 16r99E71D0F
			16r803E89D6 16r5266C825 16r2E4CC978 16r9C10B36A
			16rC6150EBA 16r94E2EA78 16rA5FC3C53 16r1E0A2DF4
			16rF2F74EA7 16r361D2B3D 16r1939260F 16r19C27960
			16r5223A708 16rF71312B6 16rEBADFE6E 16rEAC31F66
			16rE3BC4595 16rA67BC883 16rB17F37D1 16r018CFF28
			16rC332DDEF 16rBE6C5AA5 16r65582185 16r68AB9802
			16rEECEA50F 16rDB2F953B 16r2AEF7DAD 16r5B6E2F84
			16r1521B628 16r29076170 16rECDD4775 16r619F1510
			16r13CCA830 16rEB61BD96 16r0334FE1E 16rAA0363CF
			16rB5735C90 16r4C70A239 16rD59E9E0B 16rCBAADE14
			16rEECC86BC 16r60622CA7 16r9CAB5CAB 16rB2F3846E
			16r648B1EAF 16r19BDF0CA 16rA02369B9 16r655ABB50
			16r40685A32 16r3C2AB4B3 16r319EE9D5 16rC021B8F7
			16r9B540B19 16r875FA099 16r95F7997E 16r623D7DA8
			16rF837889A 16r97E32D77 16r11ED935F 16r16681281
			16r0E358829 16rC7E61FD6 16r96DEDFA1 16r7858BA99
			16r57F584A5 16r1B227263 16r9B83C3FF 16r1AC24696
			16rCDB30AEB 16r532E3054 16r8FD948E4 16r6DBC3128
			16r58EBF2EF 16r34C6FFEA 16rFE28ED61 16rEE7C3C73
			16r5D4A14D9 16rE864B7E3 16r42105D14 16r203E13E0
			16r45EEE2B6 16rA3AAABEA 16rDB6C4F15 16rFACB4FD0
			16rC742F442 16rEF6ABBB5 16r654F3B1D 16r41CD2105
			16rD81E799E 16r86854DC7 16rE44B476A 16r3D816250
			16rCF62A1F2 16r5B8D2646 16rFC8883A0 16rC1C7B6A3
			16r7F1524C3 16r69CB7492 16r47848A0B 16r5692B285
			16r095BBF00 16rAD19489D 16r1462B174 16r23820E00
			16r58428D2A 16r0C55F5EA 16r1DADF43E 16r233F7061
			16r3372F092 16r8D937E41 16rD65FECF1 16r6C223BDB
			16r7CDE3759 16rCBEE7460 16r4085F2A7 16rCE77326E
			16rA6078084 16r19F8509E 16rE8EFD855 16r61D99735
			16rA969A7AA 16rC50C06C2 16r5A04ABFC 16r800BCADC
			16r9E447A2E 16rC3453484 16rFDD56705 16r0E1E9EC9
			16rDB73DBD3 16r105588CD 16r675FDA79 16rE3674340
			16rC5C43465 16r713E38D8 16r3D28F89E 16rF16DFF20
			16r153E21E7 16r8FB03D4A 16rE6E39F2B 16rDB83ADF7)! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:52'!s2Box
	^#(16rE93D5A68 16r948140F7 16rF64C261C 16r94692934
			16r411520F7 16r7602D4F7 16rBCF46B2E 16rD4A20068
			16rD4082471 16r3320F46A 16r43B7D4B7 16r500061AF
			16r1E39F62E 16r97244546 16r14214F74 16rBF8B8840
			16r4D95FC1D 16r96B591AF 16r70F4DDD3 16r66A02F45
			16rBFBC09EC 16r03BD9785 16r7FAC6DD0 16r31CB8504
			16r96EB27B3 16r55FD3941 16rDA2547E6 16rABCA0A9A
			16r28507825 16r530429F4 16r0A2C86DA 16rE9B66DFB
			16r68DC1462 16rD7486900 16r680EC0A4 16r27A18DEE
			16r4F3FFEA2 16rE887AD8C 16rB58CE006 16r7AF4D6B6
			16rAACE1E7C 16rD3375FEC 16rCE78A399 16r406B2A42
			16r20FE9E35 16rD9F385B9 16rEE39D7AB 16r3B124E8B
			16r1DC9FAF7 16r4B6D1856 16r26A36631 16rEAE397B2
			16r3A6EFA74 16rDD5B4332 16r6841E7F7 16rCA7820FB
			16rFB0AF54E 16rD8FEB397 16r454056AC 16rBA489527
			16r55533A3A 16r20838D87 16rFE6BA9B7 16rD096954B
			16r55A867BC 16rA1159A58 16rCCA92963 16r99E1DB33
			16rA62A4A56 16r3F3125F9 16r5EF47E1C 16r9029317C
			16rFDF8E802 16r04272F70 16r80BB155C 16r05282CE3
			16r95C11548 16rE4C66D22 16r48C1133F 16rC70F86DC
			16r07F9C9EE 16r41041F0F 16r404779A4 16r5D886E17
			16r325F51EB 16rD59BC0D1 16rF2BCC18F 16r41113564
			16r257B7834 16r602A9C60 16rDFF8E8A3 16r1F636C1B
			16r0E12B4C2 16r02E1329E 16rAF664FD1 16rCAD18115
			16r6B2395E0 16r333E92E1 16r3B240B62 16rEEBEB922
			16r85B2A20E 16rE6BA0D99 16rDE720C8C 16r2DA2F728
			16rD0127845 16r95B794FD 16r647D0862 16rE7CCF5F0
			16r5449A36F 16r877D48FA 16rC39DFD27 16rF33E8D1E
			16r0A476341 16r992EFF74 16r3A6F6EAB 16rF4F8FD37
			16rA812DC60 16rA1EBDDF8 16r991BE14C 16rDB6E6B0D
			16rC67B5510 16r6D672C37 16r2765D43B 16rDCD0E804
			16rF1290DC7 16rCC00FFA3 16rB5390F92 16r690FED0B
			16r667B9FFB 16rCEDB7D9C 16rA091CF0B 16rD9155EA3
			16rBB132F88 16r515BAD24 16r7B9479BF 16r763BD6EB
			16r37392EB3 16rCC115979 16r8026E297 16rF42E312D
			16r6842ADA7 16rC66A2B3B 16r12754CCC 16r782EF11C
			16r6A124237 16rB79251E7 16r06A1BBE6 16r4BFB6350
			16r1A6B1018 16r11CAEDFA 16r3D25BDD8 16rE2E1C3C9
			16r44421659 16r0A121386 16rD90CEC6E 16rD5ABEA2A
			16r64AF674E 16rDA86A85F 16rBEBFE988 16r64E4C3FE
			16r9DBC8057 16rF0F7C086 16r60787BF8 16r6003604D
			16rD1FD8346 16rF6381FB0 16r7745AE04 16rD736FCCC
			16r83426B33 16rF01EAB71 16rB0804187 16r3C005E5F
			16r77A057BE 16rBDE8AE24 16r55464299 16rBF582E61
			16r4E58F48F 16rF2DDFDA2 16rF474EF38 16r8789BDC2
			16r5366F9C3 16rC8B38E74 16rB475F255 16r46FCD9B9
			16r7AEB2661 16r8B1DDF84 16r846A0E79 16r915F95E2
			16r466E598E 16r20B45770 16r8CD55591 16rC902DE4C
			16rB90BACE1 16rBB8205D0 16r11A86248 16r7574A99E
			16rB77F19B6 16rE0A9DC09 16r662D09A1 16rC4324633
			16rE85A1F02 16r09F0BE8C 16r4A99A025 16r1D6EFE10
			16r1AB93D1D 16r0BA5A4DF 16rA186F20F 16r2868F169
			16rDCB7DA83 16r573906FE 16rA1E2CE9B 16r4FCD7F52
			16r50115E01 16rA70683FA 16rA002B5C4 16r0DE6D027
			16r9AF88C27 16r773F8641 16rC3604C06 16r61A806B5
			16rF0177A28 16rC0F586E0 16r006058AA 16r30DC7D62
			16r11E69ED7 16r2338EA63 16r53C2DD94 16rC2C21634
			16rBBCBEE56 16r90BCB6DE 16rEBFC7DA1 16rCE591D76
			16r6F05E409 16r4B7C0188 16r39720A3D 16r7C927C24
			16r86E3725F 16r724D9DB9 16r1AC15BB4 16rD39EB8FC
			16rED545578 16r08FCA5B5 16rD83D7CD3 16r4DAD0FC4
			16r1E50EF5E 16rB161E6F8 16rA28514D9 16r6C51133C
			16r6FD5C7E7 16r56E14EC4 16r362ABFCE 16rDDC6C837
			16rD79A3234 16r92638212 16r670EFA8E 16r406000E0)! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:52'!s3Box
	^#(16r3A39CE37 16rD3FAF5CF 16rABC27737 16r5AC52D1B
			16r5CB0679E 16r4FA33742 16rD3822740 16r99BC9BBE
			16rD5118E9D 16rBF0F7315 16rD62D1C7E 16rC700C47B
			16rB78C1B6B 16r21A19045 16rB26EB1BE 16r6A366EB4
			16r5748AB2F 16rBC946E79 16rC6A376D2 16r6549C2C8
			16r530FF8EE 16r468DDE7D 16rD5730A1D 16r4CD04DC6
			16r2939BBDB 16rA9BA4650 16rAC9526E8 16rBE5EE304
			16rA1FAD5F0 16r6A2D519A 16r63EF8CE2 16r9A86EE22
			16rC089C2B8 16r43242EF6 16rA51E03AA 16r9CF2D0A4
			16r83C061BA 16r9BE96A4D 16r8FE51550 16rBA645BD6
			16r2826A2F9 16rA73A3AE1 16r4BA99586 16rEF5562E9
			16rC72FEFD3 16rF752F7DA 16r3F046F69 16r77FA0A59
			16r80E4A915 16r87B08601 16r9B09E6AD 16r3B3EE593
			16rE990FD5A 16r9E34D797 16r2CF0B7D9 16r022B8B51
			16r96D5AC3A 16r017DA67D 16rD1CF3ED6 16r7C7D2D28
			16r1F9F25CF 16rADF2B89B 16r5AD6B472 16r5A88F54C
			16rE029AC71 16rE019A5E6 16r47B0ACFD 16rED93FA9B
			16rE8D3C48D 16r283B57CC 16rF8D56629 16r79132E28
			16r785F0191 16rED756055 16rF7960E44 16rE3D35E8C
			16r15056DD4 16r88F46DBA 16r03A16125 16r0564F0BD
			16rC3EB9E15 16r3C9057A2 16r97271AEC 16rA93A072A
			16r1B3F6D9B 16r1E6321F5 16rF59C66FB 16r26DCF319
			16r7533D928 16rB155FDF5 16r03563482 16r8ABA3CBB
			16r28517711 16rC20AD9F8 16rABCC5167 16rCCAD925F
			16r4DE81751 16r3830DC8E 16r379D5862 16r9320F991
			16rEA7A90C2 16rFB3E7BCE 16r5121CE64 16r774FBE32
			16rA8B6E37E 16rC3293D46 16r48DE5369 16r6413E680
			16rA2AE0810 16rDD6DB224 16r69852DFD 16r09072166
			16rB39A460A 16r6445C0DD 16r586CDECF 16r1C20C8AE
			16r5BBEF7DD 16r1B588D40 16rCCD2017F 16r6BB4E3BB
			16rDDA26A7E 16r3A59FF45 16r3E350A44 16rBCB4CDD5
			16r72EACEA8 16rFA6484BB 16r8D6612AE 16rBF3C6F47
			16rD29BE463 16r542F5D9E 16rAEC2771B 16rF64E6370
			16r740E0D8D 16rE75B1357 16rF8721671 16rAF537D5D
			16r4040CB08 16r4EB4E2CC 16r34D2466A 16r0115AF84
			16rE1B00428 16r95983A1D 16r06B89FB4 16rCE6EA048
			16r6F3F3B82 16r3520AB82 16r011A1D4B 16r277227F8
			16r611560B1 16rE7933FDC 16rBB3A792B 16r344525BD
			16rA08839E1 16r51CE794B 16r2F32C9B7 16rA01FBAC9
			16rE01CC87E 16rBCC7D1F6 16rCF0111C3 16rA1E8AAC7
			16r1A908749 16rD44FBD9A 16rD0DADECB 16rD50ADA38
			16r0339C32A 16rC6913667 16r8DF9317C 16rE0B12B4F
			16rF79E59B7 16r43F5BB3A 16rF2D519FF 16r27D9459C
			16rBF97222C 16r15E6FC2A 16r0F91FC71 16r9B941525
			16rFAE59361 16rCEB69CEB 16rC2A86459 16r12BAA8D1
			16rB6C1075E 16rE3056A0C 16r10D25065 16rCB03A442
			16rE0EC6E0E 16r1698DB3B 16r4C98A0BE 16r3278E964
			16r9F1F9532 16rE0D392DF 16rD3A0342B 16r8971F21E
			16r1B0A7441 16r4BA3348C 16rC5BE7120 16rC37632D8
			16rDF359F8D 16r9B992F2E 16rE60B6F47 16r0FE3F11D
			16rE54CDA54 16r1EDAD891 16rCE6279CF 16rCD3E7E6F
			16r1618B166 16rFD2C1D05 16r848FD2C5 16rF6FB2299
			16rF523F357 16rA6327623 16r93A83531 16r56CCCD02
			16rACF08162 16r5A75EBB5 16r6E163697 16r88D273CC
			16rDE966292 16r81B949D0 16r4C50901B 16r71C65614
			16rE6C6C7BD 16r327A140A 16r45E1D006 16rC3F27B9A
			16rC9AA53FD 16r62A80F00 16rBB25BFE2 16r35BDD2F6
			16r71126905 16rB2040222 16rB6CBCF7C 16rCD769C2B
			16r53113EC0 16r1640E3D3 16r38ABBD60 16r2547ADF0
			16rBA38209C 16rF746CE76 16r77AFA1C5 16r20756060
			16r85CBFE4E 16r8AE88DD8 16r7AAAF9B0 16r4CF9AA7E
			16r1948C25C 16r02FB8A8C 16r01C36AE4 16rD6EBE1F9
			16r90D4F869 16rA65CDEA0 16r3F09252D 16rC208E69F
			16rB74E6132 16rCE77E25B 16r578FDFE3 16r3AC372E6)! !!CPBBlowfish class methodsFor: 'decrypt' stamp: 'gsa 4/30/2012 19:50'!decrypt: someData with: aKeyByteArray
"use this when you have a wordArray"
	^self new decrypt: someData with: aKeyByteArray.! !!CPBBlowfish class methodsFor: 'decrypt' stamp: 'gsa 4/30/2012 19:50'!decryptString: someData with: aKeyString
|dataToEncrypt |
dataToEncrypt :=OrderedCollection new.
someData do:[:each | dataToEncrypt add: each asciiValue ].
	^self new decrypt: dataToEncrypt asArray with: aKeyString asByteArray .! !!CPBBlowfish class methodsFor: 'decrypt' stamp: 'gsa 4/30/2012 19:45'!decryptToString: someData with: aKey
|decryptedData | 
decryptedData := (self new ecbDecrypt: someData with: aKey asByteArray  ).
	^String fromByteArray:  decryptedData asByteArray .! !!CPBBlowfish class methodsFor: 'encrypt' stamp: 'gsa 4/30/2012 19:50'!ecbDecrypt: someData with: aKey
"use this when you have a byteArray"
	^self new ecbDecrypt: someData with: aKey.! !!CPBBlowfish class methodsFor: 'encrypt' stamp: 'gsa 4/30/2012 19:50'!ecbEncrypt: someData with: aKey
"use this when you have a byteArray"
	^self new ecbEncrypt: someData with: aKey.! !!CPBBlowfish class methodsFor: 'encrypt' stamp: 'gsa 4/30/2012 19:50'!encrypt: someData with: aKey
"use this when you have a wordArray"
	^self new encrypt: someData  with: aKey.! !!CPBBlowfish class methodsFor: 'encrypt' stamp: 'gsa 4/30/2012 19:50'!encryptString: someData with: aKeyString
"use this with a string"
|dataToEncrypt |
dataToEncrypt :=OrderedCollection new.
someData do:[:each | dataToEncrypt add: each asciiValue ].
	^self new ecbEncrypt: dataToEncrypt asArray with: aKeyString asByteArray .! !Object subclass: #CPBBlowfishProfiling	instanceVariableNames: 'keys clear encrypted'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!Object subclass: #CPBBlowfishProfiling
	instanceVariableNames: 'keys clear encrypted'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Plattform-Benchmarks-Blowfish'!!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:49'!initialize
	super initialize.
	self
		initializeClear;
		initializeEncrypted;
		initializeKeys! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:49'!initializeClear
	| tmpClear |
	clear := OrderedCollection new.
	tmpClear := #('0000000000000000' 'FFFFFFFFFFFFFFFF' '1000000000000001' '1111111111111111' '1111111111111111' '0123456789ABCDEF' '0000000000000000' '0123456789ABCDEF' '01A1D6D039776742' '5CD54CA83DEF57DA' '0248D43806F67172' '51454B582DDF440A' '42FD443059577FA2' '059B5E0851CF143A' '0756D8E0774761D2' '762514B829BF486A' '3BDD119049372802' '26955F6835AF609A' '164D5E404F275232' '6B056E18759F5CCA' '004BD6EF09176062' '480D39006EE762F2' '437540C8698F3CFA' '072D43A077075292' '02FE55778117F12A' '1D9D5C5018F728C2' '305532286D6F295A' '0123456789ABCDEF' '0123456789ABCDEF' '0123456789ABCDEF' 'FFFFFFFFFFFFFFFF' '0000000000000000' '0000000000000000' 'FFFFFFFFFFFFFFFF').
	tmpClear
		do: [ :each | 
			| array tmpByteArray |
			array := WordArray new: 2.
			array at: 1 put: ((ByteArray fromHexString: (each copyFrom: 1 to: 8)) unsignedLongAt: 1 bigEndian: true).
			array at: 2 put: ((ByteArray fromHexString: (each copyFrom: 9 to: 16)) unsignedLongAt: 1 bigEndian: true).
			clear add: array ]! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:49'!initializeEncrypted
	| tmpEncrypted |
	encrypted := OrderedCollection new.
	tmpEncrypted := #('4EF997456198DD78' '51866FD5B85ECB8A' '7D856F9A613063F2' '2466DD878B963C9D' '61F9C3802281B096' '7D0CC630AFDA1EC7' '4EF997456198DD78' '0ACEAB0FC6A0A28D' '59C68245EB05282B' 'B1B8CC0B250F09A0' '1730E5778BEA1DA4' 'A25E7856CF2651EB' '353882B109CE8F1A' '48F4D0884C379918' '432193B78951FC98' '13F04154D69D1AE5' '2EEDDA93FFD39C79' 'D887E0393C2DA6E3' '5F99D04F5B163969' '4A057A3B24D3977B' '452031C1E4FADA8E' '7555AE39F59B87BD' '53C55F9CB49FC019' '7A8E7BFA937E89A3' 'CF9C5D7A4986ADB5' 'D1ABB290658BC778' '55CB3774D13EF201' 'FA34EC4847B268B2' 'A790795108EA3CAE' 'C39E072D9FAC631D' '014933E0CDAFF6E4' 'F21E9A77B71C49BC' '245946885754369A' '6B5C5A9C5D9E0A5A').
	tmpEncrypted
		do: [ :each | 
			| array tmpByteArray |
			array := WordArray new: 2.
			array at: 1 put: ((ByteArray fromHexString: (each copyFrom: 1 to: 8)) unsignedLongAt: 1 bigEndian: true).
			array at: 2 put: ((ByteArray fromHexString: (each copyFrom: 9 to: 16)) unsignedLongAt: 1 bigEndian: true).
			encrypted add: array ]! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:49'!initializeKeys
	| tempKeys |
	keys := OrderedCollection new.
	tempKeys := #('0000000000000000' 'FFFFFFFFFFFFFFFF' '3000000000000000' '1111111111111111' '0123456789ABCDEF' '1111111111111111' '0000000000000000' 'FEDCBA9876543210' '7CA110454A1A6E57' '0131D9619DC1376E' '07A1133E4A0B2686' '3849674C2602319E' '04B915BA43FEB5B6' '0113B970FD34F2CE' '0170F175468FB5E6' '43297FAD38E373FE' '07A7137045DA2A16' '04689104C2FD3B2F' '37D06BB516CB7546' '1F08260D1AC2465E' '584023641ABA6176' '025816164629B007' '49793EBC79B3258F' '4FB05E1515AB73A7' '49E95D6D4CA229BF' '018310DC409B26D6' '1C587F1C13924FEF' '0101010101010101' '1F1F1F1F0E0E0E0E' 'E0FEE0FEF1FEF1FE' '0000000000000000' 'FFFFFFFFFFFFFFFF' '0123456789ABCDEF' 'FEDCBA9876543210').
	tempKeys do: [ :each | keys add: (ByteArray fromHexString: each) ]! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:27'!longDecryptionTest
	"(1 to: keys size)"
	(20 to: keys size)
		do: [ :each | 
			| key clearText cipherText enc |
			key := keys at: each.
			clearText := clear at: each.
			cipherText := encrypted at: each.
			enc := CPBBlowfish decrypt: cipherText with: key ]! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:27'!longEncryptionTest
	"(1 to: keys size)"
	(20 to: keys size)
		do: [ :each | 
			| key clearText cipherText enc |
			key := keys at: each.
			clearText := clear at: each.
			cipherText := encrypted at: each.
			enc := CPBBlowfish encrypt: clearText with: key ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBBlowfishProfiling class
	instanceVariableNames: ''!!CPBBlowfishProfiling class methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:43'!longTest
	! !SMarkSuite subclass: #CPBBlowfishSuite	instanceVariableNames: 'blowfish'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!SMarkSuite subclass: #CPBBlowfishSuite
	instanceVariableNames: 'blowfish'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Plattform-Benchmarks-Blowfish'!!CPBBlowfishSuite methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:31'!benchBlowfish
	blowfish longEncryptionTest.
	blowfish longDecryptionTest.! !!CPBBlowfishSuite methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:31'!setUp
	blowfish := CPBBlowfishProfiling new.! !TestCase subclass: #CPBBlowfishTests	instanceVariableNames: 'keys clear encrypted'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!TestCase subclass: #CPBBlowfishTests
	instanceVariableNames: 'keys clear encrypted'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Plattform-Benchmarks-Blowfish'!!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/25/2011 13:39'!setUp
	"this data is from here: http://www.schneier.com/code/vectors.txt"

	| tmpKeys tmpClear tmpEncrypted |
	keys := OrderedCollection new.
	clear := OrderedCollection new.
	encrypted := OrderedCollection new.
	tmpKeys := #('0000000000000000' 'FFFFFFFFFFFFFFFF' '3000000000000000' '1111111111111111' '0123456789ABCDEF' '1111111111111111' '0000000000000000' 'FEDCBA9876543210' '7CA110454A1A6E57' '0131D9619DC1376E' '07A1133E4A0B2686' '3849674C2602319E' '04B915BA43FEB5B6' '0113B970FD34F2CE' '0170F175468FB5E6' '43297FAD38E373FE' '07A7137045DA2A16' '04689104C2FD3B2F' '37D06BB516CB7546' '1F08260D1AC2465E' '584023641ABA6176' '025816164629B007' '49793EBC79B3258F' '4FB05E1515AB73A7' '49E95D6D4CA229BF' '018310DC409B26D6' '1C587F1C13924FEF' '0101010101010101' '1F1F1F1F0E0E0E0E' 'E0FEE0FEF1FEF1FE' '0000000000000000' 'FFFFFFFFFFFFFFFF' '0123456789ABCDEF' 'FEDCBA9876543210').
	tmpClear := #('0000000000000000' 'FFFFFFFFFFFFFFFF' '1000000000000001' '1111111111111111' '1111111111111111' '0123456789ABCDEF' '0000000000000000' '0123456789ABCDEF' '01A1D6D039776742' '5CD54CA83DEF57DA' '0248D43806F67172' '51454B582DDF440A' '42FD443059577FA2' '059B5E0851CF143A' '0756D8E0774761D2' '762514B829BF486A' '3BDD119049372802' '26955F6835AF609A' '164D5E404F275232' '6B056E18759F5CCA' '004BD6EF09176062' '480D39006EE762F2' '437540C8698F3CFA' '072D43A077075292' '02FE55778117F12A' '1D9D5C5018F728C2' '305532286D6F295A' '0123456789ABCDEF' '0123456789ABCDEF' '0123456789ABCDEF' 'FFFFFFFFFFFFFFFF' '0000000000000000' '0000000000000000' 'FFFFFFFFFFFFFFFF').
	tmpEncrypted := #('4EF997456198DD78' '51866FD5B85ECB8A' '7D856F9A613063F2' '2466DD878B963C9D' '61F9C3802281B096' '7D0CC630AFDA1EC7' '4EF997456198DD78' '0ACEAB0FC6A0A28D' '59C68245EB05282B' 'B1B8CC0B250F09A0' '1730E5778BEA1DA4' 'A25E7856CF2651EB' '353882B109CE8F1A' '48F4D0884C379918' '432193B78951FC98' '13F04154D69D1AE5' '2EEDDA93FFD39C79' 'D887E0393C2DA6E3' '5F99D04F5B163969' '4A057A3B24D3977B' '452031C1E4FADA8E' '7555AE39F59B87BD' '53C55F9CB49FC019' '7A8E7BFA937E89A3' 'CF9C5D7A4986ADB5' 'D1ABB290658BC778' '55CB3774D13EF201' 'FA34EC4847B268B2' 'A790795108EA3CAE' 'C39E072D9FAC631D' '014933E0CDAFF6E4' 'F21E9A77B71C49BC' '245946885754369A' '6B5C5A9C5D9E0A5A').	
		
 "keys:=tmpKeys.	"
	tmpKeys do: [ :each | keys add: (ByteArray fromHexString: each)  ].
	tmpClear
		do: [ :each | 
			| array tmpByteArray |
			array := WordArray new: 2.
			array at: 1 put: ((ByteArray fromHexString: (each copyFrom: 1 to: 8)) unsignedLongAt: 1 bigEndian: true).
			array at: 2 put: ((ByteArray fromHexString: (each copyFrom: 9 to: 16)) unsignedLongAt: 1 bigEndian: true).
			clear add: array ].
	tmpEncrypted
		do: [ :each | 
			| array tmpByteArray |
			array := WordArray new: 2.
			array at: 1 put: ((ByteArray fromHexString: (each copyFrom: 1 to: 8)) unsignedLongAt: 1 bigEndian: true).
			array at: 2 put: ((ByteArray fromHexString: (each copyFrom: 9 to: 16)) unsignedLongAt: 1 bigEndian: true).
			encrypted add: array ]! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testDecryption
|key data res|
key:='abcdefghijklmnopqrstuvwxyz'.
data:=WordArray  new: 2.
#(16r324ED0FE  16rF413A203) doWithIndex: [:each :i | data at: i put: ((each asByteArray) unsignedLongAt: 1 bigEndian:true)    ].

res:=(CPBBlowfish decrypt: data with:  key asByteArray ).


self assert:((res at: 1) =  1112297303). "16r424c4f571"
self assert:((res at: 2) =   1179210568)."16r46495348"! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testEcbDecrypt
	|key cl enc res |
key:=ByteArray fromHexString:   'FFFFFFFFFFFFFFFF'.
cl := ByteArray fromHexString:  'FFFFFFFFFFFFFFFF'.
enc :=ByteArray fromHexString:  '51866FD5B85ECB8A' . 
res:=(CPBBlowfish ecbDecrypt: enc with: key ).
self assert: (res = cl).! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testEcbEncrypt
	|key cl enc res |
key:=ByteArray fromHexString:   'FFFFFFFFFFFFFFFF'.
cl := ByteArray fromHexString:  'FFFFFFFFFFFFFFFF'.
enc :=ByteArray fromHexString:  '51866FD5B85ECB8A' . 
res:=(CPBBlowfish ecbEncrypt: cl with: key ) .

self assert: (res= enc).! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testEncryptDecrypt

self assert:((CPBBlowfish decryptToString:    (CPBBlowfish encryptString: '0123456789' with: 'AAAAA'  )  with:'AAAAA'  )='0123456789')! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testEncryption
|key data res|
key:='abcdefghijklmnopqrstuvwxyz'.
data:=WordArray  new: 2.
#(16r424C4F57 16r46495348) doWithIndex: [:each :i | data at: i put: ((each asByteArray) unsignedLongAt: 1 bigEndian:true)    ].
res:=(CPBBlowfish encrypt: data with:   key asByteArray).


self assert:((res at: 1) = 844026110). "16r324ed0fe"
self assert:((res at: 2) =  4094927363)."16rf413a203"! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testLongDecryptionTest

(1 to: keys size) do:[:each | |key clearText cipherText enc| 
	key:= keys at: each.
	clearText:=clear at: each.
	cipherText:=encrypted at: each.
	enc:=CPBBlowfish decrypt: cipherText  with: key.   
	self assert:   (enc = clearText asArray )
	]! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testLongEncryptionTest

(1 to: keys size) do:[:each | |key clearText cipherText enc| 
	key:= keys at: each.
	clearText:=clear at: each.
	cipherText:=encrypted at: each.
	enc:=CPBBlowfish encrypt: clearText  with: key.   
	self assert:   (enc = cipherText )
	]! !!ByteArray class methodsFor: '*CPBBlowfish' stamp: 'gsa 5/1/2012 10:47'!fromHexString: aString

	^ self readHexFrom: aString! !!Integer methodsFor: '*CPBBlowfish' stamp: 'gsa 4/30/2012 19:23'!asByteArray

	| stream |
	stream := WriteStream on: ByteArray new.
	self digitLength to: 1 by: -1 do: [:digitIndex |
		stream nextPut: (self digitAt: digitIndex)].
	^ stream contents! !!String class methodsFor: '*CPBBlowfish' stamp: 'gsa 4/30/2012 20:02' prior: 30215783!fromByteArray: aByteArray

	^ aByteArray asString
! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 33873611!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15' prior: 33873925!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .  
	].
	! !| writer runner |
runner := (CPBBlowfishSuite) run: 3 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'.
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/Blowfish.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 33888431!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 33889281!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 33889432!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33889639!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33889859!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33890481!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33890979!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33891435!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33891700!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33891896!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33892344!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33892546!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33892669!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 33892807!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 33893101!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 33893583!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 33894496!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 33894929!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 33895075!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 33895519!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 33896135!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 33896320!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 33896505!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 33896634!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 33897362!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33897769!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33898174!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33898505!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 33898925!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33899079!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 33900333!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 33900470!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 33900810!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 33901633!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33902040!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33902192!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 33902346!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 33902847!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33903364!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33903469!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33903611!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33903724!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 33903937!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 33904219!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33904348!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33904461!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33904733!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 33904953!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 33905070!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 33905195!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 33905350!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 33905901!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33906365!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33906460!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33906573!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33906662!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33906793!suite
	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33906876!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33906993!total
	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33907075!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 33907612!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 33907914!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 33908331!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 33908490!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 33908756!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 33908878!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 33909022!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 33909143!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 33909457!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 33909730!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 33909975!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 33910129!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 33910242!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 33910351!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 33910520!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 33910892!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 33911327!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 33911795!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 33911925!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 33912271!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 33912559!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 33912689!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 33912818!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 33912948!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 33913100!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 33913727!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 33913908!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 33914664!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 33915528!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 33915988!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 33916147!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 33916468!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 33917064!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 33917356!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 33917511!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 33918147!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 33918662!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 33918959!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 33919143!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 33919323!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 33919488!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 33919762!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 33920046!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 33920330!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 33920964!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 33921491!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 33921740!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 33922018!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 33922359!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 33923627!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 33924032!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 33924839!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 33925076!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 33925574!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 33925981!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 33926541!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 33926813!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33926984!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33927256!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 33927415!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33927576!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 33927882!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 33928142!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33928359!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33928887!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33929219!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 33929363!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 33929471!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 33929555!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 33929769!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 33929894!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33930046!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33930317!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 33930438!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 33930619!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 33930856!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 33931041!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 33931274!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 33931431!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 33931859!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33932192!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 33932325!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 33932455!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 33932756!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33932898!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33933003!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33933128!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 33933365!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 33933788!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 33934330!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 33934983!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 33936111!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33936390!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33936616!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 33936864!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 33936998!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 33937146!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 33937580!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 33937833!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 33938197!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 33938812!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 33938978!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 33939135!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 33939275!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 33939414!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 33939771!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 33978596!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15' prior: 33978918!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBInplaceComplex	instanceVariableNames: 'a b'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBInplaceComplex
	instanceVariableNames: 'a b'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:41'!absSq
	^(a*a) + (b*b)! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:36'!add: aComplex
	a := a + aComplex real.
	b := b + aComplex imaginary.! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:36'!imaginary
	^b.! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:36'!real
	^a.! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:33'!real: aNumber imaginary: bNumber
	a := aNumber.
	b := bNumber.
	! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:35'!square
	| tempA |
	tempA := (a * a) - (b * b).
	b := 2 * a * b.
	a := tempA.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBInplaceComplex class
	instanceVariableNames: ''!!CPBInplaceComplex class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:33'!real: a imaginary: b
	^(self new) real: a imaginary: b.
	! !!CPBInplaceComplex class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:39'!zero
	^(self new) real: 0 imaginary: 0.
	! !Object subclass: #CPBMandelbrot	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBMandelbrot
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Mandelbrot'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBMandelbrot class
	instanceVariableNames: ''!!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 14:49'!calculateAt: aComplex value: anotherComplex iteration: aNumber maxIterations: anotherNumber
	(aNumber >= anotherNumber) ifTrue: [^anotherNumber].
	anotherComplex square.
	anotherComplex add: aComplex.
	(anotherComplex absSq >= 4)
		ifTrue: [^ aNumber]
		ifFalse: [^ self
				calculateAt: aComplex
				value: anotherComplex
				iteration: aNumber + 1
				maxIterations: anotherNumber]! !!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 14:49'!calculateAtIterative: aComplex maxIterations: maxIterations
	| current |
	current := CPBInplaceComplex zero.
	0 to: maxIterations do: [:iteration|
		current square.
		current add: aComplex.
		(current absSq >= 4) ifTrue:[
			^iteration.	
		].
	].
	^maxIterations.! !!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 14:49'!calculateAtRecursive: aComplex maxIterations: aNumber
	^self calculateAt: aComplex value: CPBInplaceComplex zero iteration: 0 maxIterations: aNumber.! !SMarkSuite subclass: #CPBMandelbrotBenchmarkSuite	instanceVariableNames: 'mandelbrotMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!SMarkSuite subclass: #CPBMandelbrotBenchmarkSuite
	instanceVariableNames: 'mandelbrotMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18'!benchMandelbrotIterative1Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18'!benchMandelbrotIterative2Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18'!benchMandelbrotIterative4Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 4;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18'!benchMandelbrotIterative8Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 8;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18'!benchMandelbrotRecursive1Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18'!benchMandelbrotRecursive2Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18'!benchMandelbrotRecursive4Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 4;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:19'!benchMandelbrotRecursive8Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 8;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'initialize-release' stamp: 'MP 1/27/2014 14:16'!setUp
	mandelbrotMorph := CPBMandelbrotMorph new.
	mandelbrotMorph
		extent: 50@50;
		depth: 85;
		imageBounds: ((-0.3@ -0.9) corner: (0.0 @ -0.6)).! !Morph subclass: #CPBMandelbrotMorph	instanceVariableNames: 'form mode threadCount depth imageBounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Morph subclass: #CPBMandelbrotMorph
	instanceVariableNames: 'form mode threadCount depth imageBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 14:11'!calculate
	1
		to: self form width
		do: [:x | 1
				to: self form height
				do: [:y | self
						calculateValAt: x@y]]! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 15:29'!calculateValAt: aPoint
	| val aComplex |
	aComplex := (Complex
		real: (aPoint x * (self imageBounds width / self form width) + self imageBounds left) asFloat
		imaginary: (aPoint y * (self imageBounds height / self form height) + self imageBounds top) asFloat).
 	(self mode = #iterative) ifTrue: [
		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.
	] ifFalse: [
		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.
	].
	self form colorAt: aPoint put: (self colorForValue: val).! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/7/2014 12:18'!calculateWithThreads: anInteger
| semaphores |
	semaphores := OrderedCollection new.
	1 to: anInteger do:[ :i |
			semaphores add: (self createThread: i of: anInteger).
		].
	semaphores do: [:s| s wait].! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/16/2014 15:01'!colorForValue: val
	| r g b |
	(val = self depth) ifTrue:[^Color black].
	r := (((val+1) * 2) rem: 256)/256.
	g := (((val+1) * 3) rem: 256)/256.
	b := (((val+1) * 5) rem: 256)/256.
	^ Color r: r g: g b: b.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/7/2014 12:33'!createThread: threadNumber of: threadCount
| semaphore |
semaphore := Semaphore new.
[ | index maxIndex |
	maxIndex := self form width * self form height.
	index := threadNumber.
	[index < maxIndex] whileTrue: [
		self calculateValAt: (self pointForIndex: index).
		index := index + threadCount.
	].
	semaphore signal.
] fork.
^ semaphore.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/10/2013 14:08'!drawOn: aCanvas 
	super drawOn: aCanvas.
	aCanvas drawImage: self form at: self topLeft! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/10/2013 14:02'!form
	form ifNil: [form := Form extent: self extent depth: 32].
	^form.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 15:38'!handlesMouseDown: anEvent
	^true.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 15:43'!mouseDown: anEvent
	| p |
	p := anEvent position - self topLeft.
	Transcript showln: (Complex 
		real: ((p x * (self imageBounds width / self form width)) + self imageBounds left) asFloat
		imaginary: ((p y * (self imageBounds height / self form height)) + self imageBounds top) asFloat)! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/7/2014 11:58'!pointForIndex: anInteger
	| x y |
	y := (anInteger / self width) floor.
	x := anInteger - (self width * y).
	
	^ x@y.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/7/2014 12:06'!reCalculate
	form := nil.
	(self threadCount <= 1) ifTrue: [
		self calculate.
	] ifFalse: [
		self calculateWithThreads: self threadCount.
	].
	self changed.! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/11/2013 14:55'!depth
	depth ifNil: [depth := 100].
	^depth! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/11/2013 14:54'!depth: aNumber
	depth := aNumber! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/10/2013 16:04'!form: anObject

	form := anObject! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/11/2013 15:27'!imageBounds
	imageBounds ifNil: [imageBounds := -2@ -1.5 corner: 1@1.5].
	^imageBounds! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/11/2013 15:27'!imageBounds: aRectangle
	imageBounds := aRectangle! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/10/2013 16:04'!mode
	mode ifNil: [mode := #iterative].
	^ mode! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/10/2013 16:04'!mode: anObject

	mode := anObject! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 1/7/2014 12:03'!threadCount
	threadCount ifNil: [threadCount := 1].
	^ threadCount! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 1/7/2014 12:04'!threadCount: anInteger
	threadCount := anInteger.! !| writer runner |
runner := (CPBMandelbrotBenchmarkSuite) run: 1 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'. 
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/Mandelbrot.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 33980508!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 33981348!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 33981498!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33981701!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33981917!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33982526!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33983019!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33983468!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33983730!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 33983925!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33984358!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33984558!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 33984680!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 33984817!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 33985106!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 33985580!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 33986473!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 33986902!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 33987047!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 33987487!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 33988091!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 33988274!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 33988457!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 33988585!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 33989308!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33989708!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33990101!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33990424!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 33990835!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33990988!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 33992212!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 33992348!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 33992679!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 33993481!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33993876!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 33994027!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 33994180!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 33994673!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33995180!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33995284!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33995425!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 33995536!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 33995746!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 33996025!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33996153!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33996265!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 33996527!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 33996745!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 33996861!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 33996985!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 33997139!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 33997680!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33998138!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33998232!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33998344!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33998432!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33998562!suite
	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33998644!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33998760!total
	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 33998841!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 33999373!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 33999666!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 34000073!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 34000228!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34000490!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34000611!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 34000754!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 34000874!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34001181!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34001452!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 34001695!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 34001847!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 34001959!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 34002067!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 34002234!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 34002596!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 34003022!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34003476!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34003605!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 34003946!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 34004231!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 34004360!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 34004488!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34004617!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34004768!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 34005384!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 34005563!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 34006302!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 34007159!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34007604!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34007761!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 34008079!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 34008667!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 34008958!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 34009111!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 34009735!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 34010242!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 34010539!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34010721!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34010899!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34011062!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34011330!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 34011612!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 34011889!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 34012511!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 34013030!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 34013274!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 34013545!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 34013877!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 34015108!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 34015503!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 34016290!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 34016525!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 34017017!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 34017419!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34017971!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34018239!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34018408!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34018675!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34018832!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34018991!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 34019293!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 34019550!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34019765!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34020278!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34020603!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34020746!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34020853!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34020936!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 34021148!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 34021272!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34021422!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34021689!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34021809!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 34021989!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 34022223!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 34022406!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 34022637!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 34022792!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34023215!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34023544!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34023675!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 34023804!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 34024099!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34024239!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34024343!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34024467!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34024702!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 34025115!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 34025652!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 34026299!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 34027400!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34027673!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34027897!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 34028143!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 34028276!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 34028423!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34028846!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34029095!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 34029456!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34030064!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34030229!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34030385!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34030524!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 34030662!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 34031014!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 34031644!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15' prior: 34031958!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-Polymorphy'!SMarkSuite subclass: #CPBPolymorphyBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Polymorphy'!SMarkSuite subclass: #CPBPolymorphyBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Polymorphy'!!CPBPolymorphyBenchmark methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:40'!benchPolymorphy
	CPBPolymorphyBenchmark run .! !!CPBPolymorphyBenchmark methodsFor: 'initialize-release' stamp: 'MP 1/27/2014 14:40'!setUp
	CPBPolymorphyBenchmark setUp .! !!CPBPolymorphyBenchmark methodsFor: 'initialize-release' stamp: 'MP 1/27/2014 14:40'!tearDown
	CPBPolymorphyBenchmark tearDown .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBPolymorphyBenchmark class	instanceVariableNames: 'initials'!CPBPolymorphyBenchmark class
	instanceVariableNames: 'initials'!!CPBPolymorphyBenchmark class methodsFor: 'benchmarking' stamp: 'BS 1/21/2014 13:02'!getImplementingClasses
	^{
		Object class.
		Morph class.
		Collection class.
		String class.
		FontSet class.
		Canvas class.
		Stream class.
		Number class.
		Behavior class.
		Error class.
	}! !!CPBPolymorphyBenchmark class methodsFor: 'benchmarking' stamp: 'BS 1/21/2014 13:04'!run
	1 to: 300
		do: [:i| Object class allSubclasses
				do: [:mc | mc soleInstance test123polbench: i]]! !!CPBPolymorphyBenchmark class methodsFor: 'benchmarking' stamp: 'BS 1/21/2014 13:03'!setUp
	initials := Utilities authorInitialsPerSe.
	Utilities setAuthorInitials: 'test'.
	self getImplementingClasses do: [:c |
		c compile: 'test1polbench: i ', String cr, '^''I am ', c name, ''', i asString'.
		c compile: 'test2polbench: i ', String cr, '^''I still am ', c name, ''', i asString'.
		c compile: 'test3polbench: i ', String cr, '^''I allways was ', c name, ''', i asString'.
		c compile: 'test123polbench: i ', String cr,
			'self test1polbench: i.', String cr,
			'self test2polbench: i.', String cr,
			'self test3polbench: i.'.
	].! !!CPBPolymorphyBenchmark class methodsFor: 'benchmarking' stamp: 'BS 1/21/2014 13:03'!tearDown
	Utilities setAuthorInitials: initials.
	self getImplementingClasses do: [:c |
		c removeSelector: #test1polbench:.
		c removeSelector: #test2polbench:.
		c removeSelector: #test3polbench:.
		c removeSelector: #test123polbench:].! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !Object class removeSelector: #test1polbench:!Object class removeSelector: #test2polbench:!Object class removeSelector: #test3polbench:!Object class removeSelector: #test123polbench:!Morph class removeSelector: #test1polbench:!Morph class removeSelector: #test2polbench:!Morph class removeSelector: #test3polbench:!Morph class removeSelector: #test123polbench:!Collection class removeSelector: #test1polbench:!Collection class removeSelector: #test2polbench:!Collection class removeSelector: #test3polbench:!Collection class removeSelector: #test123polbench:!String class removeSelector: #test1polbench:!String class removeSelector: #test2polbench:!String class removeSelector: #test3polbench:!String class removeSelector: #test123polbench:!FontSet class removeSelector: #test1polbench:!FontSet class removeSelector: #test2polbench:!FontSet class removeSelector: #test3polbench:!FontSet class removeSelector: #test123polbench:!Canvas class removeSelector: #test1polbench:!Canvas class removeSelector: #test2polbench:!Canvas class removeSelector: #test3polbench:!Canvas class removeSelector: #test123polbench:!Stream class removeSelector: #test1polbench:!Stream class removeSelector: #test2polbench:!Stream class removeSelector: #test3polbench:!Stream class removeSelector: #test123polbench:!Number class removeSelector: #test1polbench:!Number class removeSelector: #test2polbench:!Number class removeSelector: #test3polbench:!Number class removeSelector: #test123polbench:!Behavior class removeSelector: #test1polbench:!Behavior class removeSelector: #test2polbench:!Behavior class removeSelector: #test3polbench:!Behavior class removeSelector: #test123polbench:!Error class removeSelector: #test1polbench:!Error class removeSelector: #test2polbench:!Error class removeSelector: #test3polbench:!Error class removeSelector: #test123polbench:!!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !Object class removeSelector: #test1polbench:!Object class removeSelector: #test2polbench:!Object class removeSelector: #test3polbench:!Object class removeSelector: #test123polbench:!Morph class removeSelector: #test1polbench:!Morph class removeSelector: #test2polbench:!Morph class removeSelector: #test3polbench:!Morph class removeSelector: #test123polbench:!Collection class removeSelector: #test1polbench:!Collection class removeSelector: #test2polbench:!Collection class removeSelector: #test3polbench:!Collection class removeSelector: #test123polbench:!String class removeSelector: #test1polbench:!String class removeSelector: #test2polbench:!String class removeSelector: #test3polbench:!String class removeSelector: #test123polbench:!FontSet class removeSelector: #test1polbench:!FontSet class removeSelector: #test2polbench:!FontSet class removeSelector: #test3polbench:!FontSet class removeSelector: #test123polbench:!Canvas class removeSelector: #test1polbench:!Canvas class removeSelector: #test2polbench:!Canvas class removeSelector: #test3polbench:!Canvas class removeSelector: #test123polbench:!Stream class removeSelector: #test1polbench:!Stream class removeSelector: #test2polbench:!Stream class removeSelector: #test3polbench:!Stream class removeSelector: #test123polbench:!Number class removeSelector: #test1polbench:!Number class removeSelector: #test2polbench:!Number class removeSelector: #test3polbench:!Number class removeSelector: #test123polbench:!Behavior class removeSelector: #test1polbench:!Behavior class removeSelector: #test2polbench:!Behavior class removeSelector: #test3polbench:!Behavior class removeSelector: #test123polbench:!Error class removeSelector: #test1polbench:!Error class removeSelector: #test2polbench:!Error class removeSelector: #test3polbench:!Error class removeSelector: #test123polbench:!!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Object class', i asString! !!Object class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Morph class', i asString! !!Morph class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Collection class', i asString! !!Collection class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was String class', i asString! !!String class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was FontSet class', i asString! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Canvas class', i asString! !!Canvas class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Stream class', i asString! !!Stream class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Number class', i asString! !!Number class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Behavior class', i asString! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test1polbench: i ^'I am Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test2polbench: i ^'I still am Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test3polbench: i ^'I allways was Error class', i asString! !!Error class methodsFor: 'as yet unclassified' stamp: 'test 6/11/2014 20:04'!test123polbench: i self test1polbench: i.self test2polbench: i.self test3polbench: i.! !Object class removeSelector: #test1polbench:!Object class removeSelector: #test2polbench:!Object class removeSelector: #test3polbench:!Object class removeSelector: #test123polbench:!Morph class removeSelector: #test1polbench:!Morph class removeSelector: #test2polbench:!Morph class removeSelector: #test3polbench:!Morph class removeSelector: #test123polbench:!Collection class removeSelector: #test1polbench:!Collection class removeSelector: #test2polbench:!Collection class removeSelector: #test3polbench:!Collection class removeSelector: #test123polbench:!String class removeSelector: #test1polbench:!String class removeSelector: #test2polbench:!String class removeSelector: #test3polbench:!String class removeSelector: #test123polbench:!FontSet class removeSelector: #test1polbench:!FontSet class removeSelector: #test2polbench:!FontSet class removeSelector: #test3polbench:!FontSet class removeSelector: #test123polbench:!Canvas class removeSelector: #test1polbench:!Canvas class removeSelector: #test2polbench:!Canvas class removeSelector: #test3polbench:!Canvas class removeSelector: #test123polbench:!Stream class removeSelector: #test1polbench:!Stream class removeSelector: #test2polbench:!Stream class removeSelector: #test3polbench:!Stream class removeSelector: #test123polbench:!Number class removeSelector: #test1polbench:!Number class removeSelector: #test2polbench:!Number class removeSelector: #test3polbench:!Number class removeSelector: #test123polbench:!Behavior class removeSelector: #test1polbench:!Behavior class removeSelector: #test2polbench:!Behavior class removeSelector: #test3polbench:!Behavior class removeSelector: #test123polbench:!Error class removeSelector: #test1polbench:!Error class removeSelector: #test2polbench:!Error class removeSelector: #test3polbench:!Error class removeSelector: #test123polbench:!| writer runner |
runner := (CPBPolymorphyBenchmark) run: 1 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'. 
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/Polymorphy.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 34043405!A benchmark harness stears the execution and reporting of benchmarks.For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.The benchmark harness is also parameterized by the benchmark suites that are to be executed.The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.However, directly using the harness classes gives more freedom on reporting and execution strategies.A typical call of the harness from the commandline would result in the following invokation:	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34044245!defaultArgumentParser	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 34044395!parseArguments: arguments	| parser |	parser := self defaultArgumentParser new.	parser harness: self.	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34044598!shouldShowUsage: arguments		arguments size < 2 ifTrue: [^ true ].		^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34044814!usage	| usage |	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"		usage := self usageHeader.		usage := usage, 'Arguments:', String crlf.	usage := self usageRunner:   usage.	usage := self usageReporter: usage.	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.	usage := self usageBenchmarkParameters: usage.		ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34045423!usageBenchmarkParameters: usage	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,				' processes          optional, number of processes/threads used by the benchmarks', String crlf,				' problemSize        optional, depending on benchmark for instance number of', String crlf,				'                              inner iterations or size of used data set', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34045916!usageHeader	| usage |	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.	usage := usage, String crlf.	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.	usage := usage, String crlf.	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34046365!usageReporter: usage	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,				'                              and displays the results', String crlf.	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34046627!usageRunner: usage	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34046822!version	(Smalltalk classNamed: #ConfigurationOfBenchmarking)		ifNotNilDo: [:cfg |			^ cfg project currentVersion versionNumber asString.		].	  	(Smalltalk classNamed: #MCPackage)		ifNotNilDo: [:mcp |			| package |			package := mcp named: 'SMark'.			package hasWorkingCopy ifTrue: [				^ package workingCopy ancestors first name.			].		].		^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34047255!defaultOutputDestination	^ Smalltalk at:       #ScriptConsole	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34047455!defaultReporter	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34047577!defaultRunner	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 34047714!execute: runner andReport: reporter	runner reportConfiguration: self defaultOutputDestination.	runner execute.	reporter runner: runner.	reporter outputStream: self defaultOutputDestination.	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 34048003!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass	| parsedBenchmarkOrSuite runner reporter |		parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.		runner := aRunnerClass new.	reporter := withAReporterClass new.	self instructRunner: runner with: parsedBenchmarkOrSuite.	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 34048477!run: arguments	"Execcuted from the command line using something similar to	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"	| runner reporter runnerAndReporter |		(self shouldShowUsage: arguments)		ifTrue: [			self usage.			^ self.		].		runnerAndReporter := self parseArguments: arguments.	runner := runnerAndReporter first.	reporter := runnerAndReporter second.  		self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 34049370!The ReBenchHarness is optimized for use from the command-line.It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34049799!defaultArgumentParser	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34049944!usageBenchmarkParameters: usage	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,				' inner-iterations   optional, number of iterations done by a single process', String crlf,				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34050384!usageHeader	| usage |	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.	usage := usage, String crlf.	usage := usage, 'Usage: <vm+image> ', self name,				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.	usage := usage, String crlf.		usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.		usage := usage, String crlf.	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34050988!usageReporter: usage	"Will rely on default, which is good for ReBench, so do not advertise option."	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34051171!usageRunner: usage	"Will rely on default, which is good for ReBench, so do not advertise option."	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 34051354!defaultReporter	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 34051482!defaultRunner	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 34052205!determineBenchmarkParameters	"Initialize with defaults, will be overwritten in case	 it is specified."	iterations := runner class defaultNumberOfIterations.	processes  := runner class defaultNumberOfProcesses.	problemSize:= suiteClass defaultProblemSize.		self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34052605!determineBenchmarkParametersFromArguments	i := i + 1.	i <= numParams ifTrue: [		iterations := (arguments at: i) asInteger.		i := i + 1.		i <= numParams ifTrue: [			processes := (arguments at: i) asInteger.			i := i + 1.			i <= numParams ifTrue: [				problemSize := arguments at: i.			]		]	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34052998!determineReporter	(currentObj isKindOf: SMarkReporter)		ifFalse: [ reporter := harness defaultReporter new. ]		ifTrue:  [ reporter := currentObj.			i := i + 1.			i <= numParams ifTrue: [				current := arguments at: i.			]		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34053321!determineRunner	(currentObj isKindOf: SMarkRunner)		ifFalse: [ runner := harness defaultRunner new. ]		ifTrue:  [ runner := currentObj.			i := i + 1.			i <= numParams ifTrue: [				current := arguments at: i.				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].			]		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 34053732!determineSuiteOrBenchmark	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34053885!parseBenchmarkOrSuite: aBenchmarkOrSuite	"Identify the benchmark suite or suite and benchmark method	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.	 Accepts a string, class, or array.	 Returns, a class, or an array of a class and a symbol."	| parsed |	(aBenchmarkOrSuite isKindOf: Class)		ifTrue: [			suiteClass := aBenchmarkOrSuite.			^ suiteClass		].	  	(aBenchmarkOrSuite isKindOf: Array)		ifTrue:  [ parsed := aBenchmarkOrSuite. ]		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].		((parsed size > 2) or: [parsed size < 1])				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].		suiteClass := parsed first.		(suiteClass isKindOf: Class) 		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].		parsed size = 1		ifTrue: [^suiteClass].	specificBenchmark := parsed second asSymbol.		^ { suiteClass. specificBenchmark }! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 34055109!harness: aHarness	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 34055245!instructRunner	suite := suiteClass new.	specificBenchmark ifNotNil: [		suite runOnly: specificBenchmark.	].		runner suite: suite. 	runner iterations: iterations.	runner processes: processes.	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 34055576!parse: argumentsArray	arguments := argumentsArray.	numParams := arguments size.		i := 2.	current := arguments at: i.	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].			self determineRunner.	self determineReporter.		self determineSuiteOrBenchmark.		self determineBenchmarkParameters.		self instructRunner.		^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 34056378!determineBenchmarkParametersFromArguments	i := i + 1.	i <= numParams ifTrue: [		processes := (arguments at: i) asInteger.		i := i + 1.		i <= numParams ifTrue: [			iterations := (arguments at: i) asInteger.			i := i + 1.			i <= numParams ifTrue: [				problemSize := arguments at: i.			]		]	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34056773!determineReporter	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34056924!determineRunner	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 34057077!instructRunner	super instructRunner.		runner iterations: runner class defaultNumberOfIterations.	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 34057570!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.Instance Variables:	runner	<PBenchmarkRunner>	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>		Example:	f := TextStream on: String new.	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34058077!benchmarkFooter: aName	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34058181!benchmarkHeader: aName	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34058322!footer	"No output at the moment"	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34058433!header	| suiteName |	suiteName := runner suite class name asString.	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34058643!reportAllRuns: aListOfResults of: benchmark	aListOfResults do: [:result |		result criteria keysAndValuesDo: [:benchName :timer |			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 34058922!initialize	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34059050!outputStream: aStream	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34059162!report	self header.		runner results keysAndValuesDo: [:key :value |		self benchmarkHeader: key.		self reportAllRuns: value of: key.		self benchmarkFooter: key.	].	self footer.	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34059424!runner: aRunner	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34059642!defaultOutputDestination	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34059758!defaultReporter	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34059882!reportFor: aRunner	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34060036!reportFor: aRunner on: aStream	| reporter |	reporter := self new.	reporter runner: aRunner.	reporter outputStream: aStream.	reporter report.	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 34060577!A benchmark result is characterized by: - the total execution time (#total is the least a benchmark results in) - the name of the benchmark that was executed - the suite object specifies the used input used for the benchmark - dictionary of additional the criteria and the related timingsA benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34061035!benchmarkName	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34061129!benchmarkName: aString	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34061241!criteria	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34061329!criteria: aCollectionOfTimers	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34061459!suite	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34061541!suite: aBenchmarkSuite	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34061657!total	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34061738!total: aTime	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 34062270!createTimer: name	"Create and register a new timer for the current benchmark"	| timer |	timer := self class defaultTimer new: name.		timers ifNotNil: [		timers at: name put: timer.	].		^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 34062563!recordResults: timer for: aSelector	| result name |	name := suite benchmarkNameForSelector: aSelector.		result := SMarkResult new.	result total: timer totalTime.	result benchmarkName: name.	result suite: suite.	result criteria: timers.		(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 34062970!execute	suite run.	self runBaseBenchmark.	^ results	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 34063125!initialize	super initialize.	numIterations := self class defaultNumberOfIterations.	numProcesses  := self class defaultNumberOfProcesses.	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34063387!iterations	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34063508!iterations: anInteger	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 34063651!problemSize	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 34063771!problemSize: aValue	"Do some conversion to make it easier for the benchmarks"	(aValue isString and: [aValue isAllDigits]) ifTrue: [		problemSize := Number readFrom: aValue.		^ self.	].	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34064078!processes	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34064349!processes: anInt	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 34064592!report	SMarkReporter defaultReporter reportFor: self.  	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 34064744!results	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 34064856!suite	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 34064964!suite: aBenchmarkSuite	suite := aBenchmarkSuite.	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 34065131!performBenchmark: aSelector	currentBenchmark := aSelector.		1 to: numIterations do: [:i|		"self timedBenchmarkExecution: aSelector."		suite runBenchmark: aSelector.  	].			currentBenchmark := nil.		^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 34065493!runBaseBenchmark	"In certain sitatuations it is one wants a baseline that is incooprated in all 	 benchmark results to be substracted from the final values.		#baseBenchmark can be used to charaterize such a baseline"		(suite respondsTo: #baseBenchmark) 		ifFalse: [ ^ nil ].		^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 34065919!timedBenchmarkExecution: aSelector	"Will do a timed execution of the benchmark and return the result timer"	| timer result |	timers := Dictionary new.	timer := self createTimer: 'total'.		timer start.	result := suite perform: aSelector.	timer stop.	suite processResult: result withTimer: timer.		self recordResults: timer for: aSelector.		^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34066373!printOn: aStream	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34066502!reportConfiguration: aStream	aStream << 'Runner Configuration:';cr.	aStream << ('  iterations: ', numIterations asString); cr.	aStream << ('  processes: ', numProcesses asString); cr.	aStream << ('  problem size: ', problemSize asString); cr.! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 34066843!reportOn: aStream	SMarkReporter defaultReporter reportFor: self on: aStream  	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 34067128!defaultNumberOfIterations	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 34067257!defaultNumberOfProcesses	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 34067385!defaultTimer	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34067514!execute: aSuite	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34067665!execute: aSuite with: nIterations	| runner |	runner := self new.	aSuite runner: runner.	runner suite: aSuite.	runner iterations: nIterations.  	runner execute.	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 34068281!initialize	super initialize.	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 34068460!performBenchmark: aSelector	"First determine a useful number of inner loop iterations until the targetTime is reached."	| execTime i |	"make sure no timers are recorded for this"	timers := nil.		i := 1.	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].		[ execTime > targetTime ] whileFalse: [		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].	].	innerLoopIterations := i.		"Then start executing the benchmark"	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 34069199!runBaseBenchmark	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"		(suite respondsTo: #baseBenchmark) 		ifFalse: [ ^ nil ].		"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 34070056!timedBenchmarkExecution: aSelector	"Will do a timed execution of the benchmark and return the result timer"	| timer |	timers := Dictionary new.	timer := self createTimer: 'total'.		timer start.	1 to: innerLoopIterations do: [:ignored|		suite perform: aSelector.	].	timer stop.		self recordResults: timer for: aSelector.		^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34070501!targetTime	"Target time in milliseconds"	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34070658!targetTime: anIntInMilliseconds	"Target time in milliseconds"	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 34070976!defaultTargetTime	"300 milliseconds seems to be a reasonable target time for most problems.	 It is a compromise between the general measurment noise as well as timer accuracy	 and the absolute runtime of benchmarks"	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 34071564!This runner is doing warmup on for Cog VMs with just-in-time compilation.The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 34071855!initialize	super initialize.	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 34072008!performBenchmark: aSelector	"Based on an email by Eliot from May 16th, 2011.	 The first time a method is executed it will get into the inline cache.	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.	 Thus, the third time it should be executed in the steady state."	warmingUp := true.		suite runBenchmark: aSelector.		Smalltalk garbageCollect.		suite runBenchmark: aSelector.		Smalltalk garbageCollect.	warmingUp := false.		^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 34072632!recordResults: timer for: aSelector	"Only record the results when we are not in warmup mode."	warmingUp ifFalse: [		super recordResults: timer for: aSelector.	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 34073139!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 34073436!execute	"run all benchmnarks in a benchmark suite "	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34073618!execute: aSelector		[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34073796!initialize	super initialize.	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34073959!performBenchmark: aSelector	currentBenchmark := aSelector.		1 to: numIterations do: [:i|		suite runBenchmark: aSelector ].			currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34074227!timedBenchmarkExecution: aSelector	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 34074509!execute: aSuite selector: aBenchmarkSelector	| runner |	runner := self new.	aSuite runner: runner.	runner 		suite: aSuite;		execute: aBenchmarkSelector.	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 34074786!execute: aSuite selector: aBenchmarkSelector iterations: nIterations	| runner |	runner := self new.	aSuite runner: runner.	runner 		suite: aSuite;		iterations: nIterations;		execute: aBenchmarkSelector.	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 34075408!confidenceVariance: times	| numMeasurements |	numMeasurements := times size.	(numMeasurements >= 30) 		ifTrue: [			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].			"use the students T distribution for small probe counts"	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 34075927!gaussianConfidenceFactor	"used for large probe counts >= 30"	"1 ~ 68.27%"	"1.644853626951 ~ 90%"	"2 ~ 95.45%"	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 34076171!significantDigits: confidenceVariance	confidenceVariance = 0 		ifTrue: [ ^ 2].		confidenceVariance >= 10		ifTrue: [ ^ 0].		^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 34076442!standardDeviation: times	| average variance |	average := times average .	variance := 0.0 .	times do: [:item|		variance:=variance+((item-average) squared) ].		variance:=variance / times size .		^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 34076774!studentsTConfidenceFactorFor: aNumberOfMeasurements	"used for small probe counts < 30"	"the students T distribution sucks to calculate since the value depends on the probeCout"	"these values are for a confidence interval of ~90%"	| values |	values := Array new: 30.	values at: 1  put: 6.314.	values at: 2  put: 2.920.	values at: 3  put: 2.353.	values at: 4  put: 2.132.	values at: 5  put: 2.015.	values at: 6  put: 1.943.	values at: 7  put: 1.895.	values at: 8  put: 1.860.	values at: 9  put: 1.833.	values at: 10 put: 1.812.	values at: 11 put: 1.796.	values at: 12 put: 1.782.	values at: 13 put: 1.771.	values at: 14 put: 1.761.	values at: 15 put: 1.753.	values at: 16 put: 1.746.	values at: 17 put: 1.740.	values at: 18 put: 1.734.	values at: 19 put: 1.729.	values at: 20 put: 1.725.	values at: 21 put: 1.721.	values at: 22 put: 1.717.	values at: 23 put: 1.714.	values at: 24 put: 1.711.	values at: 25 put: 1.708.	values at: 26 put: 1.706.	values at: 27 put: 1.703.	values at: 28 put: 1.701.	values at: 29 put: 1.699.	values at: 30 put: 1.697.	^ values at: aNumberOfMeasurements.	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 34078005!reportAllRuns: aListOfResults of: benchmark	| criteria |	criteria := aListOfResults first criteria.		criteria keysDo: [:criterion |		| times |		times := self resultsFor: criterion from: aListOfResults.		self reportResult: times for: criterion of: benchmark.		stream cr.	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 34078400!reportResult: aResultsArray for: aCriterion of: benchmark	| convidenceVariance significantDigits |	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.	aResultsArray size printOn: stream .	stream << ' runtime: '.		aResultsArray size < 2 ifTrue: [		aResultsArray average printOn: stream.		stream << 'ms'.		^ self.	].		convidenceVariance := self confidenceVariance: aResultsArray.  		"only print significant "	significantDigits := self significantDigits: convidenceVariance.	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.	stream << 'ms +/-'.	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 34079187!resultsFor: aCriterion from: aListOfResults	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 34079422!totalResultsFor: aListOfResults	^aListOfResults collect: [:timer | timer total]	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 34079914!benchmarkHeader: aName	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 34080316!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.However, it does not really know how to execute it.It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.Usage: Choose a suite and use the class-side #run. Print the result of the following expression:   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34080868!benchmarkNameForSelector: selector	"Extracts the actual name of the benchmark from the selector"	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].	^ selector asSymbol	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34081136!shouldRunSelector: selector	(selector includes: $:) ifTrue: [ ^ false ].	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34081305!cleanUpInstanceVariables	"Make sure all variables that are 'user variables' get cleaned"		self class allInstVarNames do: [ :name |		name = 'runner' ifFalse: [			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34081572!setUp	"subclass responsibility to set up the necessary environment for a benchmark"	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34081729!tearDown	"subclass responsibility to clean up the environment after a benchmark"	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34081888!performCustomSelector: aSelector with: aPrefix	| customSelector |	customSelector := (aPrefix, aSelector capitalized) asSymbol.	(self respondsTo: customSelector) ifTrue: [ 		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 34082190!problemSize	runner             ifNil: [^ self class defaultProblemSize].	runner problemSize ifNil: [^ self class defaultProblemSize].	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 34082447!processResult: anObject withTimer: aSMarkTimer	"subclass responsability. You can verify your results here, or do things with the timer."	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34082662!run	"Executes all the benchmarks in the suite, 	 coordinating with the runner when necessary"		| potentialBenchmarkSelectors |	selectedBenchmarks		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].						potentialBenchmarkSelectors		do: [ :selector |			(self shouldRunSelector: selector)				ifTrue: [					runner performBenchmark: selector ]		].	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34083175!runBenchmark: aSelector		[self setUp.	 self performCustomSelector: aSelector with: #setUp.	 runner timedBenchmarkExecution: aSelector] ensure: [		self performCustomSelector: aSelector with: #tearDown.		self tearDown.		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34083500!runOnly: aSymbol	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34083643!selectedBenchmarks	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34083750!runner	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34083833!runner: aRunner	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 34084045!defaultProblemSize	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 34084169!defaultRunner	^ self onCog: [SMarkCogRunner]	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34084319!isAbstractClass	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.	 Actually this class is supposed to be abstract, but well, inheritance..."		^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34084586!run	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34084706!run: nIterations	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 34084886!onCog: cogSpecificBlock else: general	^ (Smalltalk vm isRunningCogit)		ifTrue:  [cogSpecificBlock value]		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 34085120!profile: aSelector	^ self profileRunner 		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 34085303!profile: aSelector iterations: nIterations	^ self profileRunner 		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 34085534!profileAll	^ self profileRunner 		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 34085689!profileRunner	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34086112!currentMillis	"hack to make it work under most Smalltalkses and Pinocchio"	"STEFAN: had to take this out, since my images do not support pragmas	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34086441!reset	startTime := 0.	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34086572!start	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 34086701!stop	| elapsedInThisPeriod current |	current := self currentMillis.		elapsedInThisPeriod := Time milliseconds: current since: startTime.		elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 34086996!initialize	super initialize.	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34087136!name	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34087240!name: aString	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34087364!totalTime	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34087599!new: aName	| timer |		timer := super new.	timer name: aName.		^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 34088012!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 34088549!transportersForFileOutMenu	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 34089196!execute: aSelector withProcesses: numberOfProcesses withTimer: timer	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.	 It will start the processes and wait for their completion."		| processes |	processes			:= Array new: numberOfProcesses.	runningProcessesMtx := Semaphore forMutualExclusion.	completionSignal		:= Semaphore new.	runningProcesses := numberOfProcesses.		"First initialize the processes"	1 to: numberOfProcesses do: [ :procNum |		| proc |		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.		proc priority: Processor highestPriority.		proc name: (self class name, '-',  procNum asString).		processes at: procNum put: proc.		"On: procNum"	].		"Now, execute the benchmark and do the timing now"	timer start.	1 to: numberOfProcesses do: [ :procNum |		(processes at: procNum) resume.	].	completionSignal wait.	timer stop.	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 34090297!executorCompleted	runningProcessesMtx critical: [		runningProcesses := runningProcesses - 1.		(runningProcesses == 0) ifTrue: [			completionSignal signal.		]	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34090570!innerIterations	"The number of inner iterations the benchmark is executed inside a processes"	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34090794!innerIterations: anInteger	"The number of inner iterations the benchmark is executed inside a processes"	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 34091040!processes	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 34091173!processes: anInteger	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 34091320!timedBenchmarkExecution: aSelector	"Will do a timed execution of the benchmark and return the result timer"	| timer |	timers := Dictionary new.	timer := self createTimer: 'total'.		self execute: aSelector withProcesses: numProcesses withTimer: timer.		self recordResults: timer for: aSelector.		^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34091743!initialize	super initialize.	numProcesses			:= self class defaultNumberOfProcesses.	numInnerIterations	:= self class defaultNumberOfInnerIterations.! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34091992!reportConfiguration: aStream	super reportConfiguration: aStream.	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 34092353!defaultNumberOfInnerIterations	"The number of iterations of the inner loop	 in which the benchmark is executed."	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34092961!benchmarkSelector: aSelector	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34093126!innerIterations: anInt	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34093282!runner: aRunner	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34093421!suite: aSuite	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 34093559!run	1 to: numInnerIterations do: [:i |		suite perform: benchmarkSelector.].		runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 34093911!createFor: aSelector for: numIterations with: aRunner and: aSuite	| o |	o := self new.	o runner: aRunner.	o suite: aSuite.	o innerIterations: numIterations.	o benchmarkSelector: aSelector.	^ ([ o run ] newProcess)! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 34094541!standardDeviation: results withAverage: average	| variance |	variance := 0.0 .	results do: [:item|		variance:=variance+(((item total)-average) squared) ].		variance:=variance / results size .		^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 2/7/2014 15:18' prior: 34094855!writeResult: result inFile: fileName	| reportFile |	reportFile := FileStream forceNewFileNamed: fileName .	reportFile		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';		crlf .	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |		min := (smarkResults at: 1) total .		max := (smarkResults at: 1) total .		avg := 0.0 .		smarkResults do: [:smarkResult|			min := (smarkResult total) min: min .			max := (smarkResult total) max: max .			avg := avg + (smarkResult total) . ] .		avg:= avg / (smarkResults size) .		stdev:= self standardDeviation: smarkResults withAverage: avg .		reportFile			nextPutAll: benchmark;			nextPutAll: ';';			nextPutAll: (avg asFloat asString);			nextPutAll: ';';						nextPutAll: (min asFloat asString);			nextPutAll: ';';						nextPutAll: (max asFloat asString);			nextPutAll: ';';			nextPutAll: (stdev asFloat asString);			crlf .  	].	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStar	instanceVariableNames: 'openList closedList graph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStar	instanceVariableNames: 'openList closedList graph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!!CPBAStar methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 11:30'!initialize	openList := OrderedCollection new .	closedList := Set new .	graph := nil .! !!CPBAStar methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 15:05'!reset	self openList removeAll .	self closedList removeAll .! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!closedList	"Answer the value of closedList"	^ closedList! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!closedList: anObject	"Set the value of closedList"	closedList := anObject! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!graph	"Answer the value of graph"	^ graph! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!graph: anObject	"Set the value of graph"	graph := anObject! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!openList	"Answer the value of openList"	^ openList! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!openList: anObject	"Set the value of openList"	openList := anObject! !!CPBAStar methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 14:50'!draw	| form node |	form := Form extent: self graph nodes last x @ self graph nodes last y.	form floodFill: Color black at: 1@1.	node := self graph target.	[ node ] whileNotNil: [		form colorAt: (node x @ node) y put: Color white.		node := node predecessor.	].	^form.! !!CPBAStar methodsFor: 'as yet unclassified' stamp: 'MP 2/7/2014 11:59'!expandNode: node	(node neighbours) do: [:neighbour|		(self closedList includes: neighbour)			ifFalse: [				| costs |				costs := (node costsFromStart) + (node costsToNode: neighbour) .				((self openList includes: neighbour) and: (costs >= neighbour costsFromStart))					ifFalse: [						neighbour predecessor: node .						neighbour costsFromStart: costs.						(self openList includes: neighbour) ifFalse: [							self openList add: neighbour.]]]].! !!CPBAStar methodsFor: 'as yet unclassified' stamp: 'MP 2/7/2014 11:35'!findPath	| foundPath break |	foundPath := nil .	break := false .	self openList add: graph start .	[(break == false) and: ((self openList isEmpty) not)]		whileTrue: [			| currentNode |			currentNode := self nearestNode .			self openList remove: currentNode .			(currentNode == self graph target)				ifTrue: [					break:=true.					foundPath:=currentNode.]				ifFalse: [					self closedList add: currentNode .					self expandNode: currentNode .				].				] .		^ foundPath.! !!CPBAStar methodsFor: 'as yet unclassified' stamp: 'MP 2/7/2014 11:20'!nearestNode	"gets the node with the minimal costs to the target"	| min |	min := self openList first.	self openList		do: [:node | (node estimatedCostsToTarget: self graph target)					< (min estimatedCostsToTarget: self graph target)				ifTrue: [min := node]].	^ min! !SMarkSuite subclass: #CPBAStarBenchmark	instanceVariableNames: 'graph1 graph2 astar'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!SMarkSuite subclass: #CPBAStarBenchmark	instanceVariableNames: 'graph1 graph2 astar'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!!CPBAStarBenchmark methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 15:11'!benchAStar	5 timesRepeat: [		astar 			graph: graph1;			findPath;			reset .		astar			graph: graph2;			findPath;			reset .].! !!CPBAStarBenchmark methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 15:09'!setUp	astar := CPBAStar new .	graph1 := CPBAStarGraph testGraph .	graph2 := CPBAStarGraph testGraph2 .! !!CPBAStarBenchmark methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 15:04'!tearDown	astar := nil .	graph1 := nil .	graph2 := nil .! !Object subclass: #CPBAStarGraph	instanceVariableNames: 'nodes start target width'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStarGraph	instanceVariableNames: 'nodes start target width'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!!CPBAStarGraph methodsFor: 'accessing' stamp: 'BS 2/7/2014 14:03'!nodeAt: aPoint	| index |	index := (aPoint y - 1) * width + aPoint x.	^self nodes at: index. ! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!nodes	"Answer the value of nodes"	^ nodes! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!nodes: anObject	"Set the value of nodes"	nodes := anObject! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!start	"Answer the value of start"	^ start! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!start: anObject	"Set the value of start"	start := anObject! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!target	"Answer the value of target"	^ target! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!target: anObject	"Set the value of target"	target := anObject! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'BS 2/7/2014 13:30'!width	"Answer the value of width"	^ width! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'BS 2/7/2014 13:30'!width: anObject	"Set the value of width"	width := anObject! !!CPBAStarGraph methodsFor: 'initialize-release' stamp: 'BS 2/7/2014 13:29'!initialize	nodes := OrderedCollection new.	width := 0.	start := nil .	target := nil .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBAStarGraph class	instanceVariableNames: ''!!CPBAStarGraph class methodsFor: 'instance creation' stamp: 'BS 2/7/2014 14:02'!fromString: aString	| tokens maze |	tokens := (aString findTokens: Character cr) collect: [:line| (line findTokens: ',') collect: [:t| t asInteger]].		maze := self new.	maze width: tokens first size.		tokens withIndexDo: [:line :y| line withIndexDo: [:token :x| | node |			node := (CPBAStarNode x: x y: y).			maze nodes add: node.			token == 1 ifTrue:[				((y > 1) and: [((tokens at: y-1) at: x) == 1]) ifTrue: [|other|					other := maze nodeAt: (x @ (y-1)).					other neighbours add: node.					node neighbours add: other.				].				((x > 1) and: [((tokens at: y) at: x-1) == 1]) ifTrue: [|other|					other := maze nodeAt: ((x-1) @ y).					other neighbours add: node.					node neighbours add: other.				].			]		]	].		^maze.	! !!CPBAStarGraph class methodsFor: 'instance creation' stamp: 'BS 2/7/2014 14:31'!testGraph	| maze |	maze := self fromString:'1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,1,1,1,2,1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,2,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,1,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,1,1,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,2,2,1,2,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,1,1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,2,1,2,2,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,1,1,1,2,2,1,2,2,2,1,2,1,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,2,2,1,1,1,2,2,1,2,2,2,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,2,1,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,2,2,1,1,1,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,1,1,1,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,'.	maze start: maze nodes first.	maze target: maze nodes last.		^maze.! !!CPBAStarGraph class methodsFor: 'instance creation' stamp: 'BS 2/7/2014 14:32'!testGraph2	| maze |	maze := self fromString:'1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,2,2,1,2,1,2,1,2,2,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,1,2,1,1,1,2,2,1,1,1,2,2,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,1,2,2,1,1,1,2,1,1,1,1,2,2,1,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,2,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,1,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,2,1,1,2,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,2,2,1,2,1,2,1,2,2,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,1,1,2,1,1,1,2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,2,2,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,2,1,1,1,1,2,2,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,2,1,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,1,2,1,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,2,1,1,2,1,2,2,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,2,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,1,2,1,1,2,1,1,2,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,1,2,1,1,1,2,2,1,1,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,1,2,1,1,1,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,1,2,2,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,1,2,1,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,2,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,2,1,2,1,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,1,2,2,1,1,1,1,1,2,2,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,2,1,2,1,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,2,2,1,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,2,2,1,1,1,1,2,2,2,1,1,2,1,1,2,1,2,2,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,2,1,1,1,2,2,2,1,1,1,1,1,2,2,1,1,1,1,2,1,1,1,1,2,2,1,1,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,2,2,1,1,1,1,2,1,1,2,1,1,2,1,1,2,2,1,2,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,2,2,1,1,1,2,1,1,2,1,1,2,1,1,1,2,1,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,2,1,1,1,2,1,1,2,1,1,2,1,1,1,2,2,1,1,2,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,2,2,1,1,2,2,1,2,2,1,2,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,1,2,2,2,1,1,1,2,2,1,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1,2,2,2,2,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,2,2,1,1,1,2,2,1,2,2,1,1,2,1,1,2,1,1,1,1,1,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,2,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,2,1,1,1,1,1,2,2,1,1,1,2,1,1,1,2,1,1,2,1,1,2,2,1,2,2,2,2,2,2,2,2,1,1,2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,2,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,1,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,1,2,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,1,2,2,1,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,2,2,1,1,2,2,2,1,2,2,2,2,2,2,2,2,1,1,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,1,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,1,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,1,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,1,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,2,2,2,2,1,2,2,2,1,1,1,2,2,2,2,1,1,2,2,2,1,2,2,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,1,1,2,2,1,1,2,2,2,2,1,1,1,2,2,1,1,2,2,2,2,1,2,2,2,2,2,1,1,2,1,1,2,2,2,1,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,1,1,2,1,1,1,1,2,2,2,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1,2,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,'.	maze start: maze nodes first.	maze target: maze nodes last.		^maze.! !Object subclass: #CPBAStarNode	instanceVariableNames: 'neighbours x y costsFromStart predecessor distanceMetric'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStarNode	instanceVariableNames: 'neighbours x y costsFromStart predecessor distanceMetric'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!!CPBAStarNode methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 12:52'!initialize	neighbours := Set new .	x := 0 .	y := 0 .	costsFromStart := 0 .	predecessor := nil .	distanceMetric := #manhattan .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:19'!addNeighbour: neighbour	self neighbours add: neighbour .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:05'!costsFromStart	"Answer the value of costsFromStart"	^ costsFromStart! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:05'!costsFromStart: anObject	"Set the value of costsFromStart"	costsFromStart := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:58'!costsToNode: node	(self distanceMetric = #euclidian)		ifTrue: [			^ self euclideanDistanceTo: node . ]		ifFalse: [			(self distanceMetric = #manhattan)				ifTrue: [					^ self manhattanDistanceTo: node .]				ifFalse: [					^ 1 .				]		].! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:52'!distanceMetric	"Answer the value of distanceMetric"	^ distanceMetric! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:52'!distanceMetric: anObject	"Set the value of distanceMetric"	distanceMetric := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:18'!estimatedCostsToTarget: target	^ self costsFromStart + (self costsToNode: target) .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:55'!euclideanDistanceTo: node	| dX dY |	dX := node x - self x .	dY := node y - self y .	^ (dX*dX) + (dY*dY) .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:54'!manhattanDistanceTo: node	^ ((node x - self x) abs) + ((node y - self y) abs) .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:05'!neighbours	"Answer the value of neighbours"	^ neighbours! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:05'!neighbours: anObject	"Set the value of neighbours"	neighbours := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:20'!predecessor	"Answer the value of predecessor"	^ predecessor! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:20'!predecessor: anObject	"Set the value of predecessor"	predecessor := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:10'!x	"Answer the value of x"	^ x! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:10'!x: anObject	"Set the value of x"	x := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:10'!y	"Answer the value of y"	^ y! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:10'!y: anObject	"Set the value of y"	y := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBAStarNode class	instanceVariableNames: ''!!CPBAStarNode class methodsFor: 'instance creation' stamp: 'MP 2/7/2014 10:12'!x: x y: y	| instance |	instance := self new .	instance		x: x;		y: y .	^ instance .! !| writer runner |runner := (CPBAStarBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/AStar.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 34122275!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34123115!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 34123265!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34123468!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34123684!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34124293!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34124786!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34125235!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34125497!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34125692!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34126125!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34126325!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34126447!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 34126584!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 34126873!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 34127347!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 34128240!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34128669!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34128814!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34129254!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34129858!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34130041!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 34130224!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 34130352!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 34131075!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34131475!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34131868!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34132191!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 34132602!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34132755!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 34133979!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 34134115!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 34134446!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 34135248!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34135643!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34135794!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 34135947!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 34136440!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34136947!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34137051!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34137192!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34137303!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34137513!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 34137792!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34137920!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34138032!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34138294!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34138512!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34138628!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34138752!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34138906!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 34139447!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34139905!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34139999!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34140111!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34140199!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34140329!suite
	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34140411!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34140527!total
	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34140608!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 34141140!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 34141433!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 34141840!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 34141995!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34142257!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34142378!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 34142521!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 34142641!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34142948!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34143219!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 34143462!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 34143614!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 34143726!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 34143834!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 34144001!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 34144363!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 34144789!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34145243!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34145372!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 34145713!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 34145998!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 34146127!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 34146255!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34146384!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34146535!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 34147151!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 34147330!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 34148069!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 34148926!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34149371!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34149528!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 34149846!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 34150434!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 34150725!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 34150878!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 34151502!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 34152009!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 34152306!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34152488!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34152666!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34152829!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34153097!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 34153379!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 34153656!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 34154278!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 34154797!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 34155041!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 34155312!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 34155644!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 34156875!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 34157270!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 34158057!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 34158292!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 34158784!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 34159186!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34159738!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34160006!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34160175!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34160442!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34160599!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34160758!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 34161060!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 34161317!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34161532!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34162045!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34162370!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34162513!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34162620!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34162703!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 34162915!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 34163039!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34163189!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34163456!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34163576!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 34163756!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 34163990!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 34164173!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 34164404!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 34164559!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34164982!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34165311!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34165442!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 34165571!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 34165866!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34166006!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34166110!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34166234!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34166469!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 34166882!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 34167419!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 34168066!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 34169167!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34169440!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34169664!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 34169910!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 34170043!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 34170190!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34170613!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34170862!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 34171223!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34171831!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34171996!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34172152!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34172291!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 34172429!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 34172781!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 34173411!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15' prior: 34173724!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-Chameneos'!Object subclass: #CPBChameneos	instanceVariableNames: 'meetings color semaphore waitingForPair'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!Object subclass: #CPBChameneos
	instanceVariableNames: 'meetings color semaphore waitingForPair'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Chameneos'!!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:52'!color
	^ color! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:52'!color: aColor
	color := aColor.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:52'!fade
	color := #faded.
	waitingForPair signal.
	semaphore signal! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:53'!fork: aMeetingPlace
	^ [ self run: aMeetingPlace ] fork! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:58'!initialize
	meetings := 0.
      waitingForPair := Semaphore new.
      semaphore := Semaphore new.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:54'!meetings
	^meetings! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:54'!met: other
	| newColor |
	meetings := meetings + 1.
	color == #red ifTrue: [
		newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].
      color == #yellow ifTrue: [
      	newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].
      color == #blue ifTrue: [
      	newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].
      color := newColor.
      waitingForPair signal! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:55'!run: meetingPlace
    [ color == #faded ] whileFalse: [
        meetingPlace reachedBy: self.
        waitingForPair wait ]! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:55'!wait
	semaphore wait! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBChameneos class
	instanceVariableNames: ''!!CPBChameneos class methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:56'!color: c
	^ self new
		initialize;
		color: c! !SMarkSuite subclass: #CPBChameneosBenchmark	instanceVariableNames: 'c1 c2 c3 c4 mp nMeetings'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!SMarkSuite subclass: #CPBChameneosBenchmark
	instanceVariableNames: 'c1 c2 c3 c4 mp nMeetings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Chameneos'!!CPBChameneosBenchmark methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:36'!benchChameneos
	c1 fork: mp.
	c2 fork: mp.
	c3 fork: mp.
	c4 fork: mp.
	
	c1 wait.
	c2 wait.
	c3 wait.
	c4 wait.
	
	^ c1 meetings + c2 meetings + c3 meetings + c4 meetings! !!CPBChameneosBenchmark methodsFor: 'initialize-release' stamp: 'MP 1/27/2014 14:36'!setUp
	nMeetings := 500000.
	c1 := CPBChameneos color: #blue.
	c2 := CPBChameneos color: #red.
	c3 := CPBChameneos color: #yellow.
	c4 := CPBChameneos color: #blue.
	mp := CPBMeetingPlace forMeetings: nMeetings.! !Object subclass: #CPBMeetingPlace	instanceVariableNames: 'mutex first total max'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!Object subclass: #CPBMeetingPlace
	instanceVariableNames: 'mutex first total max'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Chameneos'!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:59'!initialize
	mutex := Semaphore forMutualExclusion.
	total := 0! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:59'!max: maxMeetings
	max := maxMeetings! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:59'!organizeMeetingWith: second
	total >= max
		ifTrue: [
			first fade.
			second fade]
		ifFalse: [
			first met: second color.
			second met: first color ].
	total := total + 1! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:59'!reachedBy: chameleon
	mutex critical: [
        first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBMeetingPlace class
	instanceVariableNames: ''!!CPBMeetingPlace class methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:59'!forMeetings: maxMeetings
	^super new
		initialize;
		max: maxMeetings;
		yourself! !| writer runner |		
runner := (CPBChameneosBenchmark) run: 5 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'. 
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/Chameneos.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 34211027!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34211867!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 34212017!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34212220!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34212436!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34213045!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34213538!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34213987!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34214249!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34214444!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34214877!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34215077!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34215199!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 34215336!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 34215625!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 34216099!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 34216992!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34217421!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34217566!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34218006!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34218610!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34218793!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 34218976!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 34219104!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 34219827!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34220227!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34220620!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34220943!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 34221354!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34221507!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 34222731!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 34222867!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 34223198!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 34224000!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34224395!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34224546!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 34224699!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 34225192!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34225699!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34225803!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34225944!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34226055!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34226265!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 34226544!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34226672!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34226784!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34227046!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34227264!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34227380!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34227504!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34227658!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 34228199!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34228657!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34228751!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34228863!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34228951!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34229081!suite
	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34229163!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34229279!total
	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34229360!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 34229892!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 34230185!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 34230592!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 34230747!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34231009!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34231130!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 34231273!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 34231393!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34231700!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34231971!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 34232214!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 34232366!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 34232478!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 34232586!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 34232753!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 34233115!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 34233541!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34233995!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34234124!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 34234465!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 34234750!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 34234879!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 34235007!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34235136!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34235287!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 34235903!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 34236082!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 34236821!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 34237678!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34238123!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34238280!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 34238598!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 34239186!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 34239477!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 34239630!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 34240254!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 34240761!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 34241058!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34241240!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34241418!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34241581!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34241849!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 34242131!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 34242408!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 34243030!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 34243549!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 34243793!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 34244064!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 34244396!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 34245627!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 34246022!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 34246809!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 34247044!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 34247536!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 34247938!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34248490!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34248758!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34248927!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34249194!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34249351!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34249510!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 34249812!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 34250069!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34250284!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34250797!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34251122!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34251265!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34251372!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34251455!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 34251667!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 34251791!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34251941!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34252208!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34252328!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 34252508!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 34252742!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 34252925!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 34253156!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 34253311!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34253734!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34254063!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34254194!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 34254323!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 34254618!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34254758!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34254862!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34254986!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34255221!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 34255634!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 34256171!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 34256818!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 34257919!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34258192!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34258416!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 34258662!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 34258795!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 34258942!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34259365!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34259614!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 34259975!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34260583!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34260748!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34260904!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34261043!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 34261181!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 34261533!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 34262163!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15' prior: 34262477!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBAbstractConstraint	instanceVariableNames: 'strength'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBAbstractConstraint
	instanceVariableNames: 'strength'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBAbstractConstraint commentStamp: '<historical>' prior: 0!I am an abstract class representing a system-maintainable relationship (or
"constraint") between a set of variables. I supply a strength instance
variable; concrete subclasses provide a means of storing the constrained
variables and other information required to represent a constraint.

Instance variables:
        strength                        the strength of this constraint <Strength>
!!CPBAbstractConstraint methodsFor: 'accessing'!strength
        "Answer my strength."

        ^strength! !!CPBAbstractConstraint methodsFor: 'accessing' stamp: 'HW 1/25/2014 17:23'!strength: strengthSymbol
        "Set my strength."

        strength := CPBStrength of: strengthSymbol.! !!CPBAbstractConstraint methodsFor: 'queries'!isInput
        "Normal constraints are not input constraints. An input constraint is
         one that depends on external state, such as the mouse, the keyboard,
         a clock, or some arbitrary piece of imperative code."

        ^false! !!CPBAbstractConstraint methodsFor: 'queries'!isSatisfied
        "Answer true if this constraint is satisfied in the current solution."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'add/remove' stamp: 'HW 1/25/2014 17:22'!addConstraint
        "Activate this constraint and attempt to satisfy it."

        self addToGraph.
        CPBPlanner current incrementalAdd: self.! !!CPBAbstractConstraint methodsFor: 'add/remove'!addToGraph
        "Add myself to the constraint graph."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'add/remove' stamp: 'HW 1/25/2014 17:22'!destroyConstraint
        "Deactivate this constraint, remove it from the constraint graph,
         possibly causing other constraints to be satisfied, and destroy it."

        (self isSatisfied) ifTrue: [CPBPlanner current incrementalRemove: self].
        self removeFromGraph.
        self release.! !!CPBAbstractConstraint methodsFor: 'add/remove'!removeFromGraph
        "Remove myself from the constraint graph."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!chooseMethod: mark
        "Decide if I can be satisfied and record that decision. The output of
         the choosen method must not have the given mark and must have a
         walkabout strength less than that of this constraint."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!execute
        "Enforce this constraint. Assume that it is satisfied."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!inputsDo: aBlock
        "Assume that I am satisfied. Evaluate the given block on all my current
         input variables."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!inputsKnown: mark
        "Assume that I am satisfied. Answer true if all my current inputs are
         known. A variable is known if either a) it is 'stay' (i.e. it is a
         constant at plan execution time), b) it has the given mark (indicating
         that it has been computed by a constraint appearing earlier in the
         plan), or c) it is not determined by any constraint."

        self inputsDo:
                [: v |
                 ((v mark = mark) or: [(v stay) or: [v determinedBy == nil]]) ifFalse:
                        [^false]].
        ^true! !!CPBAbstractConstraint methodsFor: 'planning'!markUnsatisfied
        "Record the fact that I am unsatisfied."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!output
        "Answer my current output variable. Raise an error if I am not
         currently satisfied."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!recalculate
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
         the value for the current output of this constraint. Assume this
         constraint is satisfied."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning' stamp: 'HW 1/25/2014 17:23'!satisfy: mark
        "Attempt to find a way to enforce this (still unsatisfied) constraint.
         If successful, record the solution, perhaps modifying the current
         dataflow graph. Answer the constraint that this constraint overrides,
         if there is one, or nil, if there isn't."

        | overridden out |
        self chooseMethod: mark.
        (self isSatisfied)
                ifTrue:                        "constraint can be satisfied"
                        ["mark inputs to allow cycle detection in addPropagate"
                         self inputsDo: [: in | in mark: mark].
                         out := self output.
                         overridden := out determinedBy.
                         (overridden == nil) ifFalse: [overridden markUnsatisfied].
                         out determinedBy: self.
                         (CPBPlanner current addPropagate: self mark: mark) ifFalse:
                                [self notify:
                                        ('Cycle encountered adding:\ ',
                                         self printString,
                                         '\Constraint removed.') withCRs.
                                 ^nil].
                         out mark: mark]
                ifFalse:                        "constraint cannot be satisfied"
                        [overridden := nil.
                         (strength sameAs: (CPBStrength required)) ifTrue:
                                [self notify: 'Failed to satisfy a required constraint']].
        ^overridden! !!CPBAbstractConstraint methodsFor: 'printing'!longPrintOn: aStream

        | bindings |
        aStream nextPut: $(.
        self shortPrintOn: aStream.
        aStream space; nextPutAll: self strength printString.
        (self isSatisfied)
                ifTrue:
                        [aStream cr; space; space; space.
                         self inputsDo:
                                [: in | aStream nextPutAll: 'v', in asOop printString, ' '].
                        aStream nextPutAll: '-> '.
                        aStream nextPutAll: 'v', self output asOop printString]
                ifFalse:
                        [aStream space; nextPutAll: 'UNSATISFIED'].
        aStream nextPut: $); cr.! !!CPBAbstractConstraint methodsFor: 'printing'!printOn: aStream

        self shortPrintOn: aStream! !!CPBAbstractConstraint methodsFor: 'printing'!shortPrintOn: aStream

        aStream nextPutAll: self class name, '(', self asOop printString, ')'.! !CPBAbstractConstraint subclass: #CPBBinaryConstraint	instanceVariableNames: 'v1 v2 direction'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBAbstractConstraint subclass: #CPBBinaryConstraint
	instanceVariableNames: 'v1 v2 direction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBBinaryConstraint commentStamp: '<historical>' prior: 0!I am an abstract superclass for constraints having two possible output
variables.

Instance variables:
        v1, v2                possible output variables <Variable>
        direction                one of:
                                        #forward (v2 is output)
                                        #backward (        v1 is output)
                                        nil (not satisfied)!!CPBBinaryConstraint methodsFor: 'initialize-release' stamp: 'HW 1/25/2014 17:23'!var: variable1 var: variable2 strength: strengthSymbol
        "Initialize myself with the given variables and strength."

        strength := CPBStrength of: strengthSymbol.
        v1 := variable1.
        v2 := variable2.
        direction := nil.
        self addConstraint.! !!CPBBinaryConstraint methodsFor: 'queries'!isSatisfied
        "Answer true if this constraint is satisfied in the current solution."

        ^direction notNil! !!CPBBinaryConstraint methodsFor: 'add/remove'!addToGraph
        "Add myself to the constraint graph."

        v1 addConstraint: self.
        v2 addConstraint: self.
        direction := nil.! !!CPBBinaryConstraint methodsFor: 'add/remove'!removeFromGraph
        "Remove myself from the constraint graph."

        (v1 == nil) ifFalse: [v1 removeConstraint: self].
        (v2 == nil) ifFalse: [v2 removeConstraint: self].
        direction := nil.! !!CPBBinaryConstraint methodsFor: 'planning'!chooseMethod: mark
        "Decide if I can be satisfied and which way I should flow based on
         the relative strength of the variables I relate, and record that
         decision."

        (v1 mark == mark) ifTrue:                "forward or nothing"
                [((v2 mark ~= mark) and: [strength stronger: v2 walkStrength])
                        ifTrue: [^direction := #forward]
                        ifFalse: [^direction := nil]].

        (v2 mark == mark) ifTrue:                "backward or nothing"
                [((v1 mark ~= mark) and: [strength stronger: v1 walkStrength])
                        ifTrue: [^direction := #backward]
                        ifFalse: [^direction := nil]].

        "if we get here, neither variable is marked, so we have choice"
        (v1 walkStrength weaker: v2 walkStrength)
                ifTrue:
                        [(strength stronger: v1 walkStrength)
                                ifTrue: [^direction := #backward]
                                ifFalse: [^direction := nil]]
                ifFalse:
                        [(strength stronger: v2 walkStrength)
                                ifTrue: [^direction := #forward]
                                ifFalse: [^direction := nil]].! !!CPBBinaryConstraint methodsFor: 'planning'!execute
        "Enforce this constraint. Assume that it is satisfied."

        self subclassResponsibility! !!CPBBinaryConstraint methodsFor: 'planning'!inputsDo: aBlock
        "Evaluate the given block on my current input variable."

        (direction == #forward)
                ifTrue: [aBlock value: v1]
                ifFalse: [aBlock value: v2].! !!CPBBinaryConstraint methodsFor: 'planning'!markUnsatisfied
        "Record the fact that I am unsatisfied."

        direction := nil.! !!CPBBinaryConstraint methodsFor: 'planning'!output
        "Answer my current output variable."

        (direction == #forward)
                ifTrue: [^v2]
                ifFalse: [^v1]! !!CPBBinaryConstraint methodsFor: 'planning'!recalculate
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
the value for the current output of this constraint. Assume this
         constraint is satisfied."

        | in out |
        (direction == #forward)
                ifTrue: [in := v1. out := v2]
                ifFalse: [in := v2. out := v1].
        out walkStrength: (strength weakest: in walkStrength).
        out stay: (in stay).
        (out stay) ifTrue: [self execute].                "stay optimization"! !SMarkSuite subclass: #CPBDeltaBlueBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!SMarkSuite subclass: #CPBDeltaBlueBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBDeltaBlueBenchmark methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:26'!benchDeltaBlue
	CPBPlanner standardBenchmark.! !CPBBinaryConstraint subclass: #CPBEqualityConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBBinaryConstraint subclass: #CPBEqualityConstraint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBEqualityConstraint commentStamp: '<historical>' prior: 0!I constrain two variables to have the same value: "v1 = v2".!!CPBEqualityConstraint methodsFor: 'execution'!execute
        "Enforce this constraint. Assume that it is satisfied."

        (direction == #forward)
                ifTrue: [v2 value: v1 value]
                ifFalse: [v1 value: v2 value].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBEqualityConstraint class
	instanceVariableNames: ''!!CPBEqualityConstraint class methodsFor: 'instance creation'!var: variable1 var: variable2 strength: strengthSymbol
        "Install a constraint with the given strength equating the given
         variables."

        ^(self new) var: variable1 var: variable2 strength: strengthSymbol! !OrderedCollection variableSubclass: #CPBPlan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!OrderedCollection variableSubclass: #CPBPlan
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBPlan commentStamp: '<historical>' prior: 0!A Plan is an ordered list of constraints to be executed in sequence to
resatisfy all currently satisfiable constraints in the face of one or more
changing inputs.!!CPBPlan methodsFor: 'execution'!execute
        "Execute my constraints in order."

        self do: [: c | c execute].! !Object subclass: #CPBPlanner	instanceVariableNames: 'currentMark'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBPlanner
	instanceVariableNames: 'currentMark'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBPlanner commentStamp: '<historical>' prior: 0!This benchmark is an implementation of the DeltaBlue Constraint Solver
described in `The DeltaBlue Algorithm: An Incremental Constraint
Hierarchy Solver', by Bjorn N. Freeman-Benson and John Maloney,
Communications of the ACM, January 1990 (also as University of
Washington TR 89-08-06).

To run the benchmark, execute the expression `Planner standardBenchmark'.!!CPBPlanner methodsFor: 'initialize'!initialize
        "Planner initialize"

        currentMark := 1.! !!CPBPlanner methodsFor: 'add/remove'!incrementalAdd: c
        "Attempt to satisfy the given constraint and, if successful,
         incrementally update the dataflow graph.

         Details: If satifying the constraint is successful, it may override a
         weaker constraint on its output. The algorithm attempts to resatisfy
         that constraint using some other method. This process is repeated
         until either a) it reaches a variable that was not previously
         determined by any constraint or b) it reaches a constraint that
         is too weak to be satisfied using any of its methods. The variables
         of constraints that have been processed are marked with a unique mark
         value so that we know where we've been. This allows the algorithm to
         avoid getting into an infinite loop even if the constraint graph has
         an inadvertent cycle."

        | mark overridden |
        mark := self newMark.
        overridden := c satisfy: mark.
        [overridden == nil] whileFalse:
                [overridden := overridden satisfy: mark].! !!CPBPlanner methodsFor: 'add/remove'!incrementalRemove: c
        "Entry point for retracting a constraint. Remove the given constraint,
         which should be satisfied, and incrementally update the dataflow
         graph.

         Details: Retracting the given constraint may allow some currently
         unsatisfiable downstream constraint be satisfied. We thus collect a
         list of unsatisfied downstream constraints and attempt to satisfy
         each one in turn. This list is sorted by constraint strength,
         strongest first, as a heuristic for avoiding unnecessarily adding
         and then overriding weak constraints."

        | out unsatisfied |
        out := c output.
        c markUnsatisfied.
        c removeFromGraph.
        unsatisfied := self removePropagateFrom: out.
        unsatisfied do: [: u | self incrementalAdd: u].! !!CPBPlanner methodsFor: 'planning/value propagation'!extractPlanFromConstraints: constraints
        "Extract a plan for resatisfaction starting from the outputs of the
         given constraints, usually a set of input constraints."

        | sources |
        sources := OrderedCollection new.
        constraints do:
                [: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]].
        ^self makePlan: sources! !!CPBPlanner methodsFor: 'planning/value propagation'!extractPlanFromVariables: variables
        "Extract a plan from the dataflow graph having the given variables. It
         is assumed that the given set of variables is complete, or at least
         that it contains all the input variables."

        | sources |
        sources := OrderedCollection new.
        variables do:
                [: v |
                 (v constraints) do:
                        [: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]]].
        ^self makePlan: sources! !!CPBPlanner methodsFor: 'planning/value propagation'!makePlan: sources
        "Extract a plan for resatisfaction starting from the given satisfied
         source constraints, usually a set of input constraints. This method
         assumes that stay optimization is desired; the plan will contain only
         constraints whose output variables are not stay. Constraints that do
         no computation, such as stay and edit constraints, are not included
         in the plan.

         Details: The outputs of a constraint are marked when it is added to
         the plan under construction. A constraint may be appended to the plan
         when all its input variables are known. A variable is known if either
         a) the variable is marked (indicating that has been computed by a
         constraint appearing earlier in the plan), b) the variable is 'stay'
         (i.e. it is a constant at plan execution time), or c) the variable
         is not determined by any constraint. The last provision is for past
         states of history variables, which are not stay but which are also
         not computed by any constraint."

        | mark plan todo c |
        mark := self newMark.
        plan := CPBPlan new.
        todo := sources.
        [todo isEmpty] whileFalse:
                [c := todo removeFirst.
                 ((c output mark ~= mark) and:                "not in plan already and..."
                 [c inputsKnown: mark]) ifTrue:        "eligible for inclusion"
                        [plan addLast: c.
                         c output mark: mark.
                         self addConstraintsConsuming: c output to: todo]].
        ^plan! !!CPBPlanner methodsFor: 'planning/value propagation'!propagateFrom: v
        "The given variable has changed. Propagate new values downstream."

        | todo c |
        todo := OrderedCollection new.
        self addConstraintsConsuming: v to: todo.
        [todo isEmpty] whileFalse:
                [c := todo removeFirst.
                 c execute.
                 self addConstraintsConsuming: c output to: todo].! !!CPBPlanner methodsFor: 'private'!addConstraintsConsuming: v to: aCollection

        | determiningC |
        determiningC := v determinedBy.
        v constraints do:
                [: c |
                 ((c == determiningC) or: [c isSatisfied not]) ifFalse:
                        [aCollection add: c]].! !!CPBPlanner methodsFor: 'private'!addPropagate: c mark: mark
        "Recompute the walkabout strengths and stay flags of all variables
         downstream of the given constraint and recompute the actual values
         of all variables whose stay flag is true. If a cycle is detected,
         remove the given constraint and answer false. Otherwise, answer true.

         Details: Cycles are detected when a marked variable is encountered
         downstream of the given constraint. The sender is assumed to have
         marked the inputs of the given constraint with the given mark. Thus,
         encountering a marked node downstream of the output constraint means
         that there is a path from the constraint's output to one of its
         inputs."

        | todo d |
        todo := OrderedCollection with: c.
        [todo isEmpty] whileFalse:
                [d := todo removeFirst.
                 (d output mark = mark) ifTrue:
                        [self incrementalRemove: c.
                         ^false].
                 d recalculate.
                 self addConstraintsConsuming: d output to: todo].
        ^true! !!CPBPlanner methodsFor: 'private' stamp: 'HW 1/25/2014 17:21'!changeVar: aVariable newValue: newValue

        | editConstraint plan |
        editConstraint := CPBEditConstraint var: aVariable strength: #preferred.
        plan := self extractPlanFromConstraints: (Array with: editConstraint).
        10 timesRepeat: [
                aVariable value: newValue.
                plan execute].
        editConstraint destroyConstraint.! !!CPBPlanner methodsFor: 'private'!constraintsConsuming: v do: aBlock

        | determiningC |
        determiningC := v determinedBy.
        v constraints do:
                [: c |
                 ((c == determiningC) or: [c isSatisfied not]) ifFalse:
                        [aBlock value: c]].! !!CPBPlanner methodsFor: 'private'!newMark
        "Select a previously unused mark value.

         Details: We just keep incrementing. If necessary, the counter will
         turn into a LargePositiveInteger. In that case, it will be a bit
         slower to compute the next mark but the algorithms will all behave
         correctly. We reserve the value '0' to mean 'unmarked'. Thus, this
         generator starts at '1' and will never produce '0' as a mark value."

        ^currentMark := currentMark + 1! !!CPBPlanner methodsFor: 'private' stamp: 'HW 1/25/2014 17:24'!removePropagateFrom: out
        "Update the walkabout strengths and stay flags of all variables
         downstream of the given constraint. Answer a collection of unsatisfied
         constraints sorted in order of decreasing strength."

        | unsatisfied todo v nextC |
        unsatisfied := SortedCollection sortBlock:
                [: c1 : c2 | c1 strength stronger: c2 strength].
        out determinedBy: nil.
        out walkStrength: CPBStrength absoluteWeakest.
        out stay: true.
        todo := OrderedCollection with: out.
        [todo isEmpty] whileFalse:
                [v := todo removeFirst.
                 v constraints do:
                         [: c | (c isSatisfied) ifFalse: [unsatisfied add: c]].
                 self constraintsConsuming: v do:
                        [: c |
                         c recalculate.
                         todo add: c output]].
        ^unsatisfied! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBPlanner class	instanceVariableNames: 'currentPlanner'!CPBPlanner class
	instanceVariableNames: 'currentPlanner'!!CPBPlanner class methodsFor: 'instance creation'!new
        ^currentPlanner := super new initialize! !!CPBPlanner class methodsFor: 'benchmarks' stamp: 'HW 1/25/2014 17:24'!chainTest: n
        "Do chain-of-equality-constraints performance tests."

        | vars editConstraint plan planner |
        planner := CPBPlanner new.
        vars := (1 to: n+1) collect: [ :i | CPBVariable new].

        "thread a chain of equality constraints through the variables"
        1 to: n do:
                [ :i || v1 v2 |
                 v1 := vars at: i.
                 v2 := vars at: i + 1.
                 CPBEqualityConstraint var: v1 var: v2 strength: #required].

        CPBStayConstraint var: vars last strength: #strongDefault.
        editConstraint := CPBEditConstraint var: (vars first) strength: #preferred.
        plan := planner extractPlanFromConstraints: (Array with: editConstraint).
        1 to: 100 do: [ :v |
                vars first value: v.
                plan execute.
                vars last value ~= v ifTrue: [self error: 'Chain test failed!!']].
        editConstraint destroyConstraint! !!CPBPlanner class methodsFor: 'benchmarks' stamp: 'HW 1/25/2014 17:25'!projectionTest: n
        "This test constructs a two sets of variables related to each other by
         a simple linear transformation (scale and offset)."

        | scale offset src dst planner dests |
        planner := CPBPlanner new.
        dests := OrderedCollection new.
        scale := CPBVariable value: 10.
        offset := CPBVariable value: 1000.
        1 to: n do:
                [ :i |
                src := CPBVariable value: i.
                dst := CPBVariable value: i.
                dests add: dst.
                CPBStayConstraint var: src strength: #default.
                CPBScaleConstraint var: src var: scale var: offset var: dst strength: #required].

        planner changeVar: src newValue: 17.
        dst value ~= 1170 ifTrue: [self error: 'Projection test 1 failed!!'].

        planner changeVar: dst newValue: 1050.
        src value ~= 5 ifTrue: [self error: 'Projection test 2 failed!!'].

        planner changeVar: scale newValue: 5.
        1 to: n - 1 do: [ :i |
                (dests at: i) value ~= (i*5 + 1000)
                        ifTrue: [self error: 'Projection test 3 failed!!']].

        planner changeVar: offset newValue: 2000.
        1 to: n - 1 do: [ :i |
                (dests at: i) value ~= (i*5 + 2000)
                        ifTrue: [self error: 'Projection test 4 failed!!']].! !!CPBPlanner class methodsFor: 'benchmarks'!report: string times: count run: aBlock
        "Report the time required to execute the given block."

        | time |
        time := Time millisecondsToRun: [count timesRepeat: aBlock].
        Transcript show: string, ' ', (time // count) printString, ' milliseconds'; cr.! !!CPBPlanner class methodsFor: 'benchmarks'!standardBenchmark
        "This the combined benchmark."
        "Planner standardBenchmark"

        self report: 'Chain and projection tests' times: 100 run: [
                self chainTest: 100.
                self projectionTest: 100
        ]! !!CPBPlanner class methodsFor: 'accessing'!current
        ^currentPlanner! !CPBBinaryConstraint subclass: #CPBScaleConstraint	instanceVariableNames: 'scale offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBBinaryConstraint subclass: #CPBScaleConstraint
	instanceVariableNames: 'scale offset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBScaleConstraint commentStamp: '<historical>' prior: 0!I relate two variables by the linear scaling relationship:
"v2 = (v1 * scale) + offset". Either v1 or v2 may be changed to maintain this
relationship but the scale factor and offset are considered read-only.

Instance variables:
        scale                scale factor input variable <Variable>
        offset                offset input variable <Variable>!!CPBScaleConstraint methodsFor: 'initialize-release' stamp: 'HW 1/25/2014 17:24'!src: srcVar scale: scaleVar offset: offsetVar dst: dstVar strength: strengthSymbol
        "Initialize myself with the given variables and strength."

        strength := CPBStrength of: strengthSymbol.
        v1 := srcVar.
        v2 := dstVar.
        scale := scaleVar.
        offset := offsetVar.
        direction := nil.
        self addConstraint.! !!CPBScaleConstraint methodsFor: 'add/remove'!addToGraph
        "Add myself to the constraint graph."

        v1 addConstraint: self.
        v2 addConstraint: self.
        scale addConstraint: self.
        offset addConstraint: self.
        direction := nil.! !!CPBScaleConstraint methodsFor: 'add/remove'!removeFromGraph
        "Remove myself from the constraint graph."

        (v1 == nil) ifFalse: [v1 removeConstraint: self].
        (v2 == nil) ifFalse: [v2 removeConstraint: self].
        (scale == nil) ifFalse: [scale removeConstraint: self].
        (offset == nil) ifFalse: [offset removeConstraint: self].
        direction := nil.! !!CPBScaleConstraint methodsFor: 'planning'!execute
        "Enforce this constraint. Assume that it is satisfied."

        (direction == #forward)
                ifTrue: [v2 value: (v1 value * scale value) + offset value]
                ifFalse: [v1 value: (v2 value - offset value) // scale value].! !!CPBScaleConstraint methodsFor: 'planning'!inputsDo: aBlock
        "Evaluate the given block on my current input variable."

        (direction == #forward)
                ifTrue: [aBlock value: v1; value: scale; value: offset]
                ifFalse: [aBlock value: v2; value: scale; value: offset].! !!CPBScaleConstraint methodsFor: 'planning'!recalculate
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
         the value for the current output of this constraint. Assume this
         constraint is satisfied."

        | in out |
        (direction == #forward)
                ifTrue: [in := v1. out := v2]
                ifFalse: [out := v1. in := v2].
        out walkStrength: (strength weakest: in walkStrength).
        out stay: ((in stay) and: [(scale stay) and: [offset stay]]).
        (out stay) ifTrue: [self execute].                "stay optimization"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBScaleConstraint class
	instanceVariableNames: ''!!CPBScaleConstraint class methodsFor: 'instance creation'!var: src var: scale var: offset var: dst strength: strengthSymbol
        "Install a scale constraint with the given strength on the given
         variables."

        ^(self new) src: src scale: scale offset: offset dst: dst strength: strengthSymbol! !Object subclass: #CPBStrength	instanceVariableNames: 'symbolicValue arithmeticValue'	classVariableNames: 'AbsoluteStrongest AbsoluteWeakest Required StrengthConstants StrengthTable'	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBStrength
	instanceVariableNames: 'symbolicValue arithmeticValue'
	classVariableNames: 'AbsoluteStrongest AbsoluteWeakest Required StrengthConstants StrengthTable'
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBStrength commentStamp: '<historical>' prior: 0!Strengths are used to measure the relative importance of constraints. The
hierarchy of available strengths is determined by the class variable
StrengthTable (see my class initialization method). Because Strengths are
invariant, references to Strength instances are shared (i.e. all references to
"Strength of: #required" point to a single, shared instance). New strengths may
be inserted in the strength hierarchy without disrupting current constraints.

Instance variables:
        symbolicValue                symbolic strength name (e.g. #required) <Symbol>
        arithmeticValue                index of the constraint in the hierarchy, used for comparisons <Number>
!!CPBStrength methodsFor: 'comparing'!sameAs: aStrength
        "Answer true if I am the same strength as the given Strength."

        ^arithmeticValue = aStrength arithmeticValue! !!CPBStrength methodsFor: 'comparing'!stronger: aStrength
        "Answer true if I am stronger than the given Strength."

        ^arithmeticValue < aStrength arithmeticValue! !!CPBStrength methodsFor: 'comparing'!weaker: aStrength
        "Answer true if I am weaker than the given Strength."

        ^arithmeticValue > aStrength arithmeticValue! !!CPBStrength methodsFor: 'max/min'!strongest: aStrength
        "Answer the stronger of myself and aStrength."

        (aStrength stronger: self)
                ifTrue: [^aStrength]
                ifFalse: [^self].! !!CPBStrength methodsFor: 'max/min'!weakest: aStrength
        "Answer the weaker of myself and aStrength."

        (aStrength weaker: self)
                ifTrue: [^aStrength]
                ifFalse: [^self].! !!CPBStrength methodsFor: 'printing'!printOn: aStream
        "Append a string which represents my strength onto aStream."

        aStream nextPutAll: '%', symbolicValue, '%'.! !!CPBStrength methodsFor: 'private'!arithmeticValue
        "Answer my arithmetic value. Used for comparisons. Note that
         STRONGER constraints have SMALLER arithmetic values."

        ^arithmeticValue! !!CPBStrength methodsFor: 'private'!initializeWith: symVal
        "Record my symbolic value and reset my arithmetic value."

        symbolicValue := symVal.
        arithmeticValue := StrengthTable at: symbolicValue.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBStrength class
	instanceVariableNames: ''!!CPBStrength class methodsFor: 'class initialization'!initialize
        "Initialize the symbolic strength table. Fix the internally caches
         values of all existing instances."
        "Strength initialize"

        StrengthTable := Dictionary new.
        StrengthTable at: #absoluteStrongest put: -10000.
        StrengthTable at: #required put: -800.
        StrengthTable at: #strongPreferred put: -600.
        StrengthTable at: #preferred put: -400.
        StrengthTable at: #strongDefault put: -200.
        StrengthTable at: #default put: 0.
        StrengthTable at: #weakDefault put: 500.
        StrengthTable at: #absoluteWeakest put: 10000.

        StrengthConstants := Dictionary new.
        StrengthTable keys do:
                [: strengthSymbol |
                        StrengthConstants
                                at: strengthSymbol
                                put: ((super new) initializeWith: strengthSymbol)].

        AbsoluteStrongest := CPBStrength of: #absoluteStrongest.
        AbsoluteWeakest := CPBStrength of: #absoluteWeakest.
        Required := CPBStrength of: #required.! !!CPBStrength class methodsFor: 'instance creation'!of: aSymbol
        "Answer an instance with the specified strength."

        ^StrengthConstants at: aSymbol! !!CPBStrength class methodsFor: 'constants'!absoluteStrongest

        ^AbsoluteStrongest! !!CPBStrength class methodsFor: 'constants'!absoluteWeakest

        ^AbsoluteWeakest! !!CPBStrength class methodsFor: 'constants'!required

        ^Required! !CPBAbstractConstraint subclass: #CPBUnaryConstraint	instanceVariableNames: 'output satisfied'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBAbstractConstraint subclass: #CPBUnaryConstraint
	instanceVariableNames: 'output satisfied'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBUnaryConstraint commentStamp: '<historical>' prior: 0!I am an abstract superclass for constraints having a single possible output
variable.

Instance variables:
        output                possible output variable <Variable>
        satisfied                true if I am currently satisfied <Boolean>!!CPBUnaryConstraint methodsFor: 'initialize-release' stamp: 'HW 1/25/2014 17:24'!var: aVariable strength: strengthSymbol
        "Initialize myself with the given variable and strength."

        strength := CPBStrength of: strengthSymbol.
        output := aVariable.
        satisfied := false.
        self addConstraint.! !!CPBUnaryConstraint methodsFor: 'queries'!isSatisfied
        "Answer true if this constraint is satisfied in the current solution."

        ^satisfied! !!CPBUnaryConstraint methodsFor: 'add/remove'!addToGraph
        "Add myself to the constraint graph."

        output addConstraint: self.
        satisfied := false.! !!CPBUnaryConstraint methodsFor: 'add/remove'!removeFromGraph
        "Remove myself from the constraint graph."

        (output == nil) ifFalse: [output removeConstraint: self].
        satisfied := false.! !!CPBUnaryConstraint methodsFor: 'planning'!chooseMethod: mark
        "Decide if I can be satisfied and record that decision."

        satisfied :=
                (output mark ~= mark) and:
                [strength stronger: output walkStrength].! !!CPBUnaryConstraint methodsFor: 'planning'!execute
        "Enforce this constraint. Assume that it is satisfied."

        self subclassResponsibility! !!CPBUnaryConstraint methodsFor: 'planning'!inputsDo: aBlock
        "I have no input variables."! !!CPBUnaryConstraint methodsFor: 'planning'!markUnsatisfied
        "Record the fact that I am unsatisfied."

        satisfied := false.! !!CPBUnaryConstraint methodsFor: 'planning'!output
        "Answer my current output variable."

        ^output! !!CPBUnaryConstraint methodsFor: 'planning'!recalculate
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
         the value for the current output of this constraint. Assume this
         constraint is satisfied."

        output walkStrength: strength.
        output stay: (self isInput not).
        (output stay) ifTrue: [self execute].        "stay optimization"! !CPBUnaryConstraint subclass: #CPBEditConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBUnaryConstraint subclass: #CPBEditConstraint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBEditConstraint commentStamp: '<historical>' prior: 0!I am a unary input constraint used to mark a variable that the client
wishes to change.!!CPBEditConstraint methodsFor: 'queries'!isInput
        "I indicate that a variable is to be changed by imperative code."

        ^true! !!CPBEditConstraint methodsFor: 'execution'!execute
        "Edit constraints do nothing."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBEditConstraint class
	instanceVariableNames: ''!!CPBEditConstraint class methodsFor: 'instance creation'!var: aVariable strength: strengthSymbol
        "Install an edit constraint with the given strength on the given
         variable."

        ^(self new) var: aVariable strength: strengthSymbol! !CPBUnaryConstraint subclass: #CPBStayConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBUnaryConstraint subclass: #CPBStayConstraint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBStayConstraint commentStamp: '<historical>' prior: 0!I mark variables that should, with some level of preference, stay the same.
I have one method with zero inputs and one output, which does nothing. Planners
may exploit the fact that, if I am satisfied, my output will not change during
plan execution. This is called "stay optimization."!!CPBStayConstraint methodsFor: 'execution'!execute
        "Stay constraints do nothing."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBStayConstraint class
	instanceVariableNames: ''!!CPBStayConstraint class methodsFor: 'instance creation'!var: aVariable strength: strengthSymbol
        "Install a stay constraint with the given strength on the given variable."

        ^(self new) var: aVariable strength: strengthSymbol! !Object subclass: #CPBVariable	instanceVariableNames: 'value constraints determinedBy walkStrength stay mark'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBVariable
	instanceVariableNames: 'value constraints determinedBy walkStrength stay mark'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBVariable commentStamp: '<historical>' prior: 0!I represent a constrained variable. In addition to my value, I maintain the
structure of the constraint graph, the current dataflow graph, and various
parameters of interest to the DeltaBlue incremental constraint solver.

Instance variables:
        value                        my value; changed by constraints, read by client <Object>
        constraints                normal constraints that reference me <Array of Constraint>
        determinedBy        the constraint that currently determines
                                        my value (or nil if there isn't one) <Constraint>
        walkStrength                my walkabout strength <Strength>
        stay                        true if I am a planning-time constant <Boolean>
        mark                        used by the planner to mark constraints <Number>!!CPBVariable methodsFor: 'name' stamp: 'stephaneducasse 2/4/2006 20:39'!name: aName type: aType
	"Set the variable's name and type as indicated"

	variableName := aName.
	variableType := aType! !!CPBVariable methodsFor: 'name' stamp: 'sw 12/11/2000 14:07'!variableName
	"Answer the variable name of the receiver"

	^ variableName! !!CPBVariable methodsFor: 'type' stamp: 'sw 12/11/2000 14:06'!variableType
	"Anser the variable type of the receiver"

	^ variableType! !!CPBVariable methodsFor: 'type' stamp: 'stephaneducasse 2/4/2006 20:39'!variableType: aType
	"Set the receiver's variable type as requested"

	variableType := aType! !!CPBVariable methodsFor: 'value' stamp: 'sw 12/11/2000 14:06'!defaultValue
	"Answer the default value to be supplied to the receiver"

	^ defaultValue! !!CPBVariable methodsFor: 'value' stamp: 'stephaneducasse 2/4/2006 20:39'!sample
	"The closest we can come to an object for our type"

	| ty clsName |
	self defaultValue ifNotNil: [^ self defaultValue].
	ty := self variableType.
	"How translate a type like #player into a class?"
	clsName := ty asString.
	clsName at: 1 put: (clsName first asUppercase).
	clsName := clsName asSymbol.
	(Smalltalk includesKey: clsName) ifFalse: [self error: 'What type is this?'. ^ 5].
	^ (Smalltalk at: clsName) initializedInstance! !!CPBVariable methodsFor: 'initialize-release' stamp: 'HW 1/25/2014 17:24'!initialize

        value := 0.
        constraints := OrderedCollection new: 2.
        determinedBy := nil.
        walkStrength := CPBStrength absoluteWeakest.
        stay := true.
        mark := 0.! !!CPBVariable methodsFor: 'access'!addConstraint: aConstraint
        "Add the given constraint to the set of all constraints that refer
         to me."

        constraints add: aConstraint.! !!CPBVariable methodsFor: 'access'!constraints
        "Answer the set of constraints that refer to me."

        ^constraints! !!CPBVariable methodsFor: 'access'!determinedBy
        "Answer the constraint that determines my value in the current
         dataflow."

        ^determinedBy! !!CPBVariable methodsFor: 'access'!determinedBy: aConstraint
        "Record that the given constraint determines my value in the current
         data flow."

        determinedBy := aConstraint.! !!CPBVariable methodsFor: 'access'!mark
        "Answer my mark value."

        ^mark! !!CPBVariable methodsFor: 'access'!mark: markValue
        "Set my mark value."

        mark := markValue.! !!CPBVariable methodsFor: 'access'!removeConstraint: c
        "Remove all traces of c from this variable."

        constraints remove: c ifAbsent: [].
        (determinedBy == c) ifTrue: [determinedBy := nil].! !!CPBVariable methodsFor: 'access'!stay
        "Answer my stay flag."

        ^stay! !!CPBVariable methodsFor: 'access'!stay: aBoolean
        "Set my stay flag."

        stay := aBoolean! !!CPBVariable methodsFor: 'access'!value
        "Answer my value."

        ^value! !!CPBVariable methodsFor: 'access'!value: anObject
        "Set my value."

        value := anObject.! !!CPBVariable methodsFor: 'access'!walkStrength
        "Answer my walkabout strength in the current dataflow."

        ^walkStrength! !!CPBVariable methodsFor: 'access'!walkStrength: aStrength
        "Set my walkabout strength in the current dataflow."

        walkStrength := aStrength.! !!CPBVariable methodsFor: 'changes'!setValue: aValue
        "Attempt to assign the given value to me using a strength of
         #preferred."

        self setValue: aValue strength: #preferred.! !!CPBVariable methodsFor: 'changes' stamp: 'HW 1/25/2014 17:22'!setValue: aValue strength: strengthSymbol
        "Attempt to assign the given value to me using the given strength."

        | editConstraint |
        editConstraint := CPBEditConstraint var: self strength: strengthSymbol.
        (editConstraint isSatisfied) ifTrue:
                [self value: aValue.
                 CPBPlanner propagateFrom: self].
        editConstraint destroyConstraint.! !!CPBVariable methodsFor: 'printing'!longPrintOn: aStream

        self shortPrintOn: aStream.
        aStream nextPutAll: ' Constraints: '.
        (constraints isEmpty)
                ifTrue: [aStream cr; tab; nextPutAll: 'none']
                ifFalse:
                        [constraints do:
                                [: c | aStream cr; tab. c shortPrintOn: aStream]].
        (determinedBy isNil) ifFalse:
                [aStream cr; nextPutAll: ' Determined by: '.
                 aStream cr; tab. determinedBy shortPrintOn: aStream].
        aStream cr.! !!CPBVariable methodsFor: 'printing'!printOn: aStream

        self shortPrintOn: aStream! !!CPBVariable methodsFor: 'printing'!shortPrintOn: aStream

        aStream nextPutAll: 'V(', self asOop printString, ', '.
        aStream nextPutAll: walkStrength printString, ', '.
        (stay isNil) ifFalse:
                [aStream nextPutAll: (stay ifTrue: ['stay, '] ifFalse: ['changing, '])].
        aStream nextPutAll: value printString.
        aStream nextPutAll: ')'.
        aStream cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBVariable class
	instanceVariableNames: ''!!CPBVariable class methodsFor: 'instance creation'!new

        ^super new initialize! !!CPBVariable class methodsFor: 'instance creation'!value: aValue

        ^(super new) initialize; value: aValue! !CPBStrength initialize!| writer runner |
runner := (CPBDeltaBlueBenchmark) run: 5 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'. 
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/DeltaBlue.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 34268677!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34269527!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 34269678!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34269885!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34270105!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34270727!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34271225!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34271681!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34271946!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34272142!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34272590!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34272792!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34272915!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 34273053!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 34273347!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 34273829!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 34274742!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34275175!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34275321!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34275765!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34276381!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34276566!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 34276751!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 34276880!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 34277608!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34278015!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34278420!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34278751!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 34279171!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34279325!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 34280579!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 34280716!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 34281056!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 34281879!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34282286!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34282438!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 34282592!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 34283093!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34283610!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34283715!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34283857!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34283970!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34284183!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 34284465!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34284594!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34284707!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34284979!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34285199!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34285316!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34285441!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34285596!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 34286147!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34286611!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34286706!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34286819!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34286908!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34287039!suite
	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34287122!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34287239!total
	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34287321!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 34287858!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 34288160!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 34288577!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 34288736!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34289002!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34289124!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 34289268!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 34289389!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34289703!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34289976!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 34290221!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 34290375!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 34290488!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 34290597!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 34290766!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 34291138!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 34291573!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34292041!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34292171!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 34292517!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 34292805!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 34292935!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 34293064!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34293194!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34293346!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 34293973!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 34294154!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 34294910!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 34295774!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34296234!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34296393!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 34296714!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 34297310!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 34297602!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 34297757!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 34298393!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 34298908!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 34299205!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34299389!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34299569!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34299734!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34300008!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 34300292!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 34300576!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 34301210!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 34301737!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 34301986!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 34302264!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 34302605!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 34303873!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 34304278!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 34305085!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 34305322!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 34305820!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 34306227!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34306787!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34307059!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34307230!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34307502!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34307661!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34307822!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 34308128!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 34308388!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34308605!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34309133!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34309465!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34309609!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34309717!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34309801!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 34310015!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 34310140!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34310292!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34310563!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34310684!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 34310865!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 34311102!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 34311287!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 34311520!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 34311677!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34312105!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34312438!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34312571!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 34312701!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 34313002!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34313144!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34313249!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34313374!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34313611!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 34314034!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 34314576!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 34315229!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 34316357!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34316636!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34316862!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 34317110!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 34317244!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 34317392!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34317826!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34318079!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 34318443!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34319058!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34319224!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34319381!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34319521!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 34319660!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 34320017!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 34320658!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15' prior: 34320980!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-NBody'!Object subclass: #CPBBody	instanceVariableNames: 'x y z vx vy vz mass'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-NBody'!Object subclass: #CPBBody
	instanceVariableNames: 'x y z vx vy vz mass'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-NBody'!!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:12'!addMomentumTo: anArray
   anArray at: 1 put: (anArray at: 1) + (vx * mass).
   anArray at: 2 put: (anArray at: 2) + (vy * mass).
   anArray at: 3 put: (anArray at: 3) + (vz * mass).
   ^anArray! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:13'!and: aBody velocityAfter: dt        
   | dx dy dz distance mag |
   dx := x - aBody x.
   dy := y - aBody y.
   dz := z - aBody z.
   
   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.
   mag := dt / (distance * distance * distance).

   self decreaseVelocity: dx y: dy z: dz m: aBody mass * mag.   
   aBody increaseVelocity: dx y: dy z: dz m: mass * mag! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:13'!decreaseVelocity: dx y: dy z: dz m: m
   vx := vx - (dx * m).
   vy := vy - (dy * m).
   vz := vz - (dz * m)! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!increaseVelocity: dx y: dy z: dz m: m
   vx := vx + (dx * m).
   vy := vy + (dy * m).
   vz := vz + (dz * m)! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!kineticEnergy
   ^0.5d0 * mass * ((vx * vx) + (vy * vy) + (vz * vz))! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!offsetMomentum: anArray 
   | m |
   m := self class solarMass.
   vx := (anArray at: 1) negated / m.
   vy := (anArray at: 2) negated / m.
   vz := (anArray at: 3) negated / m! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!positionAfter: dt
   x := x + (dt * vx).
   y := y + (dt * vy).
   z := z + (dt * vz)! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!potentialEnergy: aBody
   | dx dy dz distance |
   dx := x - aBody x.
   dy := y - aBody y.
   dz := z - aBody z.

   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.
   ^mass * aBody mass / distance! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:09'!mass
	^ mass! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:10'!x
	^ x! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:11'!x: d1 y: d2 z: d3 vx: d4 vy: d5 vz: d6 mass: d7
   x := d1.
   y := d2. 
   z := d3. 
   vx := d4.
   vy := d5.
   vz := d6.
   mass := d7! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:10'!y
	^ y! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:10'!z
	^ z! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBBody class
	instanceVariableNames: ''!!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:15'!daysPerYear
   ^365.24d0! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:15'!jupiter
   ^self new
      x: 4.84143144246472090d0
      y: -1.16032004402742839d0
      z: -1.03622044471123109d-1
      vx: 1.66007664274403694d-3 * self daysPerYear
      vy: 7.69901118419740425d-3 * self daysPerYear
      vz: -6.90460016972063023d-5 * self daysPerYear
      mass: 9.54791938424326609d-4 * self solarMass! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:15'!neptune
   ^self new
      x: 1.53796971148509165d1
      y: -2.59193146099879641d1
      z: 1.79258772950371181d-1
      vx: 2.68067772490389322d-3 * self daysPerYear
      vy: 1.62824170038242295d-3 * self daysPerYear
      vz: -9.51592254519715870d-5 * self daysPerYear
      mass: 5.15138902046611451d-5 * self solarMass! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:15'!pi
   ^3.141592653589793d0! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:16'!saturn
   ^self new
      x: 8.34336671824457987d0
      y: 4.12479856412430479d0
      z: -4.03523417114321381d-1
      vx: -2.76742510726862411d-3 * self daysPerYear
      vy: 4.99852801234917238d-3 * self daysPerYear
      vz: 2.30417297573763929d-5 * self daysPerYear
      mass: 2.85885980666130812d-4 * self solarMass! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:16'!solarMass
   ^4.0d0 * self pi * self pi! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:16'!sun
   ^self new
      x: 0.0d0
      y: 0.0d0
      z: 0.0d0
      vx: 0.0d0
      vy: 0.0d0
      vz: 0.0d0
      mass: self solarMass! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:16'!uranus
   ^self new
      x: 1.28943695621391310d1
      y: -1.51111514016986312d1
      z: -2.23307578892655734d-1
      vx: 2.96460137564761618d-3 * self daysPerYear
      vy: 2.37847173959480950d-3 * self daysPerYear
      vz: -2.96589568540237556d-5 * self daysPerYear
      mass: 4.36624404335156298d-5 * self solarMass! !SMarkSuite subclass: #CPBNBodyBenchmark	instanceVariableNames: 'bodies'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-NBody'!SMarkSuite subclass: #CPBNBodyBenchmark
	instanceVariableNames: 'bodies'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-NBody'!!CPBNBodyBenchmark methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:18'!after: dt
   1 to: bodies size do: [:i|
      i+1 to: bodies size do: [:j|                            
         (bodies at: i) and: (bodies at: j) velocityAfter: dt].
   ].   
   bodies do: [:each| each positionAfter: dt]! !!CPBNBodyBenchmark methodsFor: 'nbody' stamp: 'MP 1/27/2014 14:22'!benchNBody
	"helper method to run the n body benchmark"
	
	self runBenchmarkFor: 10000 withStep: 0.01d0 .! !!CPBNBodyBenchmark methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:18'!energy
   | e |
   e := 0.0d0.
   1 to: bodies size do: [:i|       
      e := e + (bodies at: i) kineticEnergy.

      i+1 to: bodies size do: [:j| 
         e := e - ((bodies at: i) potentialEnergy: (bodies at: j))].
   ].
   ^e! !!CPBNBodyBenchmark methodsFor: 'nbody' stamp: 'MP 1/15/2014 14:53'!runBenchmarkFor: iterations withStep: stepSize 
	"helper method to run the n body benchmark"
	
	0 to: iterations
		do: [:i | self after: stepSize]! !!CPBNBodyBenchmark methodsFor: 'initialize-release' stamp: 'MP 1/27/2014 14:22'!setUp
   bodies := OrderedCollection new
      add: CPBBody sun; add: CPBBody jupiter; add: CPBBody saturn;
      add: CPBBody uranus; add: CPBBody neptune; yourself.

   bodies first offsetMomentum:
      (bodies inject: (Array with: 0.0d0 with: 0.0d0 with: 0.0d0)
         into: [:m :each | each addMomentumTo: m])! !| writer runner |
runner := (CPBNBodyBenchmark) run: 20 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'. 
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/NBody.st----!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 34370109!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkHarness class
	instanceVariableNames: ''!!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34370959!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00' prior: 34371110!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34371317!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34371537!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34372159!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34372657!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34373113!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34373378!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper' stamp: '' prior: 34373574!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34374022!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34374224!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults' stamp: '' prior: 34374347!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41' prior: 34374485!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking' stamp: '' prior: 34374779!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19' prior: 34375261!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 34376174!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReBenchHarness class
	instanceVariableNames: ''!!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59' prior: 34376607!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34376753!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20' prior: 34377197!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34377813!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper' stamp: '' prior: 34377998!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults' stamp: '' prior: 34378183!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06' prior: 34378312!defaultRunner
	^ SMarkWeakScalingRunner! !Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser
	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38' prior: 34379040!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34379447!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34379852!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34380183!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26' prior: 34380603!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34380757!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing' stamp: '' prior: 34382011!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29' prior: 34382148!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27' prior: 34382488!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17' prior: 34383311!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34383718!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: '' prior: 34383870!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31' prior: 34384024!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter
	instanceVariableNames: 'runner stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 34384525!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34385042!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34385147!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34385289!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting' stamp: '' prior: 34385402!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34385615!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization' stamp: '' prior: 34385897!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34386026!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34386139!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing' stamp: '' prior: 34386411!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkReporter class
	instanceVariableNames: ''!!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34386631!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults' stamp: '' prior: 34386748!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34386873!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting' stamp: '' prior: 34387028!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult
	instanceVariableNames: 'time benchName suite criteria'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 34387579!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34388043!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34388138!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34388251!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34388340!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34388471!suite
	^ suite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34388554!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34388671!total
	^ time! !!SMarkResult methodsFor: 'accessing' stamp: '' prior: 34388753!total: aTime
	time := aTime! !Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner
	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28' prior: 34389290!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01' prior: 34389592!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05' prior: 34390009!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10' prior: 34390168!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34390434!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20' prior: 34390556!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08' prior: 34390700!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44' prior: 34390821!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34391135!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08' prior: 34391408!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46' prior: 34391653!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41' prior: 34391807!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45' prior: 34391920!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14' prior: 34392029!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50' prior: 34392198!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42' prior: 34392570!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30' prior: 34393005!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13' prior: 34393473!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34393603!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47' prior: 34393949!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkRunner class
	instanceVariableNames: ''!!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43' prior: 34394237!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09' prior: 34394367!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56' prior: 34394496!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34394626!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51' prior: 34394778!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner
	instanceVariableNames: 'targetTime innerLoopIterations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59' prior: 34395405!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27' prior: 34395586!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49' prior: 34396342!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31' prior: 34397206!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34397666!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18' prior: 34397825!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkAutosizeRunner class
	instanceVariableNames: ''!!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17' prior: 34398146!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner
	instanceVariableNames: 'warmingUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 34398742!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51' prior: 34399034!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26' prior: 34399189!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57' prior: 34399825!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 34400340!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24' prior: 34400637!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34400821!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28' prior: 34401001!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34401166!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34' prior: 34401440!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkProfileRunner class
	instanceVariableNames: ''!!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19' prior: 34401724!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31' prior: 34402008!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59' prior: 34402642!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49' prior: 34403169!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46' prior: 34403418!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08' prior: 34403696!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03' prior: 34404037!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08' prior: 34405305!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41' prior: 34405710!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02' prior: 34406517!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40' prior: 34406754!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23' prior: 34407252!benchmarkHeader: aName
	^ self! !Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite
	instanceVariableNames: 'runner selectedBenchmarks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 34407659!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34408219!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper' stamp: '' prior: 34408491!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34408662!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34408934!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running' stamp: '' prior: 34409093!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34409254!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17' prior: 34409560!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31' prior: 34409820!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34410037!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34410565!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34410897!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking' stamp: '' prior: 34411041!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34411149!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing' stamp: '' prior: 34411233!runner: aRunner
	runner := aRunner.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkSuite class
	instanceVariableNames: ''!!SMarkSuite class methodsFor: 'defaults' stamp: '' prior: 34411447!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43' prior: 34411572!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34411724!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34411995!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking' stamp: '' prior: 34412116!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20' prior: 34412297!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22' prior: 34412534!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30' prior: 34412719!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21' prior: 34412952!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17' prior: 34413109!profileRunner
	^ SMarkProfileRunner! !Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer
	instanceVariableNames: 'startTime elapsedTime name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34413537!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34413870!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24' prior: 34414003!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25' prior: 34414133!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32' prior: 34414434!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34414576!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34414681!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34414806!totalTime
	^elapsedTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTimer class
	instanceVariableNames: ''!!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54' prior: 34415043!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 34415466!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkTransporter class
	instanceVariableNames: ''!!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46' prior: 34416008!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner
	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13' prior: 34416661!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17' prior: 34417789!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34418068!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34418294!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54' prior: 34418542!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53' prior: 34418676!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31' prior: 34418824!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43' prior: 34419258!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50' prior: 34419511!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunner class
	instanceVariableNames: ''!!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42' prior: 34419875!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor
	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SMark'!!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34420490!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20' prior: 34420656!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34420813!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21' prior: 34420953!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22' prior: 34421092!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMarkWeakScalingRunnerExecutor class
	instanceVariableNames: ''!!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33' prior: 34421449!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks'!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34' prior: 34422090!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 17:15' prior: 34422412!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !SystemOrganization addCategory: #'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBDeviceTask	instanceVariableNames: 'scheduler packet1'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBDeviceTask
	instanceVariableNames: 'scheduler packet1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Richards'!!CPBDeviceTask methodsFor: 'execution' stamp: 'MP 1/15/2014 17:12'!run: packet
	| return |
	(packet == nil) ifTrue: [
		(self packet1 == nil) ifTrue: [
			return := (self scheduler) suspendCurrent .
		] ifFalse: [
			| v |
			v := self packet1 .
			self packet1: nil .
			return := (self scheduler) queue: v .
		] .
	] ifFalse: [
		self packet1: packet .
		return := (self scheduler) holdCurrent .
	] .
	^ return .! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:06'!packet1
	"Answer the value of packet1"

	^ packet1! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:06'!packet1: anObject
	"Set the value of packet1"

	packet1 := anObject! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:59'!scheduler
	"Answer the value of scheduler"

	^ scheduler! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:59'!scheduler: anObject
	"Set the value of scheduler"

	scheduler := anObject! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:12'!toString
	^ 'DeviceTask' .! !!CPBDeviceTask methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 17:06'!initialize
	self
		scheduler: nil;
		packet1: nil .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBDeviceTask class
	instanceVariableNames: ''!!CPBDeviceTask class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 17:06'!createWithScheduler: scheduler
	| instance |
	instance := self new .
	instance scheduler: scheduler .
	^ instance .! !Object subclass: #CPBHandlerTask	instanceVariableNames: 'scheduler v1 v2'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBHandlerTask
	instanceVariableNames: 'scheduler v1 v2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Richards'!!CPBHandlerTask methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 17:28'!initialize
	self 
		scheduler: nil;
		v1: nil;
		v2: nil .! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!scheduler
	"Answer the value of scheduler"

	^ scheduler! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!scheduler: anObject
	"Set the value of scheduler"

	scheduler := anObject! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:30'!toString
	^ 'HandlerTask'! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!v1
	"Answer the value of v1"

	^ v1! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!v1: anObject
	"Set the value of v1"

	v1 := anObject! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!v2
	"Answer the value of v2"

	^ v2! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!v2: anObject
	"Set the value of v2"

	v2 := anObject! !!CPBHandlerTask methodsFor: 'execution' stamp: 'MP 1/15/2014 18:54'!run: packet
	| return |
	(packet ~~ nil) ifTrue: [
		(packet kind == (CPBPacket kindWork)) ifTrue: [
			self v1: (packet addTo: (self v1)) .
		] ifFalse: [
			self v2: (packet addTo: (self v2)).
		] .
	] .
	
	(self v1 ~~ nil) ifTrue: [
		| count v |
		count := (self v1) a1 .
		(count < (CPBPacket dataSize)) ifTrue: [
			(self v2 ~~ nil) ifTrue: [
				v := self v2 .
				self v2: ((self v2) link) .
				v a1: (((self v1) a2) at: (count + 1)) .
				(self v1) a1: (count + 1) .
				return := (self scheduler) queue: v .
			] ifFalse: [
				return := (self scheduler) suspendCurrent .
			] .
		] ifFalse: [
			v := self v1 .
      		self v1: ((self v1) link) .
		      return := (self scheduler) queue: v .
		] .
	] ifFalse: [
		return := (self scheduler) suspendCurrent .
	] .
	^ return .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBHandlerTask class
	instanceVariableNames: ''!!CPBHandlerTask class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 17:27'!createWithScheduler: scheduler
	| instance |
	instance := self new .
	instance scheduler: scheduler .
	^ instance! !Object subclass: #CPBIdleTask	instanceVariableNames: 'scheduler seed1 count'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBIdleTask
	instanceVariableNames: 'scheduler seed1 count'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Richards'!!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!count
	"Answer the value of count"

	^ count! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!count: anObject
	"Set the value of count"

	count := anObject! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!scheduler
	"Answer the value of scheduler"

	^ scheduler! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!scheduler: anObject
	"Set the value of scheduler"

	scheduler := anObject! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!seed1
	"Answer the value of seed1"

	^ seed1! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!seed1: anObject
	"Set the value of seed1"

	seed1 := anObject! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:47'!toString
	^ 'IdleTask' .! !!CPBIdleTask methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 16:46'!initialize
	self
		scheduler: nil;
		seed1: 0;
		count: 0 .! !!CPBIdleTask methodsFor: 'execution' stamp: 'MP 1/15/2014 16:58'!run: packet
	| return |
	self count: (self count) - 1 .
	
	(self count == 0) ifTrue: [
		return := (self scheduler) holdCurrent .
	] ifFalse: [
		((self seed1 bitAnd: 1) == 0) ifTrue: [
			self seed1: (self seed1 bitShift: -1) .
			return := (self scheduler) release: (CPBScheduler idDeviceA) .
		] ifFalse: [
			self seed1: ((self seed1 bitShift: -1) bitXor: 16rD008) .
			return := (self scheduler) release: (CPBScheduler idDeviceB) .
		]
	] .
	^ return .
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBIdleTask class
	instanceVariableNames: ''!!CPBIdleTask class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 16:46'!createWithScheduler: scheduler withSeed: seed times: times
	| instance |
	instance := self new .
	instance
		scheduler: scheduler;
		seed1: seed;
		count: times .
	^ instance .! !Object subclass: #CPBPacket	instanceVariableNames: 'link id kind a1 a2'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBPacket
	instanceVariableNames: 'link id kind a1 a2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Richards'!!CPBPacket methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 17:48'!initialize
	self
		link: nil;
		id: 0;
		kind: 0;
		a1: 0;
		a2: (Array new: (CPBPacket dataSize)) .! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!a1
	"Answer the value of a1"

	^ a1! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!a1: anObject
	"Set the value of a1"

	a1 := anObject! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!a2
	"Answer the value of a2"

	^ a2! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!a2: anObject
	"Set the value of a2"

	a2 := anObject! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 18:52'!addTo: queue
	| return |
	self link: nil .
	(queue isNil) ifTrue: [
		return := self .
	] ifFalse: [
		| peek next |
		next := queue .
		[next link ~~ nil] whileTrue: [
			peek := next link .
			next := peek .
		] .
		next link: self .
		return := queue .
	] .
	^ return .! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!id
	"Answer the value of id"

	^ id! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!id: anObject
	"Set the value of id"

	id := anObject! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!kind
	"Answer the value of kind"

	^ kind! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!kind: anObject
	"Set the value of kind"

	kind := anObject! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!link
	"Answer the value of link"

	^ link! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:46'!link: anObject
	"Set the value of link"

	link := anObject! !!CPBPacket methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:54'!toString
	^ 'Packet' .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBPacket class
	instanceVariableNames: ''!!CPBPacket class methodsFor: 'class variables' stamp: 'MP 1/15/2014 17:45'!dataSize
	^ 4! !!CPBPacket class methodsFor: 'class variables' stamp: 'MP 1/15/2014 17:49'!kindDevice
	^ 0! !!CPBPacket class methodsFor: 'class variables' stamp: 'MP 1/15/2014 17:49'!kindWork
	^ 1! !!CPBPacket class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 17:54'!link: link id: id kind: kind
	| instance |
	instance := self new .
	instance
		link: link;
		id: id;
		kind: kind .
	^ instance .! !SMarkSuite subclass: #CPBRichardsBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!SMarkSuite subclass: #CPBRichardsBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Richards'!!CPBRichardsBenchmark methodsFor: 'testing' stamp: 'MP 1/27/2014 14:24'!benchRichards
	| scheduler queue |
	scheduler := CPBScheduler new .
	scheduler addIdleTask: (CPBScheduler idIdle) withPriority: 0 withQueue: nil times: (CPBRichardsBenchmark iterations) .

	queue := CPBPacket link: nil id: (CPBScheduler idWorker) kind: (CPBPacket kindWork) .
	queue := CPBPacket link: queue id: (CPBScheduler idWorker) kind: (CPBPacket kindWork) .
	scheduler addWorkerTask: (CPBScheduler idWorker) withPriority: 1000 withQueue: queue .
	
	queue := CPBPacket link: nil id: (CPBScheduler idDeviceA) kind: (CPBPacket kindDevice) .
	queue := CPBPacket link: queue id: (CPBScheduler idDeviceA) kind: (CPBPacket kindDevice) .
	queue := CPBPacket link: queue id: (CPBScheduler idDeviceA) kind: (CPBPacket kindDevice) .
	scheduler addHandlerTask: (CPBScheduler idHandlerA) withPriority: 2000 withQueue: queue .
	
	queue := CPBPacket link: nil id: (CPBScheduler idDeviceB) kind: (CPBPacket kindDevice) .
	queue := CPBPacket link: queue id: (CPBScheduler idDeviceB) kind: (CPBPacket kindDevice) .
	queue := CPBPacket link: queue id: (CPBScheduler idDeviceB) kind: (CPBPacket kindDevice) .
	scheduler addHandlerTask: (CPBScheduler idHandlerB) withPriority: 3000 withQueue: queue .	

	scheduler addDeviceTask: (CPBScheduler idDeviceA) withPriority: 4000 withQueue: nil .
	scheduler addDeviceTask: (CPBScheduler idDeviceB) withPriority: 5000 withQueue: nil .
	
	scheduler schedule .
	
	((scheduler queueCount ~~ (CPBRichardsBenchmark expectedQueueCount)) or: 
	(scheduler holdCount ~~ (CPBRichardsBenchmark expectedHoldCount))) ifTrue: [
		Transcript 
			show: 'Error during execution: queueCount= ';
			show: (scheduler queueCount);
			show: ', holdCount=';
			show: (scheduler holdCount);
			show: '.';
			cr .
	] .
! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBRichardsBenchmark class
	instanceVariableNames: ''!!CPBRichardsBenchmark class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:30'!expectedHoldCount
	^ 928! !!CPBRichardsBenchmark class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:30'!expectedQueueCount
	^ 2322! !!CPBRichardsBenchmark class methodsFor: 'class variables' stamp: 'MP 1/15/2014 20:08'!iterations
	^ 1000! !Object subclass: #CPBScheduler	instanceVariableNames: 'queueCount holdCount blocks list currentTcb currentId'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBScheduler
	instanceVariableNames: 'queueCount holdCount blocks list currentTcb currentId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Richards'!!CPBScheduler methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 15:35'!initialize
	self
		queueCount: 0;
		holdCount: 0;
		blocks: (Array new: CPBScheduler numberOfIDs);
		list: nil;
		currentTcb: nil;
		currentId: nil.! !!CPBScheduler methodsFor: 'scheduling' stamp: 'MP 1/15/2014 16:08'!holdCurrent
	self holdCount: (self holdCount) + 1 .
	(self currentTcb) markAsHeld .
	^ (self currentTcb) link! !!CPBScheduler methodsFor: 'scheduling' stamp: 'MP 1/15/2014 18:30'!queue: packet
	| t return |
	t := (self blocks) at: ((packet id) + 1) .
	(t == nil) ifTrue: [
		return := t .
	] ifFalse: [
		self queueCount: (self queueCount) + 1 .
		packet
			link: nil;
			id: (self currentId) .
		return := (t checkPriorityAdd: (self currentTcb) packet: packet) .
	] .
	^ return .! !!CPBScheduler methodsFor: 'scheduling' stamp: 'MP 1/15/2014 18:30'!release: id
	| tcb return |
	return := nil .
	tcb := (self blocks) at: (id+1) .
	(tcb == nil) ifTrue: [
		return := tcb .
	] ifFalse: [
		tcb markAsNotHeld .
		(tcb priority > (self currentTcb) priority) ifTrue: [
			return := tcb .
		] ifFalse: [
			return := self currentTcb .
		] .
	] .
	^ return! !!CPBScheduler methodsFor: 'scheduling' stamp: 'MP 1/15/2014 18:18'!schedule
	"executes the scheduler"
	self currentTcb: (self list) .
	[self currentTcb ~~ nil] whileTrue: [
		((self currentTcb) isHeldOrSuspended) ifTrue: [
			self currentTcb: ((self currentTcb) link) .
		] ifFalse: [
			self
				currentId: (self currentTcb) id;
				currentTcb: (self currentTcb) run .
		] .
	] .! !!CPBScheduler methodsFor: 'scheduling' stamp: 'MP 1/15/2014 16:09'!suspendCurrent
	(self currentTcb) markAsSuspended .
	^ (self currentTcb) .! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 18:17'!addDeviceTask: id withPriority: priority withQueue: queue
	self addTask: id withPriority: priority withQueue: queue task: (CPBDeviceTask createWithScheduler: self) .! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:26'!addHandlerTask: id withPriority: priority withQueue: queue
	self addTask: id withPriority: priority withQueue: queue task: (CPBHandlerTask createWithScheduler: self) .! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:41'!addIdleTask: id withPriority: priority withQueue: queue times: times
	self addRunningTask: id withPriority: priority withQueue: queue task: (CPBIdleTask createWithScheduler: self withSeed: 1 times: times) .! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:51'!addRunningTask: id withPriority: priority withQueue: queue task: task
	self addTask: id withPriority: priority withQueue: queue task: task .
      (self currentTcb) setRunning .! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 19:42'!addTask: id withPriority: priority withQueue: queue task: task
	self currentTcb: (CPBTaskControlBlock
		link: self list
		id: id
		priority: priority
		queue: queue
		task: task) .
	self list: (self currentTcb) .
	(self blocks) at: (id+1) put: (self currentTcb) .
		! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:13'!addWorkerTask: id withPriority: priority withQueue: queue
	self addTask: id withPriority: priority withQueue: queue task: (CPBWorkerTask createWithScheduler: self seed1: (CPBScheduler idHandlerA) seed2: 0) .! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!blocks
	"Answer the value of blocks"

	^ blocks! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!blocks: anObject
	"Set the value of blocks"

	blocks := anObject! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!currentId
	"Answer the value of currentId"

	^ currentId! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!currentId: anObject
	"Set the value of currentId"

	currentId := anObject! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!currentTcb
	"Answer the value of currentTcb"

	^ currentTcb! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!currentTcb: anObject
	"Set the value of currentTcb"

	currentTcb := anObject! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!holdCount
	"Answer the value of holdCount"

	^ holdCount! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!holdCount: anObject
	"Set the value of holdCount"

	holdCount := anObject! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!list
	"Answer the value of list"

	^ list! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!list: anObject
	"Set the value of list"

	list := anObject! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!queueCount
	"Answer the value of queueCount"

	^ queueCount! !!CPBScheduler methodsFor: 'accessing' stamp: 'MP 1/15/2014 15:21'!queueCount: anObject
	"Set the value of queueCount"

	queueCount := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBScheduler class
	instanceVariableNames: ''!!CPBScheduler class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:34'!idDeviceA
	^ 4! !!CPBScheduler class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:34'!idDeviceB
	^ 5! !!CPBScheduler class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:33'!idHandlerA
	^ 2! !!CPBScheduler class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:34'!idHandlerB
	^ 3! !!CPBScheduler class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:33'!idIdle
	^ 0! !!CPBScheduler class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:33'!idWorker
	^ 1! !!CPBScheduler class methodsFor: 'class variables' stamp: 'MP 1/15/2014 15:34'!numberOfIDs
	^ 6! !Object subclass: #CPBTaskControlBlock	instanceVariableNames: 'link id priority queue task state'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBTaskControlBlock
	instanceVariableNames: 'link id priority queue task state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Richards'!!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!id
	"Answer the value of id"

	^ id! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!id: anObject
	"Set the value of id"

	id := anObject! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:30'!isHeldOrSuspended
	^ ((self state bitAnd: CPBTaskControlBlock stateHeld) ~~ 0) or: (self state == (CPBTaskControlBlock stateSuspended)) .! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!link
	"Answer the value of link"

	^ link! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!link: anObject
	"Set the value of link"

	link := anObject! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:27'!markAsHeld
	self state: (self state bitOr: CPBTaskControlBlock stateHeld) .! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:27'!markAsNotHeld
	self state: (self state bitAnd: CPBTaskControlBlock stateNotHeld) .! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:31'!markAsRunnable
	self state: (self state bitOr: CPBTaskControlBlock stateRunnable) .! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:31'!markAsSuspended
	self state: (self state bitOr: CPBTaskControlBlock stateSuspended) .! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!priority
	"Answer the value of priority"

	^ priority! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!priority: anObject
	"Set the value of priority"

	priority := anObject! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!queue
	"Answer the value of queue"

	^ queue! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 19:39'!queue: anObject
	"Set the value of queue and changes the state"

	queue := anObject .! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:26'!setRunning
	self state: (CPBTaskControlBlock stateRunning) .! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!state
	"Answer the value of state"

	^ state! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!state: anObject
	"Set the value of state"

	state := anObject! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!task
	"Answer the value of task"

	^ task! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:15'!task: anObject
	"Set the value of task"

	task := anObject! !!CPBTaskControlBlock methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:41'!toString
	^ 'tcb {' + self task + '@' + self state + ' }' .! !!CPBTaskControlBlock methodsFor: 'execution' stamp: 'MP 1/15/2014 16:39'!checkPriorityAdd: task packet: packet
	| return |
	return := task .
	(self queue == nil) ifTrue: [
		self
			queue: packet;
			markAsRunnable .
			
			(self priority > task priority) ifTrue: [
				return := self .
			] .
	] ifFalse: [
		self queue: (packet addTo: (self queue)) .
	] .
	^ return .
	! !!CPBTaskControlBlock methodsFor: 'execution' stamp: 'MP 1/15/2014 16:35'!run
	| packet |
	
	(self state == CPBTaskControlBlock stateSuspendedRunnable) ifTrue: [
		packet := self queue .
		self queue: (packet link) .
		(self queue == nil) ifTrue: [
			self state: CPBTaskControlBlock stateRunning .
		] ifFalse: [
			self state: CPBTaskControlBlock stateRunnable .
		] .
	] ifFalse: [
		packet := nil .
	] .
	^ (self task) run: packet .! !!CPBTaskControlBlock methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 19:35'!initialize
	self 
		link: nil;
		id: 0;
		priority: 0;
		queue: nil;
		task: nil;
		state: CPBTaskControlBlock stateSuspended .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBTaskControlBlock class
	instanceVariableNames: ''!!CPBTaskControlBlock class methodsFor: 'class variables' stamp: 'MP 1/15/2014 16:18'!stateHeld
	^ 4! !!CPBTaskControlBlock class methodsFor: 'class variables' stamp: 'MP 1/15/2014 16:21'!stateNotHeld
	^ (self stateHeld) bitInvert . ! !!CPBTaskControlBlock class methodsFor: 'class variables' stamp: 'MP 1/15/2014 16:18'!stateRunnable
	^ 1! !!CPBTaskControlBlock class methodsFor: 'class variables' stamp: 'MP 1/15/2014 16:18'!stateRunning
	^ 0! !!CPBTaskControlBlock class methodsFor: 'class variables' stamp: 'MP 1/15/2014 16:18'!stateSuspended
	^ 2! !!CPBTaskControlBlock class methodsFor: 'class variables' stamp: 'MP 1/15/2014 16:20'!stateSuspendedRunnable
	^ self stateSuspended bitOr: self stateRunnable .! !!CPBTaskControlBlock class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 19:39'!link: link id: id priority: priority queue: queue task: task
	| instance |
	instance := self new .
	instance
		link: link;
		id: id;
		priority: priority;
		queue: queue;
		task: task .
	(queue isNil) ifTrue: [
		instance state: (CPBTaskControlBlock stateSuspended) .
	] ifFalse: [
		instance state: (CPBTaskControlBlock stateSuspendedRunnable) .
	] .
	^ instance .! !Object subclass: #CPBWorkerTask	instanceVariableNames: 'scheduler seed1 seed2'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBWorkerTask
	instanceVariableNames: 'scheduler seed1 seed2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cross-Platform-Benchmarks-Richards'!!CPBWorkerTask methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 17:30'!initialize
	self
		scheduler: nil;
		seed1: nil;
		seed2: nil .! !!CPBWorkerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:13'!scheduler
	"Answer the value of scheduler"

	^ scheduler! !!CPBWorkerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:13'!scheduler: anObject
	"Set the value of scheduler"

	scheduler := anObject! !!CPBWorkerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:13'!seed1
	"Answer the value of seed1"

	^ seed1! !!CPBWorkerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:13'!seed1: anObject
	"Set the value of seed1"

	seed1 := anObject! !!CPBWorkerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:13'!seed2
	"Answer the value of seed2"

	^ seed2! !!CPBWorkerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:13'!seed2: anObject
	"Set the value of seed2"

	seed2 := anObject! !!CPBWorkerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:17'!toString
	^ 'WorkerTask'! !!CPBWorkerTask methodsFor: 'execution' stamp: 'MP 1/15/2014 18:53'!run: packet
	| return |
	(packet == nil) ifTrue: [
		return := (self scheduler) suspendCurrent .
	] ifFalse: [
		(self seed1 == (CPBScheduler idHandlerA)) ifTrue: [
			self seed1: (CPBScheduler idHandlerB) .
		] ifFalse: [
			self seed1: (CPBScheduler idHandlerA) .
		] .
		packet id: (self seed1).
		packet a1: 0.
		1 to: (CPBPacket dataSize) do: [:i|
			self seed2: (self seed2) + 1.
			(self seed2 > 26) ifTrue: [
				self seed2: 1 .
			] .
			(packet a2) at: i put: (self seed2) .
		] .
		return := (self scheduler) queue: packet .
	] .
	^ return .
! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPBWorkerTask class
	instanceVariableNames: ''!!CPBWorkerTask class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 17:17'!createWithScheduler: scheduler seed1: seed1 seed2: seed2
	| instance |
	instance := self new .
	instance
		scheduler: scheduler;
		seed1: seed1;
		seed2: seed2 .
	^ instance .! !| writer runner |
runner := (CPBRichardsBenchmark) run: 20 .
writer := CPBBenchmarkResultWriter new .
writer writeResult: (runner results) inFile: 'result.txt'. 
Smalltalk snapshot: false andQuit: true !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/benchmarks/Richards.st----!!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'hh 6/11/2014 20:05' prior: 33769394!snapshot: t1 andQuit: t2 	^ self		snapshot: t1		andQuit: t2		embedded: false! !'From Squeak4.4 of 28 April 2013 [latest update: #12627] on 28 May 2014 at 3:28:48 pm'!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 2/7/2014 19:01'!runCPBAStarBenchmark| writer runner |		runner := (CPBAStarBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 2/7/2014 20:20'!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 2/7/2014 20:20'!runCPBBlowfishSuite| writer runner |runner := (CPBBlowfishSuite) run: 3 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 1/27/2014 19:30'!runCPBChameneosBenchmark| writer runner |		runner := (CPBChameneosBenchmark) run: 5 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 1/28/2014 16:18'!runCPBDeltaBlueBenchmark| writer runner |runner := (CPBDeltaBlueBenchmark) run: 5 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 1/27/2014 19:31'!runCPBMandelbrotBenchmarkSuite| writer runner |		runner := (CPBMandelbrotBenchmarkSuite) run: 1 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 1/27/2014 19:32'!runCPBNBodyBenchmark| writer runner |		runner := (CPBNBodyBenchmark) run: 20 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 2/4/2014 16:51'!runCPBPolymorphyBenchmark| writer runner |runner := (CPBPolymorphyBenchmark) run: 1 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 1/27/2014 19:32'!runCPBRichardsBenchmark| writer runner |		runner := (CPBRichardsBenchmark) run: 20 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 1/27/2014 19:32'!runCPBSplayTreeBenchmark| writer runner |		runner := (CPBSplayTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'lw 4/29/2013 13:20' prior: 42573057!runSPyBenchmarks	^ SPyRunner run! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'lw 6/27/2013 15:27' prior: 42627943!runTests	^ SPyRunner runKernelTests! !----End fileIn of /home/hub/hpi/stm/src/benchmarks-st/rsqueak-image-customization/Integer-*SPy-Benchmarks.st----!----SNAPSHOT----{11 June 2014 . 8:05:59 pm} Squeak4.5-12568.image priorSource: 162099!----SNAPSHOT----{11 June 2014 . 8:12:18 pm} Squeak4.5-12568.image priorSource: 958394!----STARTUP----{11 June 2014 . 8:43:32 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{11 June 2014 . 8:44:52 pm} Squeak4.5-12568.image priorSource: 958482!----STARTUP----{11 June 2014 . 8:44:57 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{11 June 2014 . 8:46:25 pm} Squeak4.5-12568.image priorSource: 958482!----STARTUP----{11 June 2014 . 8:51:51 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 20:54' prior: 34482208!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !FileStream stdout nextPutAll: 'foo'.!FileStream stderr nextPutAll: 'foo'.!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 20:55' prior: 34513622!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .	reportFile := FileStream stderr.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !----QUIT----{11 June 2014 . 8:55:37 pm} Squeak4.5-12568.image priorSource: 958482!----STARTUP----{11 June 2014 . 9:01:48 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{11 June 2014 . 9:04:07 pm} Squeak4.5-12568.image priorSource: 961325!----STARTUP----{11 June 2014 . 9:05:48 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:05' prior: 34514775!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 21:06' prior: 34509835!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .SPyVM print: 'done. now writing results.'.writer writeResult: (runner results) inFile: 'result.txt'. ! !----QUIT----{11 June 2014 . 9:06:21 pm} Squeak4.5-12568.image priorSource: 961524!----STARTUP----{11 June 2014 . 9:07:18 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 21:07' prior: 34517282!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .SPyVM print: 'done. now writing results.'.writer writeResult: (runner results) inFile: 'result.txt'. SPyVM print: 'done..'.Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{11 June 2014 . 9:08 pm} Squeak4.5-12568.image priorSource: 963085!----QUIT----{11 June 2014 . 9:08:04 pm} Squeak4.5-12568.image priorSource: 963669!----STARTUP----{11 June 2014 . 9:10:47 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:11' prior: 34516248!writeResult: result inFile: fileName
	| reportFile |	SPyVM print: '1'.
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:11' prior: 34518478!writeResult: result inFile: fileName
	| reportFile |	SPyVM print: '1'.
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .	SPyVM print: '2'.
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].     	SPyVM print: '3'.
	! !----QUIT----{11 June 2014 . 9:11:43 pm} Squeak4.5-12568.image priorSource: 963754!----STARTUP----{11 June 2014 . 9:12:47 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:13' prior: 34519539!writeResult: result inFile: fileName
	| reportFile |	SPyVM print: '1'.
	reportFile := FileStream forceNewFileNamed: fileName .	SPyVM print: '2'.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .	SPyVM print: '2'.
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].     	SPyVM print: '3'.
	! !----QUIT----{11 June 2014 . 9:14:34 pm} Squeak4.5-12568.image priorSource: 966119!----STARTUP----{11 June 2014 . 9:15:16 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!StandardFileStream class methodsFor: 'file creation' stamp: 'hh 6/11/2014 21:18' prior: 34373698!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened 	for writing on that file. If the file already exists, delete it without 	asking before creating the new file."	| dir localName fullName f |	fullName := self fullName: fileName.	(self isAFileNamed: fullName)		ifFalse: 			[f := self new open: fullName forWrite: true.			^ f				ifNil: ["Failed to open the file"					(FileDoesNotExistException fileName: fullName) signal]].	dir := FileDirectory forFileName: fullName.	localName := FileDirectory localNameFor: fullName.	dir		deleteFileNamed: localName		ifAbsent: [(CannotDeleteFileException new			messageText: 'Could not delete the old version of file ' , fullName) signal].	f := self new open: fullName forWrite: true.	^ f		ifNil: ["Failed to open the file"			(FileDoesNotExistException fileName: fullName) signal]! !StandardFileStream class removeSelector: #forceNewFileNamed:!!StandardFileStream class methodsFor: 'file creation' stamp: 'hh 6/11/2014 21:19'!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened 	for writing on that file. If the file already exists, delete it without 	asking before creating the new file."	| dir localName fullName f |	fullName := self fullName: fileName.	(self isAFileNamed: fullName)		ifFalse: 			[f := self new open: fullName forWrite: true.			^ f				ifNil: ["Failed to open the file"					(FileDoesNotExistException fileName: fullName) signal]].	dir := FileDirectory forFileName: fullName.	localName := FileDirectory localNameFor: fullName.	dir		deleteFileNamed: localName		ifAbsent: [(CannotDeleteFileException new			messageText: 'Could not delete the old version of file ' , fullName) signal].	f := self new open: fullName forWrite: true.	^ f		ifNil: ["Failed to open the file"			(FileDoesNotExistException fileName: fullName) signal]! !!StandardFileStream class methodsFor: 'file creation' stamp: 'hh 6/11/2014 21:20' prior: 34374679!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| fullName f |	fullName := self fullName: fileName.	f := self new open: fullName forWrite: false.	^ f		ifNil: ["File does not exist..."			((FileDoesNotExistException fileName: fullName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !----QUIT----{11 June 2014 . 9:20:05 pm} Squeak4.5-12568.image priorSource: 967442!----STARTUP----{11 June 2014 . 9:21:23 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:22' prior: 34520843!writeResult: result inFile: fileName
	| reportFile |	SPyVM print: '1'.
	reportFile := Stream new .	SPyVM print: '2'.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .	SPyVM print: '2'.
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].     	SPyVM print: '3'.
	! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:22' prior: 34524814!writeResult: result inFile: fileName
	| reportFile |	SPyVM print: '1'.
	reportFile := Stream new .	SPyVM print: '2'.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .	SPyVM print: '2'.
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].     	SPyVM print: reportFile.
	! !----QUIT----{11 June 2014 . 9:22:42 pm} Squeak4.5-12568.image priorSource: 970090!----STARTUP----{11 June 2014 . 9:24:08 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 20:54' prior: 34525910!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:25' prior: 34527212!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:25' prior: 34528287!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	SPyVM print: '3'.	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	! !----SNAPSHOT----{11 June 2014 . 9:25:29 pm} Squeak4.5-12568.image priorSource: 972488!FileStream forceNewFileNamed: 'result.txt'!FileStream forceNewFileNamed: 'result.txt'.!FileStream forceNewFileNamed: 'result.txt'.!FileStream forceNewFileNamed: 'result.txt'.!s:=FileStream forceNewFileNamed: 'result.txt'.!s:=FileStream forceNewFileNamed: 'result.txt'.!s:=FileStream forceNewFileNamed: 'result.txt'.!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:27' prior: 34529368!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	SPyVM print: '3'.	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	reportFile flush.! !s:=FileStream forceNewFileNamed: 'result.txt'.s nextPutAll: 'herpderp'.!s:=FileStream forceNewFileNamed: 'result.txt'.s nextPutAll: 'herpderp'.s flush.!----SNAPSHOT----{11 June 2014 . 9:28:55 pm} Squeak4.5-12568.image priorSource: 975943!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:32' prior: 34530886!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .		SPyVM print: '3'.
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	reportFile flush.! !----QUIT----{11 June 2014 . 9:32:37 pm} Squeak4.5-12568.image priorSource: 977637!----STARTUP----{11 June 2014 . 9:34:03 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----SNAPSHOT----{11 June 2014 . 9:34:36 pm} Squeak4.5-12568.image priorSource: 978844!----QUIT/NOSAVE----{11 June 2014 . 9:35:07 pm} Squeak4.5-12568.image priorSource: 979043!----STARTUP----{11 June 2014 . 9:39:38 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:40' prior: 34532250!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	reportFile flush.	FileStream stdout nextPutAll: 'herp'.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 21:40' prior: 34517801!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. 	FileStream stdout nextPutAll: 'derp'.Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 21:40' prior: 34534993!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. FileStream stdout nextPutAll: 'derp'.Smalltalk snapshot: false andQuit: true .! !----QUIT----{11 June 2014 . 9:41:02 pm} Squeak4.5-12568.image priorSource: 979043!----STARTUP----{11 June 2014 . 9:45:50 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 21:46' prior: 34535351!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. (FileStream stdout) nextPutAll: 'derp';flush.Smalltalk snapshot: false andQuit: true .! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:46' prior: 34533862!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].
	reportFile flush.	(FileStream stdout) nextPutAll: 'derp';flush.! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:46' prior: 34536280!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].	(FileStream stdout) nextPutAll: 'derp';flush.            
	reportFile flush.	(FileStream stdout) nextPutAll: 'derp';flush.! !----QUIT----{11 June 2014 . 9:46:49 pm} Squeak4.5-12568.image priorSource: 981191!----STARTUP----{11 June 2014 . 9:46:53 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{11 June 2014 . 9:47:02 pm} Squeak4.5-12568.image priorSource: 984108!----STARTUP----{11 June 2014 . 9:47:11 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{11 June 2014 . 9:47:15 pm} Squeak4.5-12568.image priorSource: 984108!----STARTUP----{11 June 2014 . 9:47:20 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{11 June 2014 . 9:47:25 pm} Squeak4.5-12568.image priorSource: 984108!----STARTUP----{11 June 2014 . 9:52:17 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 21:52' prior: 34537427!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].	(FileStream stdout) nextPutAll: 'derp';flush.            
	"""reportFile flush."""	(FileStream stdout) nextPutAll: 'derp';flush.! !----SNAPSHOT----{11 June 2014 . 9:53:51 pm} Squeak4.5-12568.image priorSource: 984719!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 22:01' prior: 34535907!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new ."writer writeResult: (runner results) inFile: 'result.txt'. "(FileStream stdout) nextPutAll: 'derp'.Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{11 June 2014 . 10:01:21 pm} Squeak4.5-12568.image priorSource: 986130!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 22:02' prior: 34539443!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].	(FileStream stdout) nextPutAll: 'derp'.           
	"""reportFile flush."""	(FileStream stdout) nextPutAll: 'derp'.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 22:03' prior: 34540735!runCPBBinaryTreeBenchmark| writer runner |"runner := (CPBBinaryTreeBenchmark) run: 10 .""writer := CPBBenchmarkResultWriter new .""writer writeResult: (runner results) inFile: 'result.txt'. "Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{11 June 2014 . 10:03:16 pm} Squeak4.5-12568.image priorSource: 986581!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 22:04' prior: 34542386!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true .! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/11/2014 22:09' prior: 34541195!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{11 June 2014 . 10:09:12 pm} Squeak4.5-12568.image priorSource: 988195!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/11/2014 22:09' prior: 34542801!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 1 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true .! !----QUIT/NOSAVE----{11 June 2014 . 10:19:46 pm} Squeak4.5-12568.image priorSource: 989723!----STARTUP----{12 June 2014 . 11:18:42 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 11:26' prior: 34542801!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 11:26' prior: 34544855!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | ].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 11:26' prior: 34545200!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print messageText.].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 11:26' prior: 34545553!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print exc messageText.].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 11:26' prior: 34545930!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print: exc messageText.].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 11:27' prior: 34546311!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 11:27:03 am} Squeak4.5-12568.image priorSource: 989723!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:30' prior: 34543128!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .		avg isNil: [reportFile nextPutAll: 'avg is nil'.].
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:32' prior: 34547174!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .		avg ifNil: [reportFile nextPutAll: 'avg is nil'.].
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 11:32:39 am} Squeak4.5-12568.image priorSource: 992560!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:32' prior: 34548348!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .		avg ifNil: [reportFile nextPutAll: 'avg is nil'.].
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 11:32:58 am} Squeak4.5-12568.image priorSource: 994997!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:34' prior: 34549611!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) .
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .		SPyVM print: avg.
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 11:34:03 am} Squeak4.5-12568.image priorSource: 996260!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:50' prior: 34550874!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .		SPyVM print: avg.
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 11:50:24 am} Squeak4.5-12568.image priorSource: 997490!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:51' prior: 34552104!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size as String).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .		SPyVM print: avg.
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:52' prior: 34553365!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .		SPyVM print: avg.
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 11:52:04 am} Squeak4.5-12568.image priorSource: 998751!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:53' prior: 34554547!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult|
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .		SPyVM print: avg.
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:53' prior: 34555817!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) . ] .		SPyVM print: avg.
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 11:53:13 am} Squeak4.5-12568.image priorSource: 1001203!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:54' prior: 34556998!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print:  (smarkResult total) as String.			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:54' prior: 34558270!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print: 'asd'.			SPyVM print:  (smarkResult total) as String.			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 11:55 am} Squeak4.5-12568.image priorSource: 1003655!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 11:58' prior: 34559487!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print: 'asd'.			SPyVM print:  (smarkResult total) as String.			SPyVM print:  min asString.			SPyVM print:  max asString.			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 11:58:48 am} Squeak4.5-12568.image priorSource: 1006202!----QUIT/NOSAVE----{12 June 2014 . 9:59:10 am} Squeak4.5-12568.image priorSource: 1007591!----STARTUP----{12 June 2014 . 1:12:15 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:12' prior: 34560814!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print:  (smarkResult total) as String.			SPyVM print:  min asString.			SPyVM print:  max asString.			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !1 min: 0!1 min: 0!SMarkResult allInstances!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 13:18' prior: 34509542!runCPBAStarBenchmark| writer runner |				SPyVM print: (Time millisecondClockValue) asString.runner := (CPBAStarBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 13:18' prior: 34546693!runCPBBinaryTreeBenchmark| writer runner |[SPyVM print: (Time millisecondClockValue) asString.runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 1:18:20 pm} Squeak4.5-12568.image priorSource: 1007591!!SMarkTimer methodsFor: 'accessing' stamp: 'hh 6/12/2014 13:19' prior: 34474717!totalTime	SPyVM print: 'totaltime called.'.
	^elapsedTime! !----SNAPSHOT----{12 June 2014 . 1:19:36 pm} Squeak4.5-12568.image priorSource: 1010017!!SMarkTimer methodsFor: 'accessing' stamp: 'hh 6/12/2014 13:20' prior: 34564620!totalTime	SPyVM print: 'totaltime called.'.	SPyVM print: elapsedTime asString.
	^elapsedTime! !----SNAPSHOT----{12 June 2014 . 1:20:13 pm} Squeak4.5-12568.image priorSource: 1010250!!SMarkTimer methodsFor: 'accessing' stamp: 'hh 6/12/2014 13:20' prior: 34564853!totalTime
	^elapsedTime! !!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:22' prior: 34449916!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	SPyVM print:  (result total) as String.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:22' prior: 34565229!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM record.
	SPyVM print:  (result total) as String.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !----SNAPSHOT----{12 June 2014 . 1:22:58 pm} Squeak4.5-12568.image priorSource: 1010519!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:23' prior: 34565666!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record'.
	SPyVM print:  (result total) as String.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:24' prior: 34566207!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.
	SPyVM print:  (result total) as String.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !----SNAPSHOT----{12 June 2014 . 1:24:07 pm} Squeak4.5-12568.image priorSource: 1011606!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:26' prior: 34566668!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.
	SPyVM print:  (result total) as String.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.	SPyVM print:  (results at: name ) as String.! !----SNAPSHOT----{12 June 2014 . 1:26:42 pm} Squeak4.5-12568.image priorSource: 1012619!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:28' prior: 34567220!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.
	SPyVM print:  (result total) as String.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.	SPyVM print:  (results at: name ) as String.	SPyVM print: 'recordend\n'.! !----SNAPSHOT----{12 June 2014 . 1:28:11 pm} Squeak4.5-12568.image priorSource: 1013217!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:28' prior: 34567818!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.
	SPyVM print:  (result total) asString.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.	SPyVM print:  (results at: name ) as String.	SPyVM print: 'recordend\n'.! !!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:29' prior: 34568445!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.
	SPyVM print:  (result total) asString.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.	SPyVM print:  (results at: name ) asString.	SPyVM print: 'recordend\n'.! !----SNAPSHOT----{12 June 2014 . 1:29:04 pm} Squeak4.5-12568.image priorSource: 1013844!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:29' prior: 34568982!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.
	SPyVM print:  (result total) asString.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.	SPyVM print:  (results at: name) total asString.	SPyVM print: 'recordend\n'.! !----SNAPSHOT----{12 June 2014 . 1:29:46 pm} Squeak4.5-12568.image priorSource: 1015006!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:30' prior: 34569607!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.
	SPyVM print:  (result total) asString.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.	SPyVM print:  (results at: name) totalTime asString.	SPyVM print: 'recordend\n'.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 13:35' prior: 34564098!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .SPyVM print: (runner results size) asString.writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 13:35' prior: 34570787!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .SPyVM print: (runner results size).writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 1:35:59 pm} Squeak4.5-12568.image priorSource: 1015636!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:36' prior: 34570237!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.	SPyVM print: 'recordend\n'.! !!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:37' prior: 34571720!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.	SPyVM print: 'recordend\n'.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 13:37' prior: 34571216!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .SPyVM print: (runner results size) asString.writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 1:37:15 pm} Squeak4.5-12568.image priorSource: 1017119!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:39' prior: 34572170!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.		(result at: name) keysAndValuesDo: [:benchmark :smarkResults | | avg min max |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print:  (smarkResult total) as String.			SPyVM print:  min asString.			SPyVM print:  max asString.			 ] 		].			SPyVM print: 'recordend\n'.! !OrderedCollection new size! 2014 . 11:39:40 am} Squeak4.5-12568.image priorSource: 1018539!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:43' prior: 34562413!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	SPyVM print: (result keys).
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print:  (smarkResult total) as String.			SPyVM print:  min asString.			SPyVM print:  max asString.			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:43:59 pm} Squeak4.5-12568.image priorSource: 1018539!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:45' prior: 34574150!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	SPyVM print: (result keys) asString.
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print:  (smarkResult total) as String.			SPyVM print:  min asString.			SPyVM print:  max asString.			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:45:36 pm} Squeak4.5-12568.image priorSource: 1020931!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 13:46' prior: 34572626!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 1:46:36 pm} Squeak4.5-12568.image priorSource: 1022335!!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 13:47' prior: 34573140!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.	SPyVM print: 'record\n'.	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.		SPyVM print: 'recordend\n'.! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:47' prior: 34575545!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	"SPyVM print: (result keys) asString."
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print:  (smarkResult total) as String.			SPyVM print:  min asString.			SPyVM print:  max asString.			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:48 pm} Squeak4.5-12568.image priorSource: 1022808!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:48' prior: 34577875!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	SPyVM print: (result keys) asString.
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print:  (smarkResult total) as String.			SPyVM print:  min asString.			SPyVM print:  max asString.			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:48:54 pm} Squeak4.5-12568.image priorSource: 1024667!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:50' prior: 34579278!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .		SPyVM print: (smarkResults size) asString.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:50:14 pm} Squeak4.5-12568.image priorSource: 1026068!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:52' prior: 34580682!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |			SPyVM print: 'printf'.			SPyVM print: smarkResult total.
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:52:25 pm} Squeak4.5-12568.image priorSource: 1027371!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:53' prior: 34581985!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |			SPyVM print: 'printf'.			SPyVM print: smarkResult total asString.
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:53' prior: 34583305!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |			SPyVM print: 'printf'.			SPyVM print: (smarkResult total) asString.
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:53:16 pm} Squeak4.5-12568.image priorSource: 1028691!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:54' prior: 34584545!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:54' prior: 34585876!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		SPyVM print: avg asString.
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:54:56 pm} Squeak4.5-12568.image priorSource: 1031262!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:55' prior: 34587047!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:56:12 pm} Squeak4.5-12568.image priorSource: 1033719!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:57' prior: 34588333!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print: (avg asString).			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 1:57:28 pm} Squeak4.5-12568.image priorSource: 1035007!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:58' prior: 34589621!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .		SPyVM print: (avg asString).
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .						 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 13:58' prior: 34590913!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .		SPyVM print: (avg asString).
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 13:58'!testFloat[SPyVM print: (0.0 asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 1:58:46 pm} Squeak4.5-12568.image priorSource: 1036299!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:00' prior: 34592119!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf) ;		nextPutAll: (result size asString).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:00' prior: 34593631!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:00' prior: 34594802!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		SPyVM print: (avg asString).	
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:00:29 pm} Squeak4.5-12568.image priorSource: 1039017!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:00' prior: 34595934!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print: (avg asString).			 ] .		SPyVM print: (avg asString).	
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:00' prior: 34597184!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			SPyVM print: (avg asString).			 ] .		"""SPyVM print: (avg asString).	"""
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:00:44 pm} Squeak4.5-12568.image priorSource: 1042570!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:01' prior: 34598377!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0 .
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		"""SPyVM print: (avg asString).	"""
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:01:49 pm} Squeak4.5-12568.image priorSource: 1045051!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:02' prior: 34593297!testFloat[SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:02:29 pm} Squeak4.5-12568.image priorSource: 1046376!(0.0 + 100)!AVE----{12 June 2014 . 12:02:38 pm} Squeak4.5-12568.image priorSource: 1046710!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:03' prior: 34600982!testFloat[SPyVM print: ((0.0 asInteger + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !(0.0 asInteger + 100)!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:03' prior: 34601409!testFloat[SPyVM print: ((0.0 asInteger + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:03:15 pm} Squeak4.5-12568.image priorSource: 1046710!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:03' prior: 34599665!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		"""SPyVM print: (avg asString).	"""
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:03' prior: 34602040!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		"""SPyVM print: (avg asString).	"""
		avg:= avg asFloat / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:03:52 pm} Squeak4.5-12568.image priorSource: 1047426!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:04' prior: 34603273!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		SPyVM print: (avg asString).
		avg:= avg asFloat / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:04:44 pm} Squeak4.5-12568.image priorSource: 1049989!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:05' prior: 34604603!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:05:50 pm} Squeak4.5-12568.image priorSource: 1051312!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:06' prior: 34601688!testFloat[SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:06' prior: 34607233!testFloat[SPyVM print: ((100 / 100) asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:06:40 pm} Squeak4.5-12568.image priorSource: 1052627!----SNAPSHOT----{12 June 2014 . 2:07:06 pm} Squeak4.5-12568.image priorSource: 1053244!244!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:07' prior: 34607478!testFloat[SPyVM print: ((14252 / 10) asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:08' prior: 34607943!testFloat[SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:08:21 pm} Squeak4.5-12568.image priorSource: 1053333!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:12' prior: 34605926!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asString);
			nextPutAll: ';';			
			nextPutAll: (min asString);
			nextPutAll: ';';			
			nextPutAll: (max asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 14:13' prior: 34577409!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !----SNAPSHOT----{12 June 2014 . 2:13:09 pm} Squeak4.5-12568.image priorSource: 1054002!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:15' prior: 34608227!testFloat[SPyVM print: ((1.23 - 1.23) asString).	SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:15:41 pm} Squeak4.5-12568.image priorSource: 1055689!!Float methodsFor: 'truncation and round off' stamp: 'hh 6/12/2014 14:17' prior: 53776732!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	"self isFinite ifFalse: [self error: 'Cannot truncate this number']".	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				| di df q r |				di := 1 + (SmallInteger maxVal bitShift: -1).				df := di asFloat.				q := self quo: df.				r := self - (q asFloat * df).				^q * di + r truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]				! !----SNAPSHOT----{12 June 2014 . 2:17:22 pm} Squeak4.5-12568.image priorSource: 1056110!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:18' prior: 34610295!testFloat[SPyVM print: (0.0 asFloat).	SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:18' prior: 34611661!testFloat[SPyVM print: (0 asFloat).	SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:18' prior: 34611982!testFloat[SPyVM print: (0 asFloat).	SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:18' prior: 34612301!testFloat[SPyVM print: (0 asFloat).	SPyVM print: 'foo'.SPyVM print: (0.0 asFloat).	SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:19' prior: 34612620!testFloat[SPyVM print: (0 asFloat).	SPyVM print: 'foo'.SPyVM print: (0.0 asFloat).	SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:19:10 pm} Squeak4.5-12568.image priorSource: 1057055!!Float methodsFor: 'truncation and round off' stamp: 'hh 6/12/2014 14:19' prior: 34610723!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	self isFinite ifFalse: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				| di df q r |				di := 1 + (SmallInteger maxVal bitShift: -1).				df := di asFloat.				q := self quo: df.				r := self - (q asFloat * df).				^q * di + r truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]				! !----SNAPSHOT----{12 June 2014 . 2:19:22 pm} Squeak4.5-12568.image priorSource: 1058839!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:20' prior: 34612988!testFloat[SPyVM print: (0 asFloat).	SPyVM print: 'foo'.SPyVM print: (0.0 asFloat).	SPyVM print: 'bar'.SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:20:09 pm} Squeak4.5-12568.image priorSource: 1059782!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:23' prior: 34608616!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asString);
			nextPutAll: ';';			
			nextPutAll: (min asString);
			nextPutAll: ';';			
			nextPutAll: (max asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:23:20 pm} Squeak4.5-12568.image priorSource: 1060259!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:24' prior: 34614873!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		avg := avg asFloat.		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asString);
			nextPutAll: ';';			
			nextPutAll: (min asString);
			nextPutAll: ';';			
			nextPutAll: (max asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:24:14 pm} Squeak4.5-12568.image priorSource: 1061552!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 14:25' prior: 34616166!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		avg := avg asFloat.		SPyVM print: 'herp'.		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asString);
			nextPutAll: ';';			
			nextPutAll: (min asString);
			nextPutAll: ';';			
			nextPutAll: (max asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !----SNAPSHOT----{12 June 2014 . 2:25:10 pm} Squeak4.5-12568.image priorSource: 1062865!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:26' prior: 34614388!testFloat[SPyVM print: 0.0 asString.SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:26:38 pm} Squeak4.5-12568.image priorSource: 1064201!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:26' prior: 34618807!testFloat[SPyVM print: 0.0 asFloat asString.SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:26:56 pm} Squeak4.5-12568.image priorSource: 1064609!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:27' prior: 34619215!testFloat[SPyVM print: 0.0 asFloat asString.SPyVM print: ((14252 / 10) class asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:27:09 pm} Squeak4.5-12568.image priorSource: 1065025!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:27' prior: 34619631!testFloat[SPyVM print: (0/0) asFloat asString.SPyVM print: ((14252 / 10) class asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:27:30 pm} Squeak4.5-12568.image priorSource: 1065439!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:27' prior: 34620045!testFloat[SPyVM print: (10/10) asFloat asString.SPyVM print: ((14252 / 10) class asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:28:01 pm} Squeak4.5-12568.image priorSource: 1065855!----SNAPSHOT----{12 June 2014 . 2:28:10 pm} Squeak4.5-12568.image priorSource: 1066273!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:29' prior: 34620461!testFloat[SPyVM print: (10/10) asFloat asString.SPyVM print: (10/10) asString.SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:29' prior: 34620968!testFloat[SPyVM print: (10/10) asString.SPyVM print: (10/10) asFloat asString.SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:29:19 pm} Squeak4.5-12568.image priorSource: 1066362!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:30' prior: 34621330!testFloat[SPyVM print: (10/10) asString.SPyVM print: (10/10) asFloat isFinite asString.SPyVM print: ((14252 / 10) asFloat asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:30:20 pm} Squeak4.5-12568.image priorSource: 1067175!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:30' prior: 34621781!testFloat[SPyVM print: (10/10) asString.SPyVM print: (10/10) asFloat isFinite asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:30' prior: 34622242!testFloat[SPyVM print: (10/10) asString.SPyVM print: (10/10) asFloat asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc messageText).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:31 pm} Squeak4.5-12568.image priorSource: 1067636!!Float methodsFor: 'truncation and round off' stamp: 'nice 12/1/2009 12:30' prior: 34613452!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	self isFinite ifFalse: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				| di df q r |				di := 1 + (SmallInteger maxVal bitShift: -1).				df := di asFloat.				q := self quo: df.				r := self - (q asFloat * df).				^q * di + r truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]				! !----SNAPSHOT----{12 June 2014 . 2:39:33 pm} Squeak4.5-12568.image priorSource: 1068478!!Float methodsFor: 'truncation and round off' stamp: 'hh 6/12/2014 14:19' prior: 34623090!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	self isFinite ifFalse: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				| di df q r |				di := 1 + (SmallInteger maxVal bitShift: -1).				df := di asFloat.				q := self quo: df.				r := self - (q asFloat * df).				^q * di + r truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]				! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:40' prior: 34622623!testFloat[SPyVM print: (10/10) asString.SPyVM print: (10/10) asFloat asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:40:31 pm} Squeak4.5-12568.image priorSource: 1069420!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 14:44' prior: 33666110!absPrintOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significantBits := 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase := base asFloat.	exp := self exponent.	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r := self.			s := 1.0.			mPlus := 1.0 timesTwoPower: exp - significantBits.			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r := self timesTwoPower: significantBits.			s := 1.0 timesTwoPower:  significantBits.			mMinus := 1.0 timesTwoPower: (exp max: -1024).			mPlus :=				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r := r / fBase.					s := s * (fBase raisedToInteger: baseExpEstimate - 1).					mPlus := mPlus / fBase.					mMinus := mMinus / fBase]				ifFalse:					[s := s * (fBase raisedToInteger: baseExpEstimate)]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale := fBase raisedToInteger: d.					r := r * scale.					mPlus := mPlus * scale.					mMinus := mMinus * scale.					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale := fBase raisedToInteger: baseExpEstimate negated].			s := s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[s := s / fBase].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	[d := (r / s) truncated.	r := r - (d * s).	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * fBase.		mPlus := mPlus * fBase.		mMinus := mMinus * fBase.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !----SNAPSHOT----{12 June 2014 . 2:44:57 pm} Squeak4.5-12568.image priorSource: 1070749!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:47' prior: 34624880!testFloat[SPyVM print: (10/10) asString.SPyVM print: (1) asFloat asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:47:44 pm} Squeak4.5-12568.image priorSource: 1074099!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:48' prior: 34628705!testFloat[SPyVM print: (10/10) asString.SPyVM print: (1) asFloat asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc message).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:49' prior: 34629176!testFloat[SPyVM print: (10/10) asString.SPyVM print: (1) asFloat asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:49:27 pm} Squeak4.5-12568.image priorSource: 1074570!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:49' prior: 34629589!testFloat[SPyVM print: (1+1.0) asString.SPyVM print: (1) asFloat asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:49:47 pm} Squeak4.5-12568.image priorSource: 1075489!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:50' prior: 34630095!testFloat[SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: (1) asFloat asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:50:55 pm} Squeak4.5-12568.image priorSource: 1075995!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:51' prior: 34630601!testFloat[SPyVM print: 'test convertion'.	SPyVM print: (1) asFloat asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:51:25 pm} Squeak4.5-12568.image priorSource: 1076531!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:51' prior: 34631137!testFloat[SPyVM print: 'test convertion'.	SPyVM print: (1) asFloat.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:51:49 pm} Squeak4.5-12568.image priorSource: 1077102!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:52' prior: 34631708!testFloat| t1 |[SPyVM print: 'test convertion'.	SPyVM print: (1) asFloat.t1 := 1 asFloat.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:52:25 pm} Squeak4.5-12568.image priorSource: 1077664!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:52' prior: 34632270!testFloat| t1 |[SPyVM print: 'test convertion'.	t1 := 1 asFloat.SPyVM print: (1) asFloat.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:52:32 pm} Squeak4.5-12568.image priorSource: 1078250!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:52' prior: 34632856!testFloat| t1 |[SPyVM print: 'test convertion'.	t1 := 1 asFloat."SPyVM print: (1) asFloat."SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:52:58 pm} Squeak4.5-12568.image priorSource: 1078835!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:53' prior: 34633441!testFloat| t1 |[SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:53:30 pm} Squeak4.5-12568.image priorSource: 1079422!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 14:54' prior: 34634028!testFloat| |[SPyVM print: 'test convertion'.	SPyVM print: (1) asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 2:54:57 pm} Squeak4.5-12568.image priorSource: 1079993!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:01' prior: 40592835!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].	SPyVM print: t1 asString, ' <<>> ', t2 asString.	t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:01:04 pm} Squeak4.5-12568.image priorSource: 1080622!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:03' prior: 34635219!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: t4 asString, ' <<>> ', (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:03:34 pm} Squeak4.5-12568.image priorSource: 1082829!MinValLogBase2!----{12 June 2014 . 1:03:41 pm} Squeak4.5-12568.image priorSource: 1085093!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:05' prior: 34637426!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2 asFloat reciprocalLogBase2).	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:05:55 pm} Squeak4.5-12568.image priorSource: 1085093!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:06' prior: 34639782!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2 asFloat).	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:06:19 pm} Squeak4.5-12568.image priorSource: 1087473!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:07' prior: 34642070!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2).	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:07:08 pm} Squeak4.5-12568.image priorSource: 1089742!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:07' prior: 34644339!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2).	SPyVM print: 'asda'.	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:07:46 pm} Squeak4.5-12568.image priorSource: 1092003!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:08' prior: 34646600!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2 asFloat).	SPyVM print: 'asda'.	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:08' prior: 34648883!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2 asString).	SPyVM print: 'asda'.	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:08:13 pm} Squeak4.5-12568.image priorSource: 1094286!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:09' prior: 34651085!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2 asFloat reciprocalLogBase2).	SPyVM print: 'asda'.	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:09:29 pm} Squeak4.5-12568.image priorSource: 1098780!----SNAPSHOT----{12 June 2014 . 3:09:36 pm} Squeak4.5-12568.image priorSource: 1101090!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:10' prior: 34653377!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2 asFloat reciprocalLogBase2) asInteger asString.	SPyVM print: 'asda'.	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:10:10 pm} Squeak4.5-12568.image priorSource: 1101179!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:10' prior: 34655776!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2 asFloat reciprocalLogBase2) asFloat asString.	SPyVM print: 'asda'.	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:10' prior: 34658105!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	SPyVM print: (t2 asFloat reciprocalLogBase2) asString.	SPyVM print: 'asda'.	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString.	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !----SNAPSHOT----{12 June 2014 . 3:10:55 pm} Squeak4.5-12568.image priorSource: 1103508!10..0 asFloat reciprocalLogBase2!. 1:11:02 pm} Squeak4.5-12568.image priorSource: 1108065!10..0 asFloat reciprocalLogBase2!10 asFloat reciprocalLogBase2!----STARTUP----{12 June 2014 . 3:13:57 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Float methodsFor: 'printing' stamp: 'hh 6/12/2014 15:14' prior: 34660343!absPrintExactlyOn: t1 base: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 |	self isInfinite		ifTrue: [t1 nextPutAll: 'Infinity'.			^ self].		t3 := self significandAsInteger.	t11 := t3 even.	t4 := self exponent - 52 max: MinValLogBase2.	"SPyVM print: (t2 asFloat reciprocalLogBase2) asString.	SPyVM print: 'asda'.	SPyVM print: (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) asString."	t5 := (self exponent * t2 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	t4 >= 0		ifTrue: [t3 ~= 4503599627370496				ifTrue: [t6 := t3 bitShift: 1 + t4.					t7 := 2.					t8 := t9 := 1 bitShift: t4]				ifFalse: [t6 := t3 bitShift: 2 + t4.					t7 := 4.					t8 := 2 * (t9 := 1 bitShift: t4)]]		ifFalse: [(t4 = MinValLogBase2					or: [t3 ~= 4503599627370496])				ifTrue: [t6 := t3 bitShift: 1.					t7 := 1 bitShift: 1 - t4.					t8 := t9 := 1]				ifFalse: [t6 := t3 bitShift: 2.					t7 := 1 bitShift: 2 - t4.					t8 := 2.					t9 := 1]].	t5 >= 0		ifTrue: [t7 := t7						* (t2 raisedToInteger: t5)]		ifFalse: [t10 := t2 raisedToInteger: t5 negated.			t6 := t6 * t10.			t8 := t8 * t10.			t9 := t9 * t10].	(t6 + t8 >= t7			and: [t11					or: [t6 + t8 > t7]])		ifTrue: [t5 := t5 + 1]		ifFalse: [t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2].	(t15 := t5 between: -3 and: 6)		ifTrue: [t16 := t5.			t5 <= 0				ifTrue: [t1						nextPutAll: ('0.000000' truncateTo: 2 - t5)]]		ifFalse: [t16 := 1].	t17 := 1 - t7 lowBit.	t18 := t7 bitShift: t17.	[t12 := (t6 bitShift: t17)				// t18.	t6 := t6 - (t12 * t7).	(t13 := t6 <= t9				and: [t11						or: [t6 < t9]]) | (t14 := t6 + t8 >= t7					and: [t11							or: [t6 + t8 > t7]])]		whileFalse: [t1				nextPut: (Character digitValue: t12).			t6 := t6 * t2.			t8 := t8 * t2.			t9 := t9 * t2.			(t16 := t16 - 1) = 0				ifTrue: [t1 nextPut: $.]].	t14		ifTrue: [(t13 not					or: [t6 * 2 >= t7])				ifTrue: [t12 := t12 + 1]].	t1		nextPut: (Character digitValue: t12).	t16 > 0		ifTrue: [t16 - 1				to: 1				by: -1				do: [:t19 | t1 nextPut: $0].			t1 nextPutAll: '.0'].	t15		ifFalse: [t1 nextPut: $e.			t1 nextPutAll: (t5 - 1) printString]! !19 asFloat reciprocalLogBase2!19 asFloat reciprocalLogBase2!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:15' prior: 34634599!testFloat| |[SPyVM print: 'test convertion'.	SPyVM print: (1) asString.SPyVM print: 'test convertion'.	SPyVM print: 19 asFloat reciprocalLogBase2 isFinite.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:15' prior: 34665241!testFloat| |[SPyVM print: 'test convertion'.	SPyVM print: (1) asString.SPyVM print: 'test convertion'.	SPyVM print: 19 asFloat reciprocalLogBase2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:15:15 pm} Squeak4.5-12568.image priorSource: 1108065!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:15' prior: 34665868!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat reciprocalLogBase2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:15:23 pm} Squeak4.5-12568.image priorSource: 1111987!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:16' prior: 34666593!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat isFinite asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat reciprocalLogBase2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:16:18 pm} Squeak4.5-12568.image priorSource: 1112714!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:16' prior: 34667320!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat isFinite asString.SPyVM print: 'test convertion3'.	SPyVM print: 19 asFloat reciprocalLogBase2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:16:25 pm} Squeak4.5-12568.image priorSource: 1113520!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:17' prior: 34668126!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: (19 asFloat = 0)  asString.SPyVM print: 'test convertion3'.	SPyVM print: 19 asFloat reciprocalLogBase2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:17:31 pm} Squeak4.5-12568.image priorSource: 1114326!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:17' prior: 34668932!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: (19 asFloat = 0.0)  asString.SPyVM print: 'test convertion3'.	SPyVM print: 19 asFloat reciprocalLogBase2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:17:53 pm} Squeak4.5-12568.image priorSource: 1115130!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:19' prior: 34669736!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat ln isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: 19 asFloat reciprocalLogBase2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:19:18 pm} Squeak4.5-12568.image priorSource: 1115936!Ln2!QUIT/NOSAVE----{12 June 2014 . 1:19:24 pm} Squeak4.5-12568.image priorSource: 1116746!Float ln2!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:24' prior: 34670542!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat ln isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: Float ln2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:24:27 pm} Squeak4.5-12568.image priorSource: 1116746!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:25' prior: 34671456!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat Pi isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: Float ln2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:25:15 pm} Squeak4.5-12568.image priorSource: 1117640!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:25' prior: 34672246!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: Float Pi isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:25:46 pm} Squeak4.5-12568.image priorSource: 1118430!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:25' prior: 34673036!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: Float pi isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:26:28 pm} Squeak4.5-12568.image priorSource: 1119216!16!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:26' prior: 34673822!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: Float ln2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:26:54 pm} Squeak4.5-12568.image priorSource: 1120002!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:27' prior: 34674611!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: Float ln10 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 3:27:57 pm} Squeak4.5-12568.image priorSource: 1120792!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:28' prior: 34675398!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: Float ln2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !Float!Ln2!self at: 1!self at: 2!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 16:34' prior: 34576941!runCPBBinaryTreeBenchmark| writer runner |runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true .! !----SNAPSHOT----{12 June 2014 . 4:35:17 pm} Squeak4.5-12568.image priorSource: 1121580!----QUIT/NOSAVE----{12 June 2014 . 4:43:14 pm} Squeak4.5-12568.image priorSource: 1122726!----QUIT/NOSAVE----{12 June 2014 . 6:18:28 pm} Squeak4.5-12568.image priorSource: 1122726!----STARTUP----{12 June 2014 . 8:18:37 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 20:18' prior: 34617479!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		avg := avg asFloat.		SPyVM print: 'herp'.		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asString);
			nextPutAll: ';';			
			nextPutAll: (min asString);
			nextPutAll: ';';			
			nextPutAll: (max asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .		FileStream stdout nextPutAll: 'aaa'.
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 20:19' prior: 34677639!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		avg := avg asFloat.		SPyVM print: 'herp'.		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asString);
			nextPutAll: ';';			
			nextPutAll: (min asString);
			nextPutAll: ';';			
			nextPutAll: (max asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 20:19' prior: 34678846!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		avg := avg asFloat.		SPyVM print: 'herp'.		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].! !----QUIT----{12 June 2014 . 8:19:20 pm} Squeak4.5-12568.image priorSource: 1122726!----STARTUP----{12 June 2014 . 8:21:55 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 20:22' prior: 34680015!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		avg := avg asFloat.		SPyVM print: 'herp'.		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].! !----QUIT----{12 June 2014 . 8:22:16 pm} Squeak4.5-12568.image priorSource: 1126683!----STARTUP----{12 June 2014 . 8:22:18 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{12 June 2014 . 8:22:23 pm} Squeak4.5-12568.image priorSource: 1128110!----STARTUP----{12 June 2014 . 8:31:03 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 20:31' prior: 34681408!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .			SPyVM print: (avg asString).
			avg := avg + (smarkResult total) .			SPyVM print: (smarkResult total).			 ] .		avg := avg asFloat.		SPyVM print: 'herp'.		SPyVM print: (avg asString).
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].! !----QUIT----{12 June 2014 . 8:31:12 pm} Squeak4.5-12568.image priorSource: 1128310!----QUIT/NOSAVE----{12 June 2014 . 6:32:09 pm} Squeak4.5-12568.image priorSource: 1129743!----STARTUP----{12 June 2014 . 8:32:17 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 20:47' prior: 34683035!writeResult: result inFile: fileName
	| reportFile |
	"""reportFile := FileStream forceNewFileNamed: fileName ."""	reportFile := FileStream stdout.
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		avg := avg asFloat.
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].! !----SNAPSHOT----{12 June 2014 . 8:47:05 pm} Squeak4.5-12568.image priorSource: 1129743!----QUIT/NOSAVE----{12 June 2014 . 6:47:57 pm} Squeak4.5-12568.image priorSource: 1131147!----QUIT/NOSAVE----{12 June 2014 . 6:50:13 pm} Squeak4.5-12568.image priorSource: 1131147!----STARTUP----{12 June 2014 . 8:50:40 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 20:50' prior: 34684560!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .	"""reportFile := FileStream stdout."""
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		avg := avg asFloat.
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 20:52' prior: 34676924!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true .] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !----QUIT----{12 June 2014 . 8:52:47 pm} Squeak4.5-12568.image priorSource: 1131147!----QUIT/NOSAVE----{12 June 2014 . 6:55:38 pm} Squeak4.5-12568.image priorSource: 1133076!----STARTUP----{12 June 2014 . 8:58:22 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'hh 6/12/2014 21:02'!createThreadSTM: threadNumber of: threadCount
| semaphore |
semaphore := STMProcess new.
[ | index maxIndex |
	maxIndex := self form width * self form height.
	index := threadNumber.
	[index < maxIndex] whileTrue: [
		self calculateValAt: (self pointForIndex: index).
		index := index + threadCount.
	].
	semaphore signal.
] fork.
^ semaphore.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'hh 6/12/2014 21:02'!calculateWithThreadsSTM: anInteger
| semaphores |
	semaphores := OrderedCollection new.
	1 to: anInteger do:[ :i |
			semaphores add: (self createThread: i of: anInteger).
		].
	semaphores do: [:s| s wait].! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'hh 6/12/2014 21:02' prior: 34688314!calculateWithThreadsSTM: anInteger
| semaphores |
	semaphores := OrderedCollection new.
	1 to: anInteger do:[ :i |
			semaphores add: (self createThreadSTM: i of: anInteger).
		].
	semaphores do: [:s| s wait].! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'hh 6/12/2014 21:03'!reCalculateSTM
	form := nil.
	(self threadCount <= 1) ifTrue: [
		self calculate.
	] ifFalse: [
		self calculateWithThreadsSTM: self threadCount.
	].
	self changed.! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:04'!benchMandelbrotIterative1ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:04'!benchMandelbrotIterative2ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:04'!benchMandelbrotIterative4ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 4;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:04'!benchMandelbrotIterative8ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 8;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization addCategory: #'benchmarking-stm'!CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotIterative8ThreadSTM under: #'benchmarking-stm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-stm' stamp: 'hh 6/12/2014 21:04' prior: 34689769!benchMandelbrotIterative8ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 8;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotIterative4ThreadSTM under: #'benchmarking-stm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-stm' stamp: 'hh 6/12/2014 21:04' prior: 34689570!benchMandelbrotIterative4ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 4;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotIterative2ThreadSTM under: #'benchmarking-stm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-stm' stamp: 'hh 6/12/2014 21:04' prior: 34689371!benchMandelbrotIterative2ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotIterative1ThreadSTM under: #'benchmarking-stm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-stm' stamp: 'hh 6/12/2014 21:04' prior: 34689172!benchMandelbrotIterative1ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:05'!benchMandelbrotRecursive1ThreadSTN
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06'!benchMandelbrotRecursive1ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotRecursive1ThreadSTN!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06'!benchMandelbrotRecursive2ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06' prior: 34691864!benchMandelbrotRecursive2ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06'!benchMandelbrotRecursive4ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 4;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06'!benchMandelbrotRecursive8ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 8;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotRecursive1ThreadSTM under: #'benchmarking-stm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-stm' stamp: 'hh 6/12/2014 21:06' prior: 34691583!benchMandelbrotRecursive1ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotRecursive4ThreadSTM under: #'benchmarking-stm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-stm' stamp: 'hh 6/12/2014 21:06' prior: 34692275!benchMandelbrotRecursive4ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 4;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotRecursive2ThreadSTM under: #'benchmarking-stm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-stm' stamp: 'hh 6/12/2014 21:06' prior: 34692076!benchMandelbrotRecursive2ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotRecursive8ThreadSTM under: #'benchmarking-stm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-stm' stamp: 'hh 6/12/2014 21:06' prior: 34692474!benchMandelbrotRecursive8ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 8;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization renameCategory: #benchmarking toBe: #'benchmarking-nonstm'!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-nonstm' stamp: 'MP 1/27/2014 14:18' prior: 34036428!benchMandelbrotIterative1Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-nonstm' stamp: 'MP 1/27/2014 14:18' prior: 34036621!benchMandelbrotIterative2Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-nonstm' stamp: 'MP 1/27/2014 14:18' prior: 34036814!benchMandelbrotIterative4Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 4;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-nonstm' stamp: 'MP 1/27/2014 14:18' prior: 34037007!benchMandelbrotIterative8Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 8;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-nonstm' stamp: 'MP 1/27/2014 14:18' prior: 34037200!benchMandelbrotRecursive1Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-nonstm' stamp: 'MP 1/27/2014 14:18' prior: 34037393!benchMandelbrotRecursive2Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-nonstm' stamp: 'MP 1/27/2014 14:18' prior: 34037586!benchMandelbrotRecursive4Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 4;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking-nonstm' stamp: 'MP 1/27/2014 14:19' prior: 34037779!benchMandelbrotRecursive8Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 8;
		reCalculate .
	! !CPBMandelbrotBenchmarkSuite organization renameCategory: #'benchmarking-stm' toBe: #benchmarking!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:04' prior: 34691185!benchMandelbrotIterative1ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:04' prior: 34690850!benchMandelbrotIterative2ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:04' prior: 34690515!benchMandelbrotIterative4ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 4;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:04' prior: 34690180!benchMandelbrotIterative8ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 8;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06' prior: 34692809!benchMandelbrotRecursive1ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06' prior: 34693479!benchMandelbrotRecursive2ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06' prior: 34693144!benchMandelbrotRecursive4ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 4;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/12/2014 21:06' prior: 34693814!benchMandelbrotRecursive8ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 8;
		reCalculateSTM .
	! !----SNAPSHOT----{12 June 2014 . 9:07:11 pm} Squeak4.5-12568.image priorSource: 1133076!----QUIT----{12 June 2014 . 9:07:17 pm} Squeak4.5-12568.image priorSource: 1143144!----STARTUP----{12 June 2014 . 9:07:53 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{12 June 2014 . 9:07:55 pm} Squeak4.5-12568.image priorSource: 1143233!----STARTUP----{12 June 2014 . 9:11:24 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotIterative1ThreadSTM under: #'initialize-release'!!CPBMandelbrotBenchmarkSuite methodsFor: 'initialize-release' stamp: 'hh 6/12/2014 21:04' prior: 34695958!benchMandelbrotIterative1ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotIterative2ThreadSTM under: #'initialize-release'!!CPBMandelbrotBenchmarkSuite methodsFor: 'initialize-release' stamp: 'hh 6/12/2014 21:04' prior: 34696173!benchMandelbrotIterative2ThreadSTM
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotRecursive1ThreadSTM under: #'initialize-release'!!CPBMandelbrotBenchmarkSuite methodsFor: 'initialize-release' stamp: 'hh 6/12/2014 21:06' prior: 34696818!benchMandelbrotRecursive1ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculateSTM .
	! !CPBMandelbrotBenchmarkSuite organization classify: #benchMandelbrotRecursive2ThreadSTM under: #'initialize-release'!!CPBMandelbrotBenchmarkSuite methodsFor: 'initialize-release' stamp: 'hh 6/12/2014 21:06' prior: 34697033!benchMandelbrotRecursive2ThreadSTM
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculateSTM .
	! !----QUIT----{12 June 2014 . 9:11:52 pm} Squeak4.5-12568.image priorSource: 1143233!----STARTUP----{12 June 2014 . 9:12:29 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'hh 6/12/2014 21:15' prior: 34687884!createThreadSTM: threadNumber of: threadCount
| semaphore |
semaphore := STMProcess new.
[ | index maxIndex |
	maxIndex := self form width * self form height.
	index := threadNumber.
	[index < maxIndex] whileTrue: [
		self calculateValAt: (self pointForIndex: index).
		index := index + threadCount.
	].
	semaphore signal.
] parallelFork.
^ semaphore.! !----QUIT----{12 June 2014 . 9:15:50 pm} Squeak4.5-12568.image priorSource: 1144996!----STARTUP----{12 June 2014 . 9:19:20 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{12 June 2014 . 9:23:23 pm} Squeak4.5-12568.image priorSource: 1145650!----STARTUP----{19 June 2014 . 10:32:44 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotIterative4ThreadSTM!CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotIterative8ThreadSTM!CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotRecursive4ThreadSTM!CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotRecursive8ThreadSTM!CPBMandelbrotBenchmarkSuite organization removeCategory: #benchmarking!CPBMandelbrotBenchmarkSuite organization renameCategory: #'benchmarking-nonstm' toBe: #benchmarking!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18' prior: 34694138!benchMandelbrotIterative1Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18' prior: 34694354!benchMandelbrotIterative2Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18' prior: 34694570!benchMandelbrotIterative4Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 4;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18' prior: 34694786!benchMandelbrotIterative8Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 8;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18' prior: 34695002!benchMandelbrotRecursive1Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18' prior: 34695218!benchMandelbrotRecursive2Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:18' prior: 34695434!benchMandelbrotRecursive4Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 4;
		reCalculate .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:19' prior: 34695650!benchMandelbrotRecursive8Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 8;
		reCalculate .
	! !CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotRecursive2ThreadSTM!CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotRecursive1ThreadSTM!CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotIterative2ThreadSTM!CPBMandelbrotBenchmarkSuite removeSelector: #benchMandelbrotIterative1ThreadSTM!----SNAPSHOT----{19 June 2014 . 10:38:33 am} Squeak4.5-12568.image priorSource: 1145850!----QUIT----{19 June 2014 . 10:41:10 am} Squeak4.5-12568.image priorSource: 1148554!----STARTUP----{19 June 2014 . 10:41:17 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----SNAPSHOT----{19 June 2014 . 10:41:25 am} Squeak4.5-12568-nonSTM.image priorSource: 1148644!!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:41' prior: 34701088!benchMandelbrotIterative1Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42' prior: 34701297!benchMandelbrotIterative2Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42' prior: 34701506!benchMandelbrotIterative4Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 4;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42' prior: 34701715!benchMandelbrotIterative8Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 8;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42' prior: 34701924!benchMandelbrotRecursive1Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42' prior: 34702133!benchMandelbrotRecursive2Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculateSTM.
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42' prior: 34702342!benchMandelbrotRecursive4Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 4;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42' prior: 34702551!benchMandelbrotRecursive8Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 8;
		reCalculateSTM .
	! !!CPBChameneosBenchmark methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:43' prior: 34266155!benchChameneos
	c1 fork: mp.
	c2 fork: mp.
	c3 fork: mp.
	c4 fork: mp.
	
	c1 wait.
	c2 wait.
	c3 wait.
	c4 wait.
	
	^ c1 meetings + c2 meetings + c3 meetings + c4 meetings! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'hh 6/19/2014 10:43' prior: 34264316!fork: aMeetingPlace
	^ [ self run: aMeetingPlace ] parallelFork! !----SNAPSHOT----{19 June 2014 . 10:45:56 am} Squeak4.5-12568.image priorSource: 1148846!----SNAPSHOT----{19 June 2014 . 10:52:02 am} Squeak4.5-12568.image priorSource: 1151068!----QUIT----{19 June 2014 . 10:52:22 am} Squeak4.5-12568.image priorSource: 1151158!----STARTUP----{19 June 2014 . 10:52:31 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT----{19 June 2014 . 10:53:15 am} Squeak4.5-12568.image priorSource: 1151248!----STARTUP----{19 June 2014 . 11:15:40 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 11:16' prior: 34563733!runCPBAStarBenchmark| writer runner |		[		SPyVM print: (Time millisecondClockValue) asString.runner := (CPBAStarBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.]do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !----QUIT----{19 June 2014 . 11:16:05 am} Squeak4.5-12568.image priorSource: 1151450!----STARTUP----{19 June 2014 . 11:25:16 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 11:25' prior: 34706169!runCPBAStarBenchmark| writer runner |		[		runner := (CPBAStarBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.]do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 11:26' prior: 34706834!runCPBAStarBenchmark| writer runner |		[		runner := (CPBAStarBenchmark) run: 10 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.] on: Errordo: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !----QUIT----{19 June 2014 . 11:26:32 am} Squeak4.5-12568.image priorSource: 1152115!----STARTUP----{19 June 2014 . 12:05:21 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:05' prior: 34707245!runCPBAStarBenchmark| writer runner |		[		runner := (CPBAStarBenchmark) run: 1 . "10"writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.] on: Errordo: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:05' prior: 34687164!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 1. "10"writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true .] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:05' prior: 34510136!runCPBBlowfishSuite| writer runner |runner := (CPBBlowfishSuite) run: 1 . "3"writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:05' prior: 34510424!runCPBChameneosBenchmark| writer runner |		runner := (CPBChameneosBenchmark) run: 1 . "5"writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:05' prior: 34510725!runCPBDeltaBlueBenchmark| writer runner |runner := (CPBDeltaBlueBenchmark) run: 1 . "5"writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:06' prior: 34511025!runCPBMandelbrotBenchmarkSuite| writer runner |		runner := (CPBMandelbrotBenchmarkSuite) run: 1 .writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:06' prior: 34511338!runCPBNBodyBenchmark| writer runner |		runner := (CPBNBodyBenchmark) run: 1 . "20"writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:06' prior: 34511933!runCPBRichardsBenchmark| writer runner |		runner := (CPBRichardsBenchmark) run: 1. "20"writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:06' prior: 34512233!runCPBSplayTreeBenchmark| writer runner |		runner := (CPBSplayTreeBenchmark) run: 1 . "10"writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !----QUIT----{19 June 2014 . 12:06:28 pm} Squeak4.5-12568.image priorSource: 1153149!----QUIT/NOSAVE----{19 June 2014 . 10:09:28 am} Squeak4.5-12568.image priorSource: 1156441!----QUIT/NOSAVE----{19 June 2014 . 10:17:13 am} Squeak4.5-12568.image priorSource: 1156441!----QUIT/NOSAVE----{19 June 2014 . 10:21:19 am} Squeak4.5-12568.image priorSource: 1156441!----QUIT/NOSAVE----{19 June 2014 . 10:26:46 am} Squeak4.5-12568.image priorSource: 1156441!----QUIT/NOSAVE----{19 June 2014 . 10:36:43 am} Squeak4.5-12568.image priorSource: 1156441!----QUIT/NOSAVE----{19 June 2014 . 10:36:56 am} Squeak4.5-12568.image priorSource: 1156441!----STARTUP----{19 June 2014 . 12:37:55 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:38' prior: 34710636!runCPBSplayTreeBenchmark| writer runner |		runner := (CPBSplayTreeBenchmark) run: 10.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:38' prior: 34710317!runCPBRichardsBenchmark| writer runner |		runner := (CPBRichardsBenchmark) run: 20.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:38' prior: 34710003!runCPBNBodyBenchmark| writer runner |		runner := (CPBNBodyBenchmark) run: 20.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:38' prior: 34709354!runCPBDeltaBlueBenchmark| writer runner |runner := (CPBDeltaBlueBenchmark) run: 5.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:38' prior: 34709033!runCPBChameneosBenchmark| writer runner |		runner := (CPBChameneosBenchmark) run: 5.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:38' prior: 34708725!runCPBBlowfishSuite| writer runner |runner := (CPBBlowfishSuite) run: 3.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:38' prior: 34708293!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: 10.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true .] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:38' prior: 34707868!runCPBAStarBenchmark| writer runner |		[		runner := (CPBAStarBenchmark) run: 10.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.] on: Errordo: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/19/2014 12:39' prior: 34712974!runCPBChameneosBenchmark"			runner := (CPBChameneosBenchmark) run: 5.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true."! !----QUIT----{19 June 2014 . 12:39:08 pm} Squeak4.5-12568.image priorSource: 1156441!----STARTUP----{19 June 2014 . 3:31:49 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:32' prior: 34714441!runCPBChameneosBenchmark"	runner := (CPBChameneosBenchmark) run: 5.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true."! !3 // 2!4 // 2!4 \\ 2!4 \\ 1!4 \\ 3!4 \\ 3!4 \\ 2!4 \\ 4!7 \\ 4!7 \\ 4!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34' prior: 34712350!runCPBNBodyBenchmark| writer runner |		runner := (CPBNBodyBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34' prior: 34709674!runCPBMandelbrotBenchmarkSuite| writer runner |		runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34' prior: 34714021!runCPBAStarBenchmark| writer runner |		[		runner := (CPBAStarBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.] on: Errordo: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34' prior: 34713593!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true .] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34' prior: 34713290!runCPBBlowfishSuite| writer runner |runner := (CPBBlowfishSuite) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34' prior: 34712659!runCPBDeltaBlueBenchmark| writer runner |runner := (CPBDeltaBlueBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:35' prior: 34511631!runCPBPolymorphyBenchmark| writer runner |runner := (CPBPolymorphyBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:35' prior: 34712035!runCPBRichardsBenchmark| writer runner |		runner := (CPBRichardsBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:35' prior: 34711718!runCPBSplayTreeBenchmark| writer runner |		runner := (CPBSplayTreeBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !----QUIT----{19 June 2014 . 3:35:49 pm} Squeak4.5-12568.image priorSource: 1160227!----STARTUP----{19 June 2014 . 3:44:37 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!----QUIT----{19 June 2014 . 3:45:29 pm} Squeak4.5-12568.image priorSource: 1163959!----STARTUP----{19 June 2014 . 4:04:33 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!!BlockClosure methodsFor: 'scheduling' stamp: 'pre 6/19/2014 16:05' prior: 17524979!fork	"^ self newProcess resume"	^ self parallelFork! !----QUIT----{19 June 2014 . 4:05:31 pm} Squeak4.5-12568.image priorSource: 1164153!----STARTUP----{19 June 2014 . 5:49:43 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!!BlockClosure methodsFor: 'scheduling' stamp: 'pre 6/19/2014 17:49' prior: 34718865!fork	^ self newProcess resume! !----QUIT----{19 June 2014 . 5:49:52 pm} Squeak4.5-12568.image priorSource: 1164489!----STARTUP----{22 June 2014 . 11:57:42 am} as /home/d059605/mph2014/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{22 June 2014 . 11:57:43 am} Squeak4.5-12568.image priorSource: 1164802!----STARTUP----{22 June 2014 . 11:58 am} as /home/d059605/mph2014/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{22 June 2014 . 11:58 am} Squeak4.5-12568.image priorSource: 1164802!----STARTUP----{22 June 2014 . 11:58:22 am} as /home/d059605/mph2014/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{22 June 2014 . 11:58:23 am} Squeak4.5-12568.image priorSource: 1164802!----QUIT/NOSAVE----{22 June 2014 . 9:58:53 am} Squeak4.5-12568.image priorSource: 1164802!----QUIT/NOSAVE----{22 June 2014 . 9:59:02 am} Squeak4.5-12568.image priorSource: 1164802!----QUIT/NOSAVE----{22 June 2014 . 10:22:44 am} Squeak4.5-12568.image priorSource: 1164802!----STARTUP----{22 June 2014 . 1:25:51 pm} as /home/d059605/mph2014/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{22 June 2014 . 1:25:52 pm} Squeak4.5-12568.image priorSource: 1164802!----STARTUP----{22 June 2014 . 2:07:56 pm} as /home/d059605/mph2014/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{22 June 2014 . 2:07:56 pm} Squeak4.5-12568.image priorSource: 1164802!----QUIT/NOSAVE----{22 June 2014 . 1:50:53 pm} Squeak4.5-12568.image priorSource: 1164802!----QUIT/NOSAVE----{22 June 2014 . 3:07:21 pm} Squeak4.5-12568.image priorSource: 1164802!----STARTUP----{22 June 2014 . 7:22:26 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!!BlockClosure methodsFor: 'STM' stamp: 'pre 6/22/2014 19:24' prior: 33643905!parallelFork		^ (self newSTMProcess) fork; yourself! !----QUIT----{22 June 2014 . 7:24:58 pm} Squeak4.5-12568.image priorSource: 1164802!----STARTUP----{22 June 2014 . 7:25:12 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-ParallelSum'!SMarkSuite subclass: #CPBParallelSumBenchmarkSuite	instanceVariableNames: 'mandelbrotMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-ParallelSum'!!CPBParallelSumBenchmarkSuite methodsFor: 'no messages' stamp: 'pre 6/22/2014 19:29'!benchStmParallel1Thread10000000		| num threads max start localSums |		num := 1.	max := 10000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29'!benchStmParallel2Thread10000000		| num threads max start localSums |		num := 2.	max := 10000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29'!benchStmParallel4Thread10000000		| num threads max start localSums |		num := 2.	max := 10000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29' prior: 34723430!benchStmParallel4Thread10000000		| num threads max start localSums |		num := 4.	max := 10000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29'!benchStmParallel8Thread10000000		| num threads max start localSums |		num := 4.	max := 10000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29' prior: 34725344!benchStmParallel8Thread10000000		| num threads max start localSums |		num := 8.	max := 10000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29'!benchStmParallel16Thread10000000		| num threads max start localSums |		num := 16.	max := 10000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29'!benchStmParallel16Thread1000000000		| num threads max start localSums |		num := 16.	max := 1000000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29'!benchStmParallel8Thread1000000000		| num threads max start localSums |		num := 8.	max := 1000000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29'!benchStmParallel4Thread1000000000		| num threads max start localSums |		num := 4.	max := 1000000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:29'!benchStmParallel2Thread1000000000		| num threads max start localSums |		num := 2.	max := 1000000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:30'!benchStmParallel1Thread1000000000		| num threads max start localSums |		num := 1.	max := 1000000000.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/22/2014 19:30'!runCPBParallelSum| writer runner |runner := (CPBBlowfishSuite) run.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/22/2014 19:30' prior: 34732951!runCPBParallelSum| writer runner |runner := (CPBBlowfishSuite) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true.! !----SNAPSHOT----{22 June 2014 . 7:30:53 pm} Squeak4.5-12568.image priorSource: 1166552!!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:31' prior: 34732023!benchStmParallel1Thread1000000000		| num threads max start localSums |		num := 1.	max := 1000000000.	"SPyVM print: ('Threads:', (num printString))."	"SPyVM print: ('Items/Thread:', (max printString))."		localSums := Array new: num.		start := Time now asNanoSeconds.			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^  localSums sum printString! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:31' prior: 34733676!benchStmParallel1Thread1000000000		| num threads max localSums |		num := 1.	max := 1000000000.	"SPyVM print: ('Threads:', (num printString))."	"SPyVM print: ('Items/Thread:', (max printString))."		localSums := Array new: num.		"start := Time now asNanoSeconds."			threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].	"SPyVM print: '[squeak] milliseconds inside method:'."	"SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString."	"^  localSums sum printString"! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:32' prior: 34734649!benchStmParallel1Thread1000000000		| num threads max localSums |		num := 1.	max := 1000000000.		localSums := Array new: num.		threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:33' prior: 34735624!benchStmParallel1Thread1000000000		| num threads max localSums |		num := 1.	max := 1000000000.		localSums := Array new: num.		threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:33' prior: 34736290!benchStmParallel1Thread1000000000		| num threads max localSums |		num := 1.	max := 1000000000.		self class sumWithThreads: num andNumber: max.		localSums := Array new: num.		threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:33' prior: 34736956!benchStmParallel1Thread1000000000		| num max |		num := 1.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite class methodsFor: 'no messages' stamp: 'pre 6/22/2014 19:34'!runWith: num andNumber: max            | localSums threads |localSums := Array new: num.		threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].! !!CPBParallelSumBenchmarkSuite class methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:34'!sumWithThreads: num andNumber: max            | localSums threads |localSums := Array new: num.		threads := (1 to: num-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((self-num-max) to: self-num) do: [ :k | 				 sum := sum + k. ].		localSums at: num put: sum.		] parallelFork.	threads do: [:t | t wait].! !CPBParallelSumBenchmarkSuite class removeSelector: #runWith:andNumber:!!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34727258!benchStmParallel16Thread10000000		| num max |		num := 16.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34728209!benchStmParallel16Thread1000000000		| num max |		num := 16.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34721532!benchStmParallel1Thread10000000		| num max |		num := 1.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34722481!benchStmParallel2Thread10000000		| num max |		num := 2.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34731070!benchStmParallel2Thread1000000000		| num max |		num := 2.	max := 1000000000.			self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34724395!benchStmParallel4Thread10000000		| num max |		num := 4.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34740444!benchStmParallel4Thread10000000		| num max |		num := 4.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34730117!benchStmParallel4Thread1000000000		| num max |		num := 4.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:36' prior: 34726309!benchStmParallel8Thread10000000		| num max |		num := 8.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:36' prior: 34729164!benchStmParallel8Thread1000000000		| num max |		num := 8.	max := 1000000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:36' prior: 34741414!benchStmParallel8Thread1000000000		| num max |		num := 8.	max := 1000000000.	self class sumWithThreads: num andNumber: max.! !----SNAPSHOT----{22 June 2014 . 7:36:53 pm} Squeak4.5-12568.image priorSource: 1179044!----QUIT/NOSAVE----{22 June 2014 . 7:37:10 pm} Squeak4.5-12568.image priorSource: 1187360!----STARTUP----{22 June 2014 . 7:37:28 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/22/2014 19:37' prior: 34733250!runCPBParallelSum| writer runner |runner := (CPBParallelSumBenchmarkSuite) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true.! !----SNAPSHOT----{22 June 2014 . 7:37:52 pm} Squeak4.5-12568.image priorSource: 1187360!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/22/2014 19:38' prior: 34742168!runCPBParallelSum		| writer runner |		runner := (CPBParallelSumBenchmarkSuite) run: self \\ 100.	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'.	Smalltalk snapshot: false andQuit: true.! !----SNAPSHOT----{22 June 2014 . 7:39:16 pm} Squeak4.5-12568.image priorSource: 1187974!----QUIT----{22 June 2014 . 7:39:43 pm} Squeak4.5-12568.image priorSource: 1188396!----STARTUP----{22 June 2014 . 7:51:24 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!!CPBParallelSumBenchmarkSuite class methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:52' prior: 34738516!sumWithThreads: threadNumber andNumber: sumNumber            | localSums threads max |	localSums := Array new: threadNumber.		max := sumNumber // threadNumber.		threads := (1 to: threadNumber-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((sumNumber-max) to: sumNumber) do: [ :k | 				 sum := sum + k. ].		localSums at: threadNumber put: sum.		] parallelFork.	threads do: [:t | t wait].! !!CPBParallelSumBenchmarkSuite class methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:53' prior: 34743228!sumWithThreads: threadNumber andNumber: sumNumber            | localSums threads max |	localSums := Array new: threadNumber.		max := sumNumber // threadNumber.		threads := (1 to: threadNumber-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] fork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((sumNumber-max) to: sumNumber) do: [ :k | 				 sum := sum + k. ].		localSums at: threadNumber put: sum.		] fork.	threads do: [:t | t wait].! !!CPBParallelSumBenchmarkSuite class methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:53' prior: 34743954!sumWithThreads: threadNumber andNumber: sumNumber            | localSums threads max |	localSums := Array new: threadNumber.		max := sumNumber // threadNumber.		threads := (1 to: threadNumber-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] fork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((sumNumber-max) to: sumNumber) do: [ :k | 				 sum := sum + k. ].		localSums at: threadNumber put: sum.		] fork.	"threads do: [:t | t wait]."! !CPBParallelSumBenchmarkSuite sumWithThreads: 2 andNumber: 10000!CPBParallelSumBenchmarkSuite sumWithThreads: 2 andNumber: 100000!!CPBParallelSumBenchmarkSuite class methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:54' prior: 34744664!sumWithThreads: threadNumber andNumber: sumNumber            | localSums threads max |	localSums := Array new: threadNumber.		max := sumNumber // threadNumber.		threads := (1 to: threadNumber-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((sumNumber-max) to: sumNumber) do: [ :k | 				 sum := sum + k. ].		localSums at: threadNumber put: sum.		] parallelFork.	threads do: [:t | t wait].! !----QUIT----{22 June 2014 . 7:54:14 pm} Squeak4.5-12568.image priorSource: 1188485!----STARTUP----{22 June 2014 . 7:55:50 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!----QUIT/NOSAVE----{22 June 2014 . 7:56:41 pm} Squeak4.5-12568.image priorSource: 1191686!----STARTUP----{22 June 2014 . 8:30:08 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:30' prior: 34739467!benchStmParallel16Thread1000000000		| num max |		num := 16.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:30' prior: 34737672!benchStmParallel1Thread1000000000		| num max |		num := 1.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:30' prior: 34740197!benchStmParallel2Thread1000000000		| num max |		num := 2.	max := 10000000.			self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:30' prior: 34740926!benchStmParallel4Thread1000000000		| num max |		num := 4.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:30' prior: 34741659!benchStmParallel8Thread1000000000		| num max |		num := 8.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !----QUIT----{22 June 2014 . 8:30:40 pm} Squeak4.5-12568.image priorSource: 1191686!----STARTUP----{22 June 2014 . 8:30:47 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel16Thread1000000000!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel1Thread1000000000!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel2Thread1000000000!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel4Thread1000000000!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel8Thread1000000000!!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:31'!benchStmParallel1Thread100000		| num max |		num := 1.	max := 100000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:31' prior: 34739715!benchStmParallel1Thread10000000		| num max |		num := 1.	max := 100000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:31' prior: 34748669!benchStmParallel1Thread10000000		| num max |		num := 1.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:31'!benchStmParallel16Thread100000		| num max |		num := 16.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:31' prior: 34749131!benchStmParallel16Thread100000		| num max |		num := 16.	max := 100000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:31' prior: 34748433!benchStmParallel1Thread100000		| num max |		num := 1.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32' prior: 34749613!benchStmParallel1Thread100000		| num max |		num := 1.	max := 100000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32'!benchStmParallel2Thread100000		| num max |		num := 2.	max := 100000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32'!benchStmParallel4Thread100000		| num max |		num := 4.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32' prior: 34750293!benchStmParallel4Thread100000		| num max |		num := 4.	max := 100000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32'!benchStmParallel8Thread100000		| num max |		num := 8.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32' prior: 34750751!benchStmParallel8Thread100000		| num max |		num := 8.	max := 100000.		self class sumWithThreads: num andNumber: max.! !----QUIT----{22 June 2014 . 8:32:57 pm} Squeak4.5-12568.image priorSource: 1193301!----STARTUP----{22 June 2014 . 8:33:15 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!'From Squeak4.4 of 28 April 2013 [latest update: #12627] on 22 June 2014 at 8:32:54 pm'!!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:31' prior: 34749373!benchStmParallel16Thread100000		| num max |		num := 16.	max := 100000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34739223!benchStmParallel16Thread10000000		| num max |		num := 16.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32' prior: 34749851!benchStmParallel1Thread100000		| num max |		num := 1.	max := 100000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:31' prior: 34748907!benchStmParallel1Thread10000000		| num max |		num := 1.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32' prior: 34750071!benchStmParallel2Thread100000		| num max |		num := 2.	max := 100000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34739955!benchStmParallel2Thread10000000		| num max |		num := 2.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32' prior: 34750531!benchStmParallel4Thread100000		| num max |		num := 4.	max := 100000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34740686!benchStmParallel4Thread10000000		| num max |		num := 4.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:32' prior: 34750991!benchStmParallel8Thread100000		| num max |		num := 8.	max := 100000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:36' prior: 34741172!benchStmParallel8Thread10000000		| num max |		num := 8.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !----End fileIn of C:\Users\C5187727\Desktop\work\cogwin\CPBParallelSumBenchmarkSuite--- all --.st----!----QUIT----{22 June 2014 . 8:33:29 pm} Squeak4.5-12568.image priorSource: 1196686!----STARTUP----{22 June 2014 . 8:36:20 pm} as C:\Users\C5187727\Desktop\work\cogwin\Squeak4.5-12568.image!'From Squeak4.4 of 28 April 2013 [latest update: #12627] on 22 June 2014 at 8:36:11 pm'!!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34751753!benchStmParallel16Thread10000000		| num max |		num := 16.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:35'!benchStmParallel16Thread1000000000		| num max |		num := 16.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34752233!benchStmParallel1Thread10000000		| num max |		num := 1.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:35'!benchStmParallel1Thread1000000000		| num max |		num := 1.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34752711!benchStmParallel2Thread10000000		| num max |		num := 2.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:35'!benchStmParallel2Thread1000000000		| num max |		num := 2.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35' prior: 34753189!benchStmParallel4Thread10000000		| num max |		num := 4.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:35'!benchStmParallel4Thread1000000000		| num max |		num := 4.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:36' prior: 34753667!benchStmParallel8Thread10000000		| num max |		num := 8.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:36'!benchStmParallel8Thread1000000000		| num max |		num := 8.	max := 1000000000.				self class sumWithThreads: num andNumber: max.! !----End fileIn of C:\Users\C5187727\Desktop\work\cogwin\CPBParallelSumBenchmarkSuite--- all --.st----!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel16Thread100000!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel1Thread100000!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel2Thread100000!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel4Thread100000!CPBParallelSumBenchmarkSuite removeSelector: #benchStmParallel8Thread100000!----QUIT----{22 June 2014 . 8:37 pm} Squeak4.5-12568.image priorSource: 1199470!----QUIT/NOSAVE----{23 June 2014 . 6:29:35 am} Squeak4.5-12568.image priorSource: 1202608!----STARTUP----{26 June 2014 . 4:48:38 pm} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!'From Squeak4.4 of 28 April 2013 [latest update: #12627] on 26 June 2014 at 4:24:19 pm'!Object subclass: #OSLock	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #OSLock	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!OSLock methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:09'!internalLock		<primitive: 792>	SPyVM print: '* OS Lock could not be locked *' , Character cr.	self primitiveFailed.	self resume! !!OSLock methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:09'!internalRelease	<primitive: 793>	SPyVM print: '* OS Lock could not be released *' , Character cr.	self primitiveFailed.	self resume! !!OSLock methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:09'!lock	self internalLock	! !!OSLock methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:09'!release	self internalRelease! !----End fileIn of C:\Users\C5187727\Downloads\OSLock.st----!'From Squeak4.4 of 28 April 2013 [latest update: #12627] on 26 June 2014 at 2:51:52 pm'!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 14:43'!osLockTest	| lock process1 process2 process2lock |		lock := OSLock new.	lock lock.		process2lock := OSLock new.	process2lock lock.		process1 := [ SPyVM print: 'First process start'. 	  lock lock.	  process2lock release.	  SPyVM print: 'First process after lock'.	  lock release. ] parallelFork .	process2 := [ SPyVM print: 'Second process start'.	  process2lock lock.	  lock lock.	  SPyVM print: 'Second process after lock'.	  process2lock release.	  lock release. ] parallelFork .	SPyVM print: 'Processes initialized.'.		lock release.		process1 wait.	process2 wait.! !----End fileIn of C:\Users\C5187727\Downloads\Integer-osLockTest.st----!'From Squeak4.4 of 28 April 2013 [latest update: #12627] on 26 June 2014 at 4:24:36 pm'!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 15:59'!osLockEasyTest	| lock1 |		lock1 := OSLock new.	lock1 lock.	SPyVM print: 'Survived locking.'.	lock1 release.	SPyVM print: 'Survived releasing.'.		^ self! !----End fileIn of C:\Users\C5187727\Downloads\Integer-osLockEasyTest.st----!----QUIT----{26 June 2014 . 4:49:08 pm} Squeak4.5-12568.image priorSource: 1202608!----STARTUP----{26 June 2014 . 4:50:51 pm} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:51' prior: 34699728!createThreadSTM: threadNumber of: threadCount
^ [ | index maxIndex |
	maxIndex := self form width * self form height.
	index := threadNumber.
	[index < maxIndex] whileTrue: [
		self calculateValAt: (self pointForIndex: index).
		index := index + threadCount.
	].
] parallelFork! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:52' prior: 34267593!reachedBy: chameleon
	 [
        first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:52' prior: 34760271!reachedBy: chameleon
	 [ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:52' prior: 34267068!initialize

	total := 0! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:52' prior: 34705434!fork: aMeetingPlace
	semaphore := [ self run: aMeetingPlace ] parallelFork! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:53' prior: 34264452!initialize
	meetings := 0.
      waitingForPair := Semaphore new.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:53' prior: 34761100!initialize
	meetings := 0.
      waitingForPair := OSLock new.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:53' prior: 34264171!fade
	color := #faded.
	waitingForPair release.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:53' prior: 34264732!met: other
	| newColor |
	meetings := meetings + 1.
	color == #red ifTrue: [
		newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].
      color == #yellow ifTrue: [
      	newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].
      color == #blue ifTrue: [
      	newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].
      color := newColor.
      waitingForPair release! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:53' prior: 34265225!run: meetingPlace
    [ color == #faded ] whileFalse: [
        meetingPlace reachedBy: self.
        waitingForPair lock ]! !----SNAPSHOT----{26 June 2014 . 4:53:47 pm} Squeak4.5-12568.image priorSource: 1205159!----QUIT----{26 June 2014 . 4:53:49 pm} Squeak4.5-12568.image priorSource: 1207773!----STARTUP----{26 June 2014 . 4:57:35 pm} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 17:00' prior: 34715650!runCPBMandelbrotBenchmarkSuite	| writer runner |			runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100.	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'. 	Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 17:01' prior: 34714940!runCPBChameneosBenchmark| runner writer |runner := (CPBChameneosBenchmark) run: 5.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !----QUIT----{26 June 2014 . 5:02:06 pm} Squeak4.5-12568.image priorSource: 1207862!----STARTUP----{26 June 2014 . 5:03:54 pm} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 17:04' prior: 34762925!runCPBChameneosBenchmark| runner writer |runner := (CPBChameneosBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !----QUIT----{26 June 2014 . 5:04:44 pm} Squeak4.5-12568.image priorSource: 1208723!----STARTUP----{26 June 2014 . 5:08:38 pm} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!Matrix subclass: #CPBMandelbrotField	instanceVariableNames: 'form mode threadCount depth imageBounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBMandelbrotField methodsFor: 'nil' stamp: 'pre 6/26/2014 17:11'!calculateWithThreadsSTM: anInteger| semaphores |	semaphores := OrderedCollection new.	1 to: anInteger do:[ :i |			semaphores add: (self createThreadSTM: i of: anInteger).		].	semaphores do: [:s| s wait].! !!CPBMandelbrotField methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 17:11' prior: 34764153!calculateWithThreadsSTM: anInteger	| semaphores |	semaphores := OrderedCollection new.	1 to: anInteger do:[ :i |			semaphores add: (self createThreadSTM: i of: anInteger).		].	semaphores do: [:s| s wait].! !!CPBMandelbrotField methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 17:11'!createThreadSTM: threadNumber of: threadCount^ [ | index maxIndex |	maxIndex := self form width * self form height.	index := threadNumber.	[index < maxIndex] whileTrue: [		self calculateValAt: (self pointForIndex: index).		index := index + threadCount.	].] parallelFork! !!CPBMandelbrotField methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 17:11' prior: 34764764!createThreadSTM: threadNumber of: threadCount^ [ | index maxIndex |	maxIndex := self form width * self form height.	index := threadNumber.	[index < maxIndex] whileTrue: [		self calculateValAt: (self pointForIndex: index).		index := index + threadCount.	] ] parallelFork! !!CPBMandelbrotField methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 17:11' prior: 34765145!createThreadSTM: threadNumber of: threadCount	^ [ | index maxIndex |	maxIndex := self form width * self form height.	index := threadNumber.	[index < maxIndex] whileTrue: [		self calculateValAt: (self pointForIndex: index).		index := index + threadCount.	] ] parallelFork! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 17:12' prior: 34040454!drawOn: aCanvas 
	"super drawOn: aCanvas.
	aCanvas drawImage: self form at: self topLeft"! !----QUIT----{26 June 2014 . 5:12:35 pm} Squeak4.5-12568.image priorSource: 1209250!----STARTUP----{3 July 2014 . 10:11:55 am} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!----QUIT/NOSAVE----{3 July 2014 . 10:16:13 am} Squeak4.5-12568.image priorSource: 1211567!----STARTUP----{3 July 2014 . 10:19:31 am} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!!CPBChameneosBenchmark methodsFor: 'benchmarking' stamp: 'pre 7/3/2014 10:25' prior: 34705166!benchChameneos[
	c1 fork: mp.
	c2 fork: mp.
	c3 fork: mp.
	c4 fork: mp.
	
	c1 wait.
	c2 wait.
	c3 wait.
	c4 wait.
	
	^ c1 meetings + c2 meetings + c3 meetings + c4 meetings] on: Error do: [ :st | SPyVM print: st messageText. SPyVM print: st signalerContext longStack.]! !----QUIT----{3 July 2014 . 10:25:09 am} Squeak4.5-12568.image priorSource: 1211567!----STARTUP----{3 July 2014 . 10:29:31 am} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:33' prior: 34760928!fork: aMeetingPlace	SPyVM print: 'Chameneos started'.
	semaphore := [ self run: aMeetingPlace ] parallelFork! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:33' prior: 34762079!run: meetingPlace
    [ color == #faded ] whileFalse: [	  SPyVM print: 'Chameneos goes to meeting place'.
        meetingPlace reachedBy: self.
        waitingForPair lock ]! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:34' prior: 34760543!reachedBy: chameleon
	 [ SPyVM print: 'A Chameneos reached the meeting place'. 		first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:34' prior: 34761568!met: other
	| newColor |
	meetings := meetings + 1.
	color == #red ifTrue: [
		newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].
      color == #yellow ifTrue: [
      	newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].
      color == #blue ifTrue: [
      	newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].
      color := newColor.      SPyVM print: 'Chameneos met another one and releases lock'.
      waitingForPair release! !----QUIT----{3 July 2014 . 10:35:02 am} Squeak4.5-12568.image priorSource: 1212345!----STARTUP----{3 July 2014 . 10:35:52 am} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:36' prior: 34767553!reachedBy: chameleon
	SPyVM print: 'A Chameneos reached the meeting place'. 	[ SPyVM print: 'A Chameneos can meet'. 		first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic! !----QUIT----{3 July 2014 . 10:36:59 am} Squeak4.5-12568.image priorSource: 1213922!----STARTUP----{3 July 2014 . 10:37:09 am} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!----QUIT/NOSAVE----{3 July 2014 . 10:37:19 am} Squeak4.5-12568.image priorSource: 1214482!----STARTUP----{3 July 2014 . 10:38:46 am} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:42' prior: 34768652!reachedBy: chameleon
	SPyVM print: 'A Chameneos reached the meeting place'. 	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.	SPyVM print: 'A Chameneos can meet'.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:43' prior: 34767870!met: other
	| newColor |
	meetings := meetings + 1.
	color == #red ifTrue: [
		newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].
      color == #yellow ifTrue: [
      	newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].
      color == #blue ifTrue: [
      	newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].
      color := newColor.
      waitingForPair release! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:43' prior: 34767279!run: meetingPlace
    [ color == #faded ] whileFalse: [	  SPyVM print: 'Chameneos goes to meeting place'.
        meetingPlace reachedBy: self.
        waitingForPair lock.        SPyVM print: 'Chameneos met another one and releases lock'. ]! !----QUIT----{3 July 2014 . 10:43:24 am} Squeak4.5-12568.image priorSource: 1214482!----STARTUP----{3 July 2014 . 10:45:15 am} as C:\Users\C5187727\Desktop\work\cogwin\images\Squeak4.5-12568.image!!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:47' prior: 34767072!fork: aMeetingPlace	SPyVM print: 'Chameneos started' , self color.
	semaphore := [ self run: aMeetingPlace ] parallelFork! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:47' prior: 34770288!run: meetingPlace
    [ color == #faded ] whileFalse: [	  SPyVM print: 'Chameneos goes to meeting place' , self color.
        meetingPlace reachedBy: self.
        waitingForPair lock.        SPyVM print: 'Chameneos met another one and releases lock' , self color. ]! !----SNAPSHOT----{3 July 2014 . 10:48:04 am} Squeak4.5-12568.image priorSource: 1216102!!CPBChameneosBenchmark methodsFor: 'initialize-release' stamp: 'pre 7/3/2014 10:49' prior: 34266415!setUp
	nMeetings := 500000.
	c1 := CPBChameneos color: #blue.
	c2 := CPBChameneos color: #red.
	c3 := CPBChameneos color: #yellow.
	c4 := CPBChameneos color: #green.
	mp := CPBMeetingPlace forMeetings: nMeetings.! !----SNAPSHOT----{3 July 2014 . 10:49:51 am} Squeak4.5-12568.image priorSource: 1216889!!CPBChameneosBenchmark methodsFor: 'initialize-release' stamp: 'pre 7/3/2014 10:51' prior: 34771512!setUp
	nMeetings := 500000.
	c1 := CPBChameneos color: #blue.
	c2 := CPBChameneos color: #red.
	c3 := CPBChameneos color: #yellow.
	c4 := CPBChameneos color: #blue.
	mp := CPBMeetingPlace forMeetings: nMeetings.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:55' prior: 34769420!reachedBy: chameleon
	SPyVM print: 'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: ' , first color. 	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.	SPyVM print: 'A Chameneos can meet'.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:55' prior: 34772229!reachedBy: chameleon
	SPyVM print: 'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: ' , first color. 	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.	SPyVM print: 'A Chameneos was in the meeting place and first is now: ' , first color.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:57' prior: 34772652!reachedBy: chameleon
	SPyVM print: 'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: ' , first color. 	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.	SPyVM print: 'A Chameneos was in the meeting place and first is now: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]) .! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:57' prior: 34773124!reachedBy: chameleon
	SPyVM print: 'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]).	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.	SPyVM print: 'A Chameneos was in the meeting place and first is now: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]) .! !----SNAPSHOT----{3 July 2014 . 10:57:20 am} Squeak4.5-12568.image priorSource: 1217295!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:59' prior: 34773637!reachedBy: chameleon
	SPyVM print: 'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '. ", (first ifNil: [ first color ] ifNotNil: [ 'none' ])."	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.	SPyVM print: 'A Chameneos was in the meeting place and first is now: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]) .! !----SNAPSHOT----{3 July 2014 . 10:59:48 am} Squeak4.5-12568.image priorSource: 1219660!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:01' prior: 34774278!reachedBy: chameleon
	SPyVM print: 'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '. ", (first ifNil: [ first color ] ifNotNil: [ 'none' ])."	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.	SPyVM print: 'A Chameneos was in the meeting place and first is now: '. ", (first ifNil: [ first color ] ifNotNil: [ 'none' ]) ."! !----SNAPSHOT----{3 July 2014 . 11:01:31 am} Squeak4.5-12568.image priorSource: 1220304!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:03' prior: 34774922!reachedBy: chameleon
	| tmpString |	SPyVM print: 'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '. ", (first ifNil: [ first color ] ifNotNil: [ 'none' ])."	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]) . 	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:03' prior: 34775569!reachedBy: chameleon
	| tmpString |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: ', (first ifNil: [ first color ] ifNotNil: [ 'none' ]).	SPyVM print:	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]) . 	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:03' prior: 34776171!reachedBy: chameleon
	| tmpString |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: ', (first ifNil: [ first color ] ifNotNil: [ 'none' ]).	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]) . 	SPyVM print: tmpString.! !----SNAPSHOT----{3 July 2014 . 11:03:32 am} Squeak4.5-12568.image priorSource: 1220951!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:05' prior: 34776786!reachedBy: chameleon
	| tmpString tmpsString |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first ifNil: [ tmpsString := tmpString , first color. ] ifNotNil: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]) . 	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:05' prior: 34777501!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first ifNil: [ tmpString := tmpString , first color. ] ifNotNil: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' , (first ifNil: [ first color ] ifNotNil: [ 'none' ]) . 	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:05' prior: 34778191!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first ifNil: [ tmpString := tmpString , first color. ] ifNotNil: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first ifNil: [ tmpString := tmpString , first color. ] ifNotNil: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.! !----SNAPSHOT----{3 July 2014 . 11:05:24 am} Squeak4.5-12568.image priorSource: 1222883!----SNAPSHOT----{3 July 2014 . 11:07:04 am} Squeak4.5-12568.image priorSource: 1225076!!ProtoObject methodsFor: 'testing' stamp: 'pre 7/3/2014 11:08' prior: 34327962!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !----SNAPSHOT----{3 July 2014 . 11:08:28 am} Squeak4.5-12568.image priorSource: 1225165!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:10' prior: 34778870!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.	(first ifNil: [ tmpString := tmpString , first color. ] ifNotNil: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first ifNil: [ tmpString := tmpString , first color. ] ifNotNil: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.! !----SNAPSHOT----{3 July 2014 . 11:10:49 am} Squeak4.5-12568.image priorSource: 1225454!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:12' prior: 34780072!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.	(first isNil ifTrue: [ tmpString := tmpString , first color. ] ifFalse: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first ifNil: [ tmpString := tmpString , first color. ] ifNotNil: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:12' prior: 34780921!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.	(first isNil ifTrue: [ tmpString := tmpString , first color. ] ifFalse: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil ifTrue: [ tmpString := tmpString , first color. ] ifFalse: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.! !!BlockContext methodsFor: 'evaluating' stamp: 'pre 7/3/2014 11:13' prior: 34604979!cull: firstArg	"Activate the receiver, with one or zero arguments."		self numArgs >= 1 ifTrue: [ ^self value: firstArg ].	^self value! !!Symbol methodsFor: 'evaluating' stamp: 'pre 7/3/2014 11:13' prior: 34743077!cull: anObject 	^anObject perform: self! !----SNAPSHOT----{3 July 2014 . 11:14:04 am} Squeak4.5-12568.image priorSource: 1226303!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:17' prior: 34781687!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.	(first isNil)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil ifTrue: [ tmpString := tmpString , first color. ] ifFalse: [ tmpString := tmpString , 'none' ]).	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:17' prior: 34782896!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.	(first isNil)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:17' prior: 34783672!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:17' prior: 34784452!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.! !----SNAPSHOT----{3 July 2014 . 11:17:51 am} Squeak4.5-12568.image priorSource: 1228278!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:18' prior: 34785236!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.! !----SNAPSHOT----{3 July 2014 . 11:18:53 am} Squeak4.5-12568.image priorSource: 1231495!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:19' prior: 34786113!reachedBy: chameleon
	| tmpString  |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.		[ first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:22' prior: 34786965!reachedBy: chameleon
	| tmpString  |		[tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.		 first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] .      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString. ] atomic.! !----SNAPSHOT----{3 July 2014 . 11:22:50 am} Squeak4.5-12568.image priorSource: 1232347!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:25' prior: 34787730!reachedBy: chameleon
	| tmpString position |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.		[ first isNil
            ifTrue: [ first := chameleon. position := 'first' ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second' ] .] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString. ! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:25' prior: 34788586!reachedBy: chameleon
	| tmpString position |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.		[ first isNil
            ifTrue: [ first := chameleon. position := 'first' ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second' ] .] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString , ' ' , position. ! !----SNAPSHOT----{3 July 2014 . 11:25:30 am} Squeak4.5-12568.image priorSource: 1233968!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:27' prior: 34789404!reachedBy: chameleon
	| tmpString position |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.		[ first isNil
            ifTrue: [ first := chameleon. position := 'first' ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second' ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString , ' ' , position. ! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:28' prior: 34790328!reachedBy: chameleon
	| tmpString position |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	position := 'initial value'.	[ first isNil
            ifTrue: [ first := chameleon. position := 'first' ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second' ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString , ' ' , position. ! !----SNAPSHOT----{3 July 2014 . 11:28:33 am} Squeak4.5-12568.image priorSource: 1235710!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:28' prior: 34791162!reachedBy: chameleon
	| tmpString position num |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	position := 'initial value'.	num := 42.	[ first isNil
            ifTrue: [ first := chameleon. position := 'first' ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second' ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString , ' ' , position. ! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:29' prior: 34792113!reachedBy: chameleon
	| tmpString position num |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	position := 'initial value'.	num := 42.	[ first isNil
            ifTrue: [ first := chameleon. position := 'first'. num := 1. ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second' ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString , ' ' , position. ! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:29' prior: 34792991!reachedBy: chameleon
	| tmpString position num |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	position := 'initial value'.	num := 42.	[ first isNil
            ifTrue: [ first := chameleon. position := 'first'. num := 1. ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second'. num := 2. ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString , ' ' , position. ! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 11:29' prior: 34793880!reachedBy: chameleon
	| tmpString position num |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	position := 'initial value'.	num := 42.	[ first isNil
            ifTrue: [ first := chameleon. position := 'first'. num := 1. ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second'. num := 2. ] ] atomic.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString , ' ' , position , ' ' , num asString. ! !----SNAPSHOT----{3 July 2014 . 11:32:54 am} Squeak4.5-12568.image priorSource: 1237495!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 14:45' prior: 34794780!reachedBy: chameleon
	| tmpString position num |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	(first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString.	position := 'initial value'.	num := 42.	[ first isNil
            ifTrue: [ first := chameleon. position := 'first'. num := 1. ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second'. num := 2. ] ] atomic value.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .       (first isNil not)		ifTrue: [ tmpString := tmpString , first color. ]		ifFalse: [ tmpString := tmpString , 'none' ].	SPyVM print: tmpString , ' ' , position , ' ' , num asString. ! !----SNAPSHOT----{3 July 2014 . 2:46:06 pm} Squeak4.5-12568.image priorSource: 1241172!----STARTUP----{3 July 2014 . 3:24:52 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'hh 7/3/2014 15:25' prior: 34795790!reachedBy: chameleon
	| tmpString position num |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.		[ first isNil
            ifTrue: [ first := chameleon. position := 'first'. num := 1. ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. position := 'second'. num := 2. ] ] atomic value.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .  	SPyVM print: tmpString. ! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'hh 7/3/2014 15:25' prior: 34796930!reachedBy: chameleon
	| tmpString position |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.		[ first isNil
            ifTrue: [ first := chameleon. position := 'first' ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. ] ] atomic value.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .  	SPyVM print: tmpString. ! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'hh 7/3/2014 15:26' prior: 34797536!reachedBy: chameleon
	| tmpString |		tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString.		[ first isNil
            ifTrue: [ first := chameleon. ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. ] ] atomic value.      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .  	SPyVM print: tmpString. ! !----QUIT----{3 July 2014 . 3:26:09 pm} Squeak4.5-benchmarks.image priorSource: 1242188!----STARTUP----{3 July 2014 . 3:27:16 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{3 July 2014 . 3:27:30 pm} Squeak4.5-benchmarks.image priorSource: 1244097!----STARTUP----{3 July 2014 . 3:40:04 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{3 July 2014 . 3:40:15 pm} Squeak4.5-benchmarks.image priorSource: 1244097!----STARTUP----{3 July 2014 . 5:06:30 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{3 July 2014 . 5:06:40 pm} Squeak4.5-benchmarks.image priorSource: 1244097!----STARTUP----{10 July 2014 . 10:53:02 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT----{10 July 2014 . 10:53:26 am} Squeak4.5-benchmarks.image priorSource: 1244097!----STARTUP----{10 July 2014 . 11:40:06 am} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 11:41'!runPrintTest| |		[		SPyVM print: 'aso'.]do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !----QUIT----{10 July 2014 . 11:41:53 am} Squeak4.5-benchmarks.image priorSource: 1244980!----STARTUP----{10 July 2014 . 12:12:01 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:13' prior: 34799700!runPrintTest| |		FileStream newFileNamed: 'bar.txt'.[		SPyVM print: 'aso'.]do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !FileStream newFileNamed: 'bar.txt'.!----QUIT----{10 July 2014 . 12:13:46 pm} Squeak4.5-benchmarks.image priorSource: 1245411!----STARTUP----{10 July 2014 . 12:17:12 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:17' prior: 34800147!runPrintTestFileStream newFileNamed: 'bar.txt'.SPyVM print: 'aso'.! !----QUIT----{10 July 2014 . 12:17:29 pm} Squeak4.5-benchmarks.image priorSource: 1245933!----STARTUP----{10 July 2014 . 12:17:52 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:13' prior: 34800669!runPrintTest| |		FileStream newFileNamed: 'bar.txt'.[		SPyVM print: 'aso'.]do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:18' prior: 34801045!runPrintTest| |		FileStream newFileNamed: 'bar.txt'.[SPyVM print: 'aso'.]do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:19' prior: 34801310!runPrintTest| |		FileStream newFileNamed: 'bar.txt'.[SPyVM print: 'aso'.] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:19' prior: 34801572!runPrintTest| |		FileStream newFileNamed: 'bar.txt'.[SPyVM print: 'aso'.] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !----QUIT----{10 July 2014 . 12:19:16 pm} Squeak4.5-benchmarks.image priorSource: 1246309!----STARTUP----{10 July 2014 . 12:20:27 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:21' prior: 34801843!runPrintTest|s |		[SPyVM print: 'aso'.] on: Error do: [ :exc | 	s := FileStream newFileNamed: 'eror.txt'.	s nextPutAll: (exc messageText).	s nextPutAll: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:21' prior: 34802332!runPrintTest|s |		[SPyVM print: 'aso'.] on: Error do: [ :exc | 	s := FileStream newFileNamed: 'error.txt'.	s nextPutAll: (exc messageText).	s nextPutAll: (exc signalerContext longStack).].! !----QUIT----{10 July 2014 . 12:21:09 pm} Squeak4.5-benchmarks.image priorSource: 1247596!----STARTUP----{10 July 2014 . 1:35:50 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 1:36 pm} Squeak4.5-benchmarks.image priorSource: 1248378!----STARTUP----{10 July 2014 . 1:36:17 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 1:36:20 pm} Squeak4.5-benchmarks.image priorSource: 1248378!----STARTUP----{10 July 2014 . 1:41:01 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!AutoStart class methodsFor: 'initialization' stamp: 'hh 7/10/2014 13:43' prior: 42610534!startUp: t1 	| t2 t3 |	self active		ifTrue: [^ self].	self active: true.	t1		ifFalse: [^ self].	HTTPClient determineIfRunningInBrowser.	t2 := AbstractLauncher extractParameters.	(t2 includesKey: 'apiSupported' asUppercase)		ifTrue: [HTTPClient browserSupportsAPI: (t2 at: 'apiSupported' asUppercase) asUppercase = 'TRUE'.			HTTPClient isRunningInBrowser				ifFalse: [HTTPClient isRunningInBrowser: true]].	SPyVM stopUIProcess		ifTrue: [SPyVM print: 'Image startup process going to sleep.'.			Processor activeProcess terminate]		ifFalse: [SPyVM print: 'asdasd'].	self checkForUpdates		ifTrue: [^ self].	self checkForPluginUpdate.	t3 := self installedLaunchers				collect: [:t4 | t4 new].	t3		do: [:t4 | t4 parameters: t2].	t3		do: [:t4 | Smalltalk				at: #WorldState				ifPresent: [:t5 | t5						addDeferredUIMessage: [t4 startUp]]]! !----QUIT----{10 July 2014 . 1:43:56 pm} Squeak4.5-benchmarks.image priorSource: 1248378!----STARTUP----{10 July 2014 . 1:48:32 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 1:49:58 pm} Squeak4.5-benchmarks.image priorSource: 1249995!----STARTUP----{10 July 2014 . 2:27:20 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!AutoStart class methodsFor: 'initialization' stamp: 'hh 7/10/2014 14:27' prior: 34803565!startUp: t1 	| t2 t3 |	self active		ifTrue: [^ self].	self active: true.	t1		ifFalse: [^ self].	HTTPClient determineIfRunningInBrowser.	t2 := AbstractLauncher extractParameters.	(t2 includesKey: 'apiSupported' asUppercase)		ifTrue: [HTTPClient browserSupportsAPI: (t2 at: 'apiSupported' asUppercase) asUppercase = 'TRUE'.			HTTPClient isRunningInBrowser				ifFalse: [HTTPClient isRunningInBrowser: true]].	SPyVM stopUIProcess		ifTrue: [SPyVM print: 'Image startup process going to sleep.'.			Processor activeProcess terminate].	self checkForUpdates		ifTrue: [^ self].	self checkForPluginUpdate.	t3 := self installedLaunchers				collect: [:t4 | t4 new].	t3		do: [:t4 | t4 parameters: t2].	t3		do: [:t4 | Smalltalk				at: #WorldState				ifPresent: [:t5 | t5						addDeferredUIMessage: [t4 startUp]]]! !----QUIT----{10 July 2014 . 2:28:10 pm} Squeak4.5-benchmarks.image priorSource: 1249995!----STARTUP----{10 July 2014 . 2:39:22 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 2:39:27 pm} Squeak4.5-benchmarks.image priorSource: 1251355!----STARTUP----{10 July 2014 . 2:44:49 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT----{10 July 2014 . 2:45:28 pm} Squeak4.5-benchmarks.image priorSource: 1251355!----STARTUP----{10 July 2014 . 2:46:19 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 2:46:27 pm} Squeak4.5-benchmarks.image priorSource: 1251796!----STARTUP----{10 July 2014 . 2:57:58 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 2:59:37 pm} Squeak4.5-benchmarks.image priorSource: 1251796!----STARTUP----{10 July 2014 . 3:07:10 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'hh 7/10/2014 15:08' prior: 34761263!initialize
	meetings := 0.
      waitingForPair := OSLock new; lock.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'hh 7/10/2014 15:08' prior: 34806987!initialize
	meetings := 0.
      waitingForPair := (OSLock new) lock; yourself.! !----QUIT----{10 July 2014 . 3:09:06 pm} Squeak4.5-benchmarks.image priorSource: 1251796!----STARTUP----{10 July 2014 . 3:11:52 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'hh 7/10/2014 15:12' prior: 34798095!reachedBy: chameleon	"	tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString".		[ first isNil
            ifTrue: [ first := chameleon. ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. ] ] atomic value."      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .  	SPyVM print: tmpString. "! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'hh 7/10/2014 15:12' prior: 34771049!run: meetingPlace
    [ color == #faded ] whileFalse: [	  "SPyVM print: 'Chameneos goes to meeting place' , self color."
        meetingPlace reachedBy: self.
        waitingForPair lock.        "SPyVM print: 'Chameneos met another one and releases lock' , self color." ]! !----QUIT----{10 July 2014 . 3:13 pm} Squeak4.5-benchmarks.image priorSource: 1252802!----STARTUP----{10 July 2014 . 3:16:52 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 3:17:21 pm} Squeak4.5-benchmarks.image priorSource: 1253908!----QUIT/NOSAVE----{10 July 2014 . 1:19:47 pm} Squeak4.5-benchmarks.image priorSource: 1253908!----STARTUP----{10 July 2014 . 5:00:09 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 17:01'!OSLockTest	| lock |	lock := OSLock new.	lock release.! !----QUIT----{10 July 2014 . 5:01:29 pm} Squeak4.5-benchmarks.image priorSource: 1253908!----STARTUP----{10 July 2014 . 5:04:01 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 5:05:51 pm} Squeak4.5-benchmarks.image priorSource: 1254571!----STARTUP----{10 July 2014 . 5:35:54 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/images/Squeak4.5-benchmarks.image!----QUIT/NOSAVE----{10 July 2014 . 5:36:06 pm} Squeak4.5-benchmarks.image priorSource: 1254571!----STARTUP----{10 July 2014 . 5:44:18 pm} as /home/hub/hpi/stm/src/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{10 July 2014 . 5:44:25 pm} Squeak4.5-12568.image priorSource: 1254571!----QUIT/NOSAVE----{10 July 2014 . 6:11:07 pm} Squeak4.5-12568.image priorSource: 1254571!----STARTUP----{10 July 2014 . 6:11:32 pm} as /Users/conrad/Repositories/master-project/lang-smalltalk/images/Squeak4.5-12568.image!----QUIT/NOSAVE----{10 July 2014 . 6:22:16 pm} Squeak4.5-12568.image priorSource: 1254571!