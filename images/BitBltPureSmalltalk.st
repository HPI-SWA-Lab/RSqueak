Object subclass: #BitBltPure	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight colorMap sourceWidth sourceHeight sourceDepth sourcePitch sourceBits sourcePPW sourceMSB destWidth destHeight destDepth destPitch destBits destPPW destMSB bitCount skew mask1 mask2 preload nWords destMask hDir vDir sourceIndex sourceDelta destIndex destDelta sx sy dx dy bbW bbH halftoneHeight noSource noHalftone halftoneBase sourceAlpha srcBitShift dstBitShift bitBltOop affectedL affectedR affectedT affectedB opTable maskTable ditherMatrix4x4 ditherThresholds16 ditherValues16 hasSurfaceLock warpSrcShift warpSrcMask warpAlignShift warpAlignMask warpBitShiftTable querySurfaceFn lockSurfaceFn unlockSurfaceFn isWarping cmFlags cmMask cmShiftTable cmMaskTable cmLookupTable cmBitsPerColor dither8Lookup componentAlphaModeColor componentAlphaModeAlpha ungammaLookupTable gammaLookupTable'	classVariableNames: 'AllOnes AlphaIndex BBClipHeightIndex BBClipWidthIndex BBClipXIndex BBClipYIndex BBColorMapIndex BBDestFormIndex BBDestXIndex BBDestYIndex BBHalftoneFormIndex BBHeightIndex BBLastIndex BBRuleIndex BBSourceFormIndex BBSourceXIndex BBSourceYIndex BBWarpBase BBWidthIndex BBXTableIndex BinaryPoint BlueIndex ColorMapFixedPart ColorMapIndexedPart ColorMapNewStyle ColorMapPresent CrossedX Dither8Lookup DitherMatrix4x4 DitherThresholds16 DitherValues16 EndOfRun FixedPt1 FormBitsIndex FormDepthIndex FormHeightIndex FormWidthIndex GreenIndex JitBltHookSize MaskTable OpTable OpTableSize RedIndex'	poolDictionaries: ''	category: 'BitBltPureSmalltalk'!!BitBltPure commentStamp: '<historical>' prior: 0!This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWord	34	alphaBlendScaled: sourceWord with: destinationWord	35 alphaBlendScaled: sourceWord with:	"unused here - only used by FXBlt"	36 alphaBlendScaled: sourceWord with:	"unused here - only used by FXBlt"	37 rgbMul: sourceWord with: destinationWord	38 pixSwap: sourceWord with: destinationWord	39 pixClear: sourceWord with: destinationWord	40 fixAlpha: sourceWord with: destinationWord	41 rgbComponentAlpha: sourceWord with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.To add a new rule to BitBlt...	1.  add the new rule method or methods in the category 'combination rules' of BBSim	2.  describe it in the class comment  of BBSim and in the class comment for BitBlt	3.  add refs to initializeRuleTable in proper positions	4.  add refs to initBBOpTable, following the pattern!!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!OLDrgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	destDepth < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff := sourceWord bitXor: destinationWord.		pixMask := maskTable at: destDepth.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount := bitCount + 1].			diff := diff >> destDepth].		^ destinationWord "for no effect"]. 	destDepth = 16		ifTrue:		[diff := (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount := bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff := (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount := bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff := (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount := bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	(cmFlags bitAnd: (ColorMapPresent bitOr: ColorMapIndexedPart)) =		(ColorMapPresent bitOr: ColorMapIndexedPart)			ifFalse: [^ destinationWord "no op"].	destDepth < 16 ifTrue:		["loop through all packed pixels."		pixMask := (maskTable at: destDepth) bitAnd: cmMask.		shiftWord := destinationWord.		1 to: destPPW do:			[:i |			mapIndex := shiftWord bitAnd: pixMask.			self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1.			shiftWord := shiftWord >> destDepth].		^ destinationWord].	destDepth = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex := self rgbMap: (destinationWord bitAnd: 16rFFFF) from: 5 to: cmBitsPerColor.		self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1.		"... and then left half"		mapIndex := self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1]	ifFalse:		["Just one pixel."		mapIndex := self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!addWord: sourceWord with: destinationWord	^sourceWord + destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!alphaBlend: sourceWord with: destinationWord	"Blend sourceWord with destinationWord, assuming both are 32-bit pixels.	The source is assumed to have 255*alpha in the high 8 bits of each pixel,	while the high 8 bits of the destinationWord will be ignored.	The blend produced is alpha*source + (1-alpha)*dest, with	the computation being performed independently on each color	component.  The high byte of the result will be 0."	| alpha unAlpha colorMask result blend shift |	alpha := sourceWord >> 24.  "High 8 bits of source pixel"	alpha = 0 ifTrue: [ ^ destinationWord ].	alpha = 255 ifTrue: [ ^ sourceWord ].	unAlpha := 255 - alpha.	colorMask := 16rFF.	result := 0.	"red"	shift := 0.	blend := ((sourceWord >> shift bitAnd: colorMask) * alpha) +				((destinationWord>>shift bitAnd: colorMask) * unAlpha)			 	+ 254 // 255 bitAnd: colorMask.	result := result bitOr: blend << shift.	"green"	shift := 8.	blend := ((sourceWord >> shift bitAnd: colorMask) * alpha) +				((destinationWord>>shift bitAnd: colorMask) * unAlpha)			 	+ 254 // 255 bitAnd: colorMask.	result := result bitOr: blend << shift.	"blue"	shift := 16.	blend := ((sourceWord >> shift bitAnd: colorMask) * alpha) +				((destinationWord>>shift bitAnd: colorMask) * unAlpha)			 	+ 254 // 255 bitAnd: colorMask.	result := result bitOr: blend << shift.	"alpha (pre-multiplied)"	shift := 24.	blend := (alpha * 255) +				((destinationWord>>shift bitAnd: colorMask) * unAlpha)			 	+ 254 // 255 bitAnd: colorMask.	result := result bitOr: blend << shift.	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!alphaBlendConst: sourceWord with: destinationWord	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: false! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	destDepth < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha := 255 - sourceAlpha.	pixMask := maskTable at: destDepth.	destDepth = 16 		ifTrue: [bitsPerColor := 5]		ifFalse:[bitsPerColor := 8].	rgbMask := (1<<bitsPerColor) - 1.	maskShifted := destMask.	destShifted := destinationWord.	sourceShifted := sourceWord.	result := destinationWord.	destPPW = 1 ifTrue:["32bpp blends include alpha"		paintMode & (sourceWord = 0)  "painting a transparent pixel" ifFalse:[			result := 0.			1 to: 4 do:[:i|				shift := (i-1)*8.				blend := (((sourceWord>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destinationWord>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				result := result bitOr: blend<<shift].		].	] ifFalse:[		1 to: destPPW do:[:j |			sourcePixVal := sourceShifted bitAnd: pixMask.			((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"				or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])			ifFalse:				[destPixVal := destShifted bitAnd: pixMask.				pixBlend := 0.				1 to: 3 do:					[:i | shift := (i-1)*bitsPerColor.					blend := (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)								+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))						 	+ 254 // 255 bitAnd: rgbMask.					pixBlend := pixBlend bitOr: blend<<shift].				destDepth = 16					ifTrue: [result := (result bitAnd: (pixMask << (j-1*16)) bitInvert32)										bitOr: pixBlend << (j-1*16)]					ifFalse: [result := pixBlend]].			maskShifted := maskShifted >> destDepth.			sourceShifted := sourceShifted >> destDepth.			destShifted := destShifted >> destDepth].	].	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:02'!alphaBlendScaled: sourceWord with: destinationWord	"Blend sourceWord with destinationWord using the alpha value from sourceWord.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	In contrast to alphaBlend:with: the color produced is		srcColor + (1-srcAlpha) * dstColor	e.g., it is assumed that the source color is already scaled."	| unAlpha dstMask srcMask b g r a |	unAlpha := 255 - (sourceWord >> 24).  "High 8 bits of source pixel"	dstMask := destinationWord.	srcMask := sourceWord.	b := (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	b > 255 ifTrue:[b := 255].	dstMask := dstMask >> 8.	srcMask := srcMask >> 8.	g := (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	g > 255 ifTrue:[g := 255].	dstMask := dstMask >> 8.	srcMask := srcMask >> 8.	r := (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	r > 255 ifTrue:[r := 255].	dstMask := dstMask >> 8.	srcMask := srcMask >> 8.	a := (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	a > 255 ifTrue:[a := 255].	^(((((a << 8) + r) << 8) + g) << 8) + b! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!alphaPaintConst: sourceWord with: destinationWord	sourceWord = 0 ifTrue: [^ destinationWord  "opt for all-transparent source"].	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: true! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitAnd: sourceWord with: destinationWord	^sourceWord bitAnd: destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitAndInvert: sourceWord with: destinationWord	^sourceWord bitAnd: destinationWord bitInvert32! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitInvertAnd: sourceWord with: destinationWord	^sourceWord bitInvert32 bitAnd: destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitInvertAndInvert: sourceWord with: destinationWord	^sourceWord bitInvert32 bitAnd: destinationWord bitInvert32! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitInvertDestination: sourceWord with: destinationWord	^destinationWord bitInvert32! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitInvertOr: sourceWord with: destinationWord	^sourceWord bitInvert32 bitOr: destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitInvertOrInvert: sourceWord with: destinationWord	^sourceWord bitInvert32 bitOr: destinationWord bitInvert32! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitInvertSource: sourceWord with: destinationWord	^sourceWord bitInvert32! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitInvertXor: sourceWord with: destinationWord	^sourceWord bitInvert32 bitXor: destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitOr: sourceWord with: destinationWord	^sourceWord bitOr: destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitOrInvert: sourceWord with: destinationWord	^sourceWord bitOr: destinationWord bitInvert32! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!bitXor: sourceWord with: destinationWord	^sourceWord bitXor: destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!clearWord: source with: destination	^ 0! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!destinationWord: sourceWord with: destinationWord	^destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!fixAlpha: sourceWord with: destinationWord	"For any non-zero pixel value in destinationWord with zero alpha channel take the alpha from sourceWord and fill it in. Intended for fixing alpha channels left at zero during 16->32 bpp conversions."	destDepth = 32 ifFalse:[^destinationWord]. "no-op for non 32bpp"	destinationWord = 0 ifTrue:[^0].	(destinationWord bitAnd: 16rFF000000) = 0 ifFalse:[^destinationWord].	^destinationWord bitOr: (sourceWord bitAnd: 16rFF000000)! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:02'!merge: sourceWord with: destinationWord	"Sender warpLoop is too big to include this in-line"	^ self mergeFn: sourceWord with: destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 20:04'!mergeFn: arg1 with: arg2	^ self perform: (OpTable at: combinationRule+1) with: arg1 with: arg2! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts	"AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color"	| mask result |	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		(word1 bitAnd: mask) = mask			ifTrue: [result := result bitOr: (word2 bitAnd: mask)].		mask := mask << nBits  "slide left to next partition"].	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:03'!partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts	"Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask sum result maskedWord1 |	"In C, most arithmetic operations answer the same bit pattern regardless of the operands being signed or unsigned ints	(this is due to the way 2's complement numbers work). However, comparisions might fail. Add the proper declaration of	words as unsigned int in those cases where comparisions are done (jmv)"	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		maskedWord1 := word1 bitAnd: mask.		sum := maskedWord1 + (word2 bitAnd: mask).		(sum <= mask "result must not carry out of partition"				and: [ sum >= maskedWord1 ])	"This is needed because in C, integer arithmetic overflows silently!! (jmv)"			ifTrue: [result := result bitOr: sum]			ifFalse: [result := result bitOr: mask].		mask := mask << nBits  "slide left to next partition"].	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:03'!partitionedMax: word1 with: word2 nBits: nBits nPartitions: nParts	"Max word1 to word2 as nParts partitions of nBits each"	| mask result |	"In C, most arithmetic operations answer the same bit pattern regardless of the operands being signed or unsigned ints	(this is due to the way 2's complement numbers work). However, comparisions might fail. Add the proper declaration of	words as unsigned int in those cases where comparisions are done (jmv)"	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		result := result bitOr: ((word2 bitAnd: mask) max: (word1 bitAnd: mask)).		mask := mask << nBits  "slide left to next partition"].	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:03'!partitionedMin: word1 with: word2 nBits: nBits nPartitions: nParts	"Min word1 to word2 as nParts partitions of nBits each"	| mask result |	"In C, most arithmetic operations answer the same bit pattern regardless of the operands being signed or unsigned ints	(this is due to the way 2's complement numbers work). However, comparisions might fail. Add the proper declaration of	words as unsigned int in those cases where comparisions are done (jmv)"	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		result := result bitOr: ((word2 bitAnd: mask) min: (word1 bitAnd: mask)).		mask := mask << nBits  "slide left to next partition"].	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!partitionedMul: word1 with: word2 nBits: nBits nPartitions: nParts	"Multiply word1 with word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors.	Bug in loop version when non-white background"	| sMask product result dMask |	"In C, integer multiplication might answer a wrong value if the unsigned values are declared as signed.	This problem does not affect this method, because the most significant bit (i.e. the sign bit) will	always be zero (jmv)"	sMask := maskTable at: nBits.  "partition mask starts at the right"	dMask :=  sMask << nBits.	result := (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) >> nBits.	"optimized first step"	nParts = 1		ifTrue: [ ^result ].	product := (((word1>>nBits bitAnd: sMask)+1) * ((word2>>nBits bitAnd: sMask)+1) - 1 bitAnd: dMask).	result := result bitOr: product.	nParts = 2		ifTrue: [ ^result ].	product := (((word1>>(2*nBits) bitAnd: sMask)+1) * ((word2>>(2*nBits) bitAnd: sMask)+1) - 1 bitAnd: dMask).	result := result bitOr: product << nBits.	nParts = 3		ifTrue: [ ^result ].	product := (((word1>>(3*nBits) bitAnd: sMask)+1) * ((word2>>(3*nBits) bitAnd: sMask)+1) - 1 bitAnd: dMask).	result := result bitOr: product << (2*nBits).	^ result"	| sMask product result dMask |	sMask := maskTable at: nBits.  'partition mask starts at the right'	dMask :=  sMask << nBits.	result := (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) >> nBits.	'optimized first step'	nBits to: nBits * (nParts-1) by: nBits do: [:ofs |		product := (((word1>>ofs bitAnd: sMask)+1) * ((word2>>ofs bitAnd: sMask)+1) - 1 bitAnd: dMask).		result := result bitOr: (product bitAnd: dMask) << (ofs-nBits)].	^ result"! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!partitionedRgbComponentAlpha: sourceWord dest: destWord nBits: nBits nPartitions: nParts	| mask result p1 p2 v |	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		p1 := (sourceWord bitAnd: mask) >> ((i - 1)*nBits).		p2 := (destWord bitAnd: mask) >> ((i - 1)*nBits).		nBits = 32			ifFalse:[				nBits = 16					ifTrue:[						p1 := (self rgbMap16To32: p1) bitOr: 16rFF000000.						p2 := (self rgbMap16To32: p2) bitOr: 16rFF000000]					ifFalse:[						p1 := (self rgbMap: p1 from: nBits to: 32) bitOr: 16rFF000000.						p2 := (self rgbMap: p2 from: nBits to: 32) bitOr: 16rFF000000.]].		v := self rgbComponentAlpha32: p1 with: p2.		nBits = 32			ifFalse:[				v := self rgbMap: v from: 32 to: nBits].		result := result bitOr: (v <<  ((i - 1)*nBits)). 		mask := mask << nBits  "slide left to next partition"].	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:03'!partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts	"Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask result p1 p2 |	"In C, most arithmetic operations answer the same bit pattern regardless of the operands being signed or unsigned ints	(this is due to the way 2's complement numbers work). However, comparisions might fail. Add the proper declaration of	words as unsigned int in those cases where comparisions are done (jmv)"	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		p1 := word1 bitAnd: mask.		p2 := word2 bitAnd: mask.		p1 < p2  "result is really abs value of thedifference"			ifTrue: [result := result bitOr: p2 - p1]			ifFalse: [result := result bitOr: p1 - p2].		mask := mask << nBits  "slide left to next partition"].	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/18/2014 15:47'!pickSourcePixels: nPixels flags: mapperFlags srcMask: srcMask destMask: dstMask srcShiftInc: srcShiftInc dstShiftInc: dstShiftInc	"Pick nPix pixels starting at srcBitIndex from the source, map by the	color map, and justify them according to dstBitIndex in the resulting destWord."	| sourceWord destWord sourcePix destPix srcShift dstShift nPix |	sourceWord := self srcLongAt: sourceIndex.	destWord := 0.	srcShift := srcBitShift. "Hint: Keep in register"	dstShift := dstBitShift. "Hint: Keep in register"	nPix := nPixels. "always > 0 so we can use do { } while(--nPix);"	(mapperFlags = (ColorMapPresent bitOr: ColorMapIndexedPart)) ifTrue:[		"a little optimization for (pretty crucial) blits using indexed lookups only"		[	"grab, colormap and mix in pixel"			sourcePix := sourceWord >> srcShift bitAnd: srcMask.			destPix := cmLookupTable at: (sourcePix bitAnd: cmMask).			destWord := destWord bitOr: (destPix bitAnd: dstMask) << dstShift.			"adjust dest pix index"			dstShift := dstShift + dstShiftInc.			"adjust source pix index"			((srcShift := srcShift + srcShiftInc) bitAnd: 16rFFFFFFE0) = 0 ifFalse:[				sourceMSB ifTrue:[srcShift := srcShift + 32] ifFalse:[srcShift := srcShift - 32].				sourceWord := self srcLongAt: (sourceIndex := sourceIndex + 1)].		(nPix := nPix - 1) = 0] whileFalse.	] ifFalse:[		[	"grab, colormap and mix in pixel"			sourcePix := sourceWord >> srcShift bitAnd: srcMask.			destPix := self mapPixel: sourcePix flags: mapperFlags.			destWord := destWord bitOr: (destPix bitAnd: dstMask) << dstShift.			"adjust dest pix index"			dstShift := dstShift + dstShiftInc.			"adjust source pix index"			((srcShift := srcShift + srcShiftInc) bitAnd: 16rFFFFFFE0) = 0 ifFalse:[				sourceMSB ifTrue:[srcShift := srcShift + 32] ifFalse:[srcShift := srcShift - 32].				sourceWord := self srcLongAt: (sourceIndex := sourceIndex + 1)].		(nPix := nPix - 1) = 0] whileFalse.	].	srcBitShift := srcShift. "Store back"	^destWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:03'!pixClear: sourceWord with: destinationWord	"Clear all pixels in destinationWord for which the pixels of sourceWord have the same values. Used to clear areas of some constant color to zero."	| mask result nBits pv |	destDepth = 32 ifTrue:[		sourceWord = destinationWord ifTrue:[^0] ifFalse:[^destinationWord].	].	nBits := destDepth.	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: destPPW do:[:i |		pv := destinationWord bitAnd: mask.		(sourceWord bitAnd: mask) = pv ifTrue:[pv := 0].		result := result bitOr: pv.		mask := mask << nBits "slide left to next partition"].	^ result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:03'!pixMask: sourceWord with: destinationWord	^ self partitionedAND: sourceWord bitInvert32 to: destinationWord					nBits: destDepth nPartitions: destPPW! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:03'!pixPaint: sourceWord with: destinationWord	sourceWord = 0 ifTrue: [^ destinationWord].	^ sourceWord bitOr:		(self partitionedAND: sourceWord bitInvert32 to: destinationWord						nBits: destDepth nPartitions: destPPW)! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:04'!pixSwap: sourceWord with: destWord	"Swap the pixels in destWord"	| result shift lowMask highMask |	destPPW = 1 ifTrue:[^destWord]. "a single pixel per word"	result := 0.	lowMask := (1 << destDepth) - 1. "mask low pixel"	highMask := lowMask << (destPPW-1 * destDepth). "mask high pixel"	shift := 32 - destDepth.	result := result bitOr: (				(destWord bitAnd: lowMask) << shift bitOr:					(destWord bitAnd: highMask) >> shift).	destPPW <= 2 ifTrue:[^result].	2 to: destPPW // 2 do:[:i|		lowMask := lowMask << destDepth.		highMask := highMask >> destDepth.		shift := shift - (destDepth * 2).		result := result bitOr: (					(destWord bitAnd: lowMask) << shift bitOr:						(destWord bitAnd: highMask) >> shift)].	^result! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:04'!rgbAdd: sourceWord with: destinationWord	destDepth < 16 ifTrue:		["Add each pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Add RGB components of each pixel separately"		^ (self partitionedAdd: sourceWord to: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedAdd: sourceWord>>16 to: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Add RGBA components of the pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: 8 nPartitions: 4]! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/18/2014 15:05'!rgbComponentAlpha16	"This version assumes 		combinationRule = 41		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"		| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift ditherBase ditherIndex ditherThreshold |	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	srcShift := (dx bitAnd: 1) * 16.	destMSB ifTrue:[srcShift := 16 - srcShift].	mask1 := 16rFFFF << (16 - srcShift).	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		srcIndex := sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex := destBits + (dstY * destPitch) + (dx // 2 * 4).		ditherBase := (dstY bitAnd: 3) * 4.		ditherIndex := (sx bitAnd: 3) - 1. "For pre-increment"		deltaX := bbW + 1. "So we can pre-decrement"		dstMask := mask1.		dstMask = 16rFFFF ifTrue:[srcShift := 16] ifFalse:[srcShift := 0].		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			ditherThreshold := ditherMatrix4x4 at: ditherBase + (ditherIndex := ditherIndex + 1 bitAnd: 3) + 1.			sourceWord := self srcLongAt: srcIndex.			srcAlpha := sourceWord bitAnd: 16rFFFFFF.				srcAlpha = 0 ifFalse:[ "0 < srcAlpha"					"If we have to mix colors then just copy a single word"					destWord := self dstLongAt: dstIndex.					destWord := destWord bitAnd: dstMask bitInvert32.					destWord := destWord >> srcShift.					"Expand from 16 to 32 bit by adding zero bits"					destWord := (((destWord bitAnd: 16r7C00) bitShift: 9) bitOr:									((destWord bitAnd: 16r3E0) bitShift: 6)) bitOr:								(((destWord bitAnd: 16r1F) bitShift: 3) bitOr:									16rFF000000).					"Mix colors"					sourceWord := self rgbComponentAlpha32: sourceWord with: destWord.					"And dither"					sourceWord := self dither32To16: sourceWord threshold: ditherThreshold.					sourceWord = 0 						ifTrue:[sourceWord := 1 << srcShift]						ifFalse:[sourceWord := sourceWord << srcShift].					"Store back"					self dstLongAt: dstIndex put: sourceWord mask: dstMask.				].			srcIndex := srcIndex + 4.			destMSB				ifTrue:[srcShift = 0 ifTrue:[dstIndex := dstIndex + 4]]				ifFalse:[srcShift = 0 ifFalse:[dstIndex := dstIndex + 4]].			srcShift := srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask := dstMask bitInvert32. "Mask other half word"		].		srcY := srcY + 1.		dstY := dstY + 1.	].! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:04'!rgbComponentAlpha32	"This version assumes 		combinationRule = 41		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special case of aR = aG = aB = 0 	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY srcY dstY |	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		srcIndex := sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex := destBits + (dstY * destPitch) + (dx * 4).		deltaX := bbW + 1. "So we can pre-decrement"		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			sourceWord := self srcLongAt: srcIndex.			srcAlpha := sourceWord bitAnd:16rFFFFFF.				srcAlpha = 0 ifTrue:[					srcIndex := srcIndex + 4.					dstIndex := dstIndex + 4.					"Now skip as many words as possible,"					[(deltaX := deltaX - 1) ~= 0 and:[						((sourceWord := self srcLongAt: srcIndex) bitAnd:16rFFFFFF) = 0]]						whileTrue:[							srcIndex := srcIndex + 4.							dstIndex := dstIndex + 4.						].					"Adjust deltaX"					deltaX := deltaX + 1.				] ifFalse:[ "0 < srcAlpha"					"If we have to mix colors then just copy a single word"					destWord := self dstLongAt: dstIndex.					destWord := self rgbComponentAlpha32: sourceWord with: destWord.					self dstLongAt: dstIndex put: destWord.					srcIndex := srcIndex + 4.					dstIndex := dstIndex + 4.				].		].		srcY := srcY + 1.		dstY := dstY + 1.	].! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:05'!rgbComponentAlpha32: sourceWord with: destinationWord	"	componentAlphaModeColor is the color,	sourceWord contains an alpha value for each component of RGB	each of which is encoded as0 meaning 0.0 and 255 meaning 1.0 .	the rule is...		color = componentAlphaModeColor.	colorAlpha = componentAlphaModeAlpha.	mask = sourceWord.	dst.A =  colorAlpha + (1 - colorAlpha) * dst.A      dst.R = color.R * mask.R * colorAlpha + (1 - (mask.R * colorAlpha)) * dst.R      dst.G = color.G * mask.G * colorAlpha + (1 - (mask.G* colorAlpha)) * dst.G      dst.B = color.B * mask.B * colorAlpha + (1 - (mask.B* colorAlpha)) * dst.B	"	| alpha dstMask srcColor srcAlpha b g r a aB aG aR aA answer s d |			alpha := sourceWord.	alpha = 0 ifTrue:[^destinationWord].	srcColor := componentAlphaModeColor.	srcAlpha := componentAlphaModeAlpha bitAnd: 255.		aB := alpha bitAnd: 255.	alpha := alpha >> 8.	aG := alpha bitAnd: 255.	alpha := alpha >> 8.	aR := alpha bitAnd: 255.	alpha := alpha >> 8.	aA := alpha bitAnd: 255.		srcAlpha = 255 		ifFalse:[			aA := aA * srcAlpha >> 8.			aR := aR * srcAlpha >> 8.			aG := aG * srcAlpha >> 8.			aB := aB * srcAlpha >> 8].				dstMask := destinationWord.	d := dstMask bitAnd: 255.	s := srcColor bitAnd: 255.	ungammaLookupTable == nil		ifFalse:[			d := ungammaLookupTable at: d.			s := ungammaLookupTable at: s.].	b := (d * (255 - aB) >> 8) + (s * aB >> 8).	b > 255 ifTrue:[b := 255].	gammaLookupTable == nil		ifFalse:[				b := gammaLookupTable at: b].	dstMask := dstMask >> 8.	srcColor := srcColor >> 8.	d := dstMask bitAnd: 255.	s := srcColor bitAnd: 255.	ungammaLookupTable == nil		ifFalse:[			d := ungammaLookupTable at: d.			s := ungammaLookupTable at: s.].	g := (d * (255 - aG) >> 8) + (s * aG >> 8).	g > 255 ifTrue:[g := 255].	gammaLookupTable == nil		ifFalse:[				g := gammaLookupTable at: g].	dstMask := dstMask >> 8.	srcColor := srcColor >> 8.	d := dstMask bitAnd: 255.	s := srcColor bitAnd: 255.	ungammaLookupTable == nil		ifFalse:[			d := ungammaLookupTable at: d.			s := ungammaLookupTable at: s.].	r := (d * (255 - aR) >> 8) + (s * aR >> 8).	r > 255 ifTrue:[r := 255].	gammaLookupTable == nil		ifFalse:[				r := gammaLookupTable at: r].	dstMask := dstMask >> 8.	srcColor := srcColor >> 8.	a := ((dstMask bitAnd: 255) * (255 - aA) >> 8) + aA. "no need to gamma correct alpha value ?"	a > 255 ifTrue:[a := 255].	answer := (((((a << 8) + r) << 8) + g) << 8) + b.	^answer	! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:05'!rgbComponentAlpha8	"This version assumes 		combinationRule = 41		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	"		| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust mappingTable mapperFlags |		mappingTable := self default8To32Table.	mapperFlags := cmFlags bitAnd: ColorMapNewStyle bitInvert32.	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	mask1 := ((dx bitAnd: 3) * 8).	destMSB ifTrue:[mask1 := 24 - mask1].	mask2 := AllOnes bitXor:(16rFF << mask1).	(dx bitAnd: 1) = 0 		ifTrue:[adjust := 0]		ifFalse:[adjust := 16r1F1F1F1F].	(dy bitAnd: 1) = 0		ifTrue:[adjust := adjust bitXor: 16r1F1F1F1F].	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		adjust := adjust bitXor: 16r1F1F1F1F.		srcIndex := sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex := destBits + (dstY * destPitch) + (dx // 4 * 4).		deltaX := bbW + 1. "So we can pre-decrement"		srcShift := mask1.		dstMask := mask2.		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			sourceWord := ((self srcLongAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha := sourceWord bitAnd: 16rFFFFFF.			"set srcAlpha to the average of the 3 separate aR,Ag,AB values"			srcAlpha := ((srcAlpha >> 16) + (srcAlpha >> 8 bitAnd: 16rFF) + (srcAlpha bitAnd: 16rFF)) // 3.			srcAlpha > 31 ifTrue:["Everything below 31 is transparent"				srcAlpha > 224 					ifTrue: ["treat everything above 224 as opaque"						sourceWord := 16rFFFFFFFF].				destWord := self dstLongAt: dstIndex.				destWord := destWord bitAnd: dstMask bitInvert32.				destWord := destWord >> srcShift.				destWord := mappingTable at: destWord.				sourceWord := self rgbComponentAlpha32: sourceWord with: destWord.				sourceWord := self mapPixel: sourceWord flags: mapperFlags.				sourceWord := sourceWord << srcShift.				"Store back"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			].			srcIndex := srcIndex + 4.			destMSB ifTrue:[				srcShift = 0 					ifTrue:[dstIndex := dstIndex + 4.							srcShift := 24.							dstMask := 16r00FFFFFF]					ifFalse:[srcShift := srcShift - 8.							dstMask := (dstMask >> 8) bitOr: 16rFF000000].			] ifFalse:[				srcShift = 32					ifTrue:[dstIndex := dstIndex + 4.							srcShift := 0.							dstMask := 16rFFFFFF00]					ifFalse:[srcShift := srcShift + 8.							dstMask := dstMask << 8 bitOr: 255].			].			adjust := adjust bitXor: 16r1F1F1F1F.		].		srcY := srcY + 1.		dstY := dstY + 1.	].! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:05'!rgbComponentAlpha: sourceWord with: destinationWord	"	componentAlphaModeColor is the color,	sourceWord contains an alpha value for each component of RGB	each of which is encoded as0 meaning 0.0 and 255 meaning 1.0 .	the rule is...		color = componentAlphaModeColor.	colorAlpha = componentAlphaModeAlpha.	mask = sourceWord.	dst.A =  colorAlpha + (1 - colorAlpha) * dst.A      dst.R = color.R * mask.R * colorAlpha + (1 - (mask.R * colorAlpha)) * dst.R      dst.G = color.G * mask.G * colorAlpha + (1 - (mask.G* colorAlpha)) * dst.G      dst.B = color.B * mask.B * colorAlpha + (1 - (mask.B* colorAlpha)) * dst.B	"	| alpha |			alpha := sourceWord.	alpha = 0 ifTrue:[^destinationWord].	^self partitionedRgbComponentAlpha: sourceWord dest: destinationWord nBits: destDepth nPartitions: destPPW.! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:05'!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, return the number of differing pixels."	| pixMask destShifted sourceShifted destPixVal bitsPerColor rgbMask sourcePixVal diff maskShifted |	pixMask := maskTable at: destDepth.	destDepth = 16		ifTrue: [bitsPerColor := 5.  rgbMask := 16r1F]		ifFalse: [bitsPerColor := 8.  rgbMask := 16rFF].	maskShifted := destMask.	destShifted := destinationWord.	sourceShifted := sourceWord.	1 to: destPPW do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			destPixVal := destShifted bitAnd: pixMask.			sourcePixVal := sourceShifted bitAnd: pixMask.			destDepth < 16				ifTrue: [sourcePixVal = destPixVal							ifTrue: [diff := 0]							ifFalse: [diff := 1]]				ifFalse: [diff := (self partitionedSub: sourcePixVal from: destPixVal								nBits: bitsPerColor nPartitions: 3).						diff := (diff bitAnd: rgbMask)							+ (diff>>bitsPerColor bitAnd: rgbMask)							+ ((diff>>bitsPerColor)>>bitsPerColor bitAnd: rgbMask)].			bitCount := bitCount + diff].		maskShifted := maskShifted >> destDepth.		sourceShifted := sourceShifted >> destDepth.		destShifted := destShifted >> destDepth].	^ destinationWord  "For no effect on dest"! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:06'!rgbMax: sourceWord with: destinationWord	destDepth < 16 ifTrue:		["Max each pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Max RGB components of each pixel separately"		^ (self partitionedMax: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMax: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Max RGBA components of the pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: 8 nPartitions: 4]! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:06'!rgbMin: sourceWord with: destinationWord	destDepth < 16 ifTrue:		["Min each pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Min RGB components of each pixel separately"		^ (self partitionedMin: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMin: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Min RGBA components of the pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: 8 nPartitions: 4]! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:06'!rgbMinInvert: wordToInvert with: destinationWord	| sourceWord |	sourceWord := wordToInvert bitInvert32.	destDepth < 16 ifTrue:		["Min each pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Min RGB components of each pixel separately"		^ (self partitionedMin: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMin: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Min RGBA components of the pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: 8 nPartitions: 4]! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:06'!rgbMul: sourceWord with: destinationWord	destDepth < 16 ifTrue:		["Mul each pixel separately"		^ self partitionedMul: sourceWord with: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Mul RGB components of each pixel separately"		^ (self partitionedMul: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMul: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Mul RGBA components of the pixel separately"		^ self partitionedMul: sourceWord with: destinationWord						nBits: 8 nPartitions: 4]"	| scanner |	Display repaintMorphicDisplay.	scanner := DisplayScanner quickPrintOn: Display.	MessageTally time: [0 to: 760 by: 4 do:  [:y |scanner drawString: 'qwrepoiuasfd=)(/&()=#!!°lkjzxv.,mn124+09857907QROIYTOAFDJZXNBNB,M-.,Mqwrepoiuasfd=)(/&()=#!!°lkjzxv.,mn124+09857907QROIYTOAFDJZXNBNB,M-.,M1234124356785678' at: 0@y]]. "! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:06'!rgbSub: sourceWord with: destinationWord	destDepth < 16 ifTrue:		["Sub each pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Sub RGB components of each pixel separately"		^ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Sub RGBA components of the pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 4]! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!sourceWord: sourceWord with: destinationWord	^sourceWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:01'!subWord: sourceWord with: destinationWord	^sourceWord - destinationWord! !!BitBltPure methodsFor: 'combination rules' stamp: 'tfel 1/17/2014 19:06'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask destShifted maskShifted pixVal |	(cmFlags bitAnd: (ColorMapPresent bitOr: ColorMapIndexedPart)) = 		(ColorMapPresent bitOr: ColorMapIndexedPart)			ifFalse: [^ destinationWord "no op"].	pixMask := maskTable at: destDepth.	destShifted := destinationWord.	maskShifted := destMask.	1 to: destPPW do:		[:i |		(maskShifted bitAnd: pixMask) = 0 ifFalse:			["Only tally pixels within the destination rectangle"			pixVal := destShifted bitAnd: pixMask.			destDepth < 16				ifTrue: [mapIndex := pixVal]				ifFalse: [destDepth = 16					ifTrue: [mapIndex := self rgbMap: pixVal from: 5 to: cmBitsPerColor]					ifFalse: [mapIndex := self rgbMap: pixVal from: 8 to: cmBitsPerColor]].			self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1].		maskShifted := maskShifted >> destDepth.		destShifted := destShifted >> destDepth].	^ destinationWord  "For no effect on dest"! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!affectedB	^ affectedB! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!affectedB: anObject	affectedB := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:01'!affectedBottom	^affectedB! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!affectedL	^ affectedL! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!affectedL: anObject	affectedL := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:01'!affectedLeft	^affectedL! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!affectedR	^ affectedR! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!affectedR: anObject	affectedR := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:01'!affectedRight	^affectedR! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!affectedT	^ affectedT! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!affectedT: anObject	affectedT := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:01'!affectedTop	^affectedT! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!bbH	^ bbH! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!bbH: anObject	bbH := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!bbW	^ bbW! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!bbW: anObject	bbW := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!bitBltOop	^ bitBltOop! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!bitBltOop: anObject	bitBltOop := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!bitCount	^ bitCount! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!bitCount: anObject	bitCount := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!clipHeight	^ clipHeight! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!clipHeight: anObject	clipHeight := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!clipWidth	^ clipWidth! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!clipWidth: anObject	clipWidth := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!clipX	^ clipX! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!clipX: anObject	clipX := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!clipY	^ clipY! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!clipY: anObject	clipY := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmBitsPerColor	^ cmBitsPerColor! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmBitsPerColor: anObject	cmBitsPerColor := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmFlags	^ cmFlags! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmFlags: anObject	cmFlags := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmLookupTable	^ cmLookupTable! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmLookupTable: anObject	cmLookupTable := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmMask	^ cmMask! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmMask: anObject	cmMask := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmMaskTable	^ cmMaskTable! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmMaskTable: anObject	cmMaskTable := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmShiftTable	^ cmShiftTable! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!cmShiftTable: anObject	cmShiftTable := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:50'!colorMap	^ colorMap! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:50'!colorMap: anObject	colorMap := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!combinationRule	^ combinationRule! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!combinationRule: anObject	combinationRule := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!componentAlphaModeAlpha	^ componentAlphaModeAlpha! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!componentAlphaModeAlpha: anObject	componentAlphaModeAlpha := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!componentAlphaModeColor	^ componentAlphaModeColor! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!componentAlphaModeColor: anObject	componentAlphaModeColor := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destBits	^ destBits! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destBits: anObject	destBits := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destDelta	^ destDelta! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destDelta: anObject	destDelta := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destDepth	^ destDepth! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destDepth: anObject	destDepth := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destForm	^ destForm! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destForm: anObject	destForm := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destHeight	^ destHeight! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destHeight: anObject	destHeight := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destIndex	^ destIndex! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destIndex: anObject	destIndex := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destMSB	^ destMSB! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destMSB: anObject	destMSB := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destMask	^ destMask! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destMask: anObject	destMask := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destPPW	^ destPPW! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destPPW: anObject	destPPW := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destPitch	^ destPitch! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destPitch: anObject	destPitch := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destWidth	^ destWidth! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destWidth: anObject	destWidth := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destX	^ destX! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destX: anObject	destX := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destY	^ destY! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!destY: anObject	destY := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!dither8Lookup	^ dither8Lookup! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!dither8Lookup: anObject	dither8Lookup := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!ditherMatrix4x4	^ ditherMatrix4x4! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!ditherMatrix4x4: anObject	ditherMatrix4x4 := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!ditherThresholds16	^ ditherThresholds16! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!ditherThresholds16: anObject	ditherThresholds16 := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!ditherValues16	^ ditherValues16! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!ditherValues16: anObject	ditherValues16 := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!dstBitShift	^ dstBitShift! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!dstBitShift: anObject	dstBitShift := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!dx	^ dx! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!dx: anObject	dx := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!dy	^ dy! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!dy: anObject	dy := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!gammaLookupTable	^ gammaLookupTable! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!gammaLookupTable: anObject	gammaLookupTable := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!hDir	^ hDir! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!hDir: anObject	hDir := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!halftoneBase	^ halftoneBase! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!halftoneBase: anObject	halftoneBase := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!halftoneForm	^ halftoneForm! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!halftoneForm: anObject	halftoneForm := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!halftoneHeight	^ halftoneHeight! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!halftoneHeight: anObject	halftoneHeight := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!hasSurfaceLock	^ hasSurfaceLock! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!hasSurfaceLock: anObject	hasSurfaceLock := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!height	^ height! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!height: anObject	height := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!isWarping	^ isWarping! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!isWarping: anObject	isWarping := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!lockSurfaceFn	^ lockSurfaceFn! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!lockSurfaceFn: anObject	lockSurfaceFn := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!mask1	^ mask1! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!mask1: anObject	mask1 := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!mask2	^ mask2! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!mask2: anObject	mask2 := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!maskTable	^ maskTable! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!maskTable: anObject	maskTable := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!nWords	^ nWords! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!nWords: anObject	nWords := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!noHalftone	^ noHalftone! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!noHalftone: anObject	noHalftone := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!noSource	^ noSource! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!noSource: anObject	noSource := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!opTable	^ opTable! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!opTable: anObject	opTable := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!preload	^ preload! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!preload: anObject	preload := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!querySurfaceFn	^ querySurfaceFn! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!querySurfaceFn: anObject	querySurfaceFn := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!skew	^ skew! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!skew: anObject	skew := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceAlpha	^ sourceAlpha! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceAlpha: anObject	sourceAlpha := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceBits	^ sourceBits! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceBits: anObject	sourceBits := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceDelta	^ sourceDelta! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceDelta: anObject	sourceDelta := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceDepth	^ sourceDepth! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceDepth: anObject	sourceDepth := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceForm	^ sourceForm! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceForm: anObject	sourceForm := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceHeight	^ sourceHeight! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceHeight: anObject	sourceHeight := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceIndex	^ sourceIndex! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceIndex: anObject	sourceIndex := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceMSB	^ sourceMSB! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceMSB: anObject	sourceMSB := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourcePPW	^ sourcePPW! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourcePPW: anObject	sourcePPW := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourcePitch	^ sourcePitch! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourcePitch: anObject	sourcePitch := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceWidth	^ sourceWidth! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceWidth: anObject	sourceWidth := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceX	^ sourceX! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceX: anObject	sourceX := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceY	^ sourceY! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sourceY: anObject	sourceY := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!srcBitShift	^ srcBitShift! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!srcBitShift: anObject	srcBitShift := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sx	^ sx! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sx: anObject	sx := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sy	^ sy! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!sy: anObject	sy := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!ungammaLookupTable	^ ungammaLookupTable! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!ungammaLookupTable: anObject	ungammaLookupTable := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!unlockSurfaceFn	^ unlockSurfaceFn! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!unlockSurfaceFn: anObject	unlockSurfaceFn := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!vDir	^ vDir! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!vDir: anObject	vDir := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpAlignMask	^ warpAlignMask! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpAlignMask: anObject	warpAlignMask := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpAlignShift	^ warpAlignShift! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpAlignShift: anObject	warpAlignShift := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpBitShiftTable	^ warpBitShiftTable! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpBitShiftTable: anObject	warpBitShiftTable := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpSrcMask	^ warpSrcMask! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpSrcMask: anObject	warpSrcMask := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpSrcShift	^ warpSrcShift! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!warpSrcShift: anObject	warpSrcShift := anObject! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!width	^ width! !!BitBltPure methodsFor: 'accessing' stamp: 'tfel 1/17/2014 19:47'!width: anObject	width := anObject! !!BitBltPure methodsFor: 'inner loop' stamp: 'tfel 1/18/2014 15:05'!alphaSourceBlendBits16	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift ditherBase ditherIndex ditherThreshold |	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	srcShift := (dx bitAnd: 1) * 16.	destMSB ifTrue:[srcShift := 16 - srcShift].	mask1 := 16rFFFF << (16 - srcShift).	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		srcIndex := sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex := destBits + (dstY * destPitch) + (dx // 2 * 4).		ditherBase := (dstY bitAnd: 3) * 4.		ditherIndex := (sx bitAnd: 3) - 1. "For pre-increment"		deltaX := bbW + 1. "So we can pre-decrement"		dstMask := mask1.		dstMask = 16rFFFF ifTrue:[srcShift := 16] ifFalse:[srcShift := 0].		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			ditherThreshold := ditherMatrix4x4 at: ditherBase + (ditherIndex := ditherIndex + 1 bitAnd: 3) + 1.			sourceWord := self srcLongAt: srcIndex.			srcAlpha := sourceWord >> 24.			srcAlpha = 255 ifTrue:[				"Dither from 32 to 16 bit"				sourceWord := self dither32To16: sourceWord threshold: ditherThreshold.				sourceWord = 0 					ifTrue:[sourceWord := 1 << srcShift]					ifFalse: [sourceWord := sourceWord << srcShift].				"Store masked value"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord := self dstLongAt: dstIndex.					destWord := destWord bitAnd: dstMask bitInvert32.					destWord := destWord >> srcShift.					"Expand from 16 to 32 bit by adding zero bits"					destWord := (((destWord bitAnd: 16r7C00) bitShift: 9) bitOr:									((destWord bitAnd: 16r3E0) bitShift: 6)) bitOr:								(((destWord bitAnd: 16r1F) bitShift: 3) bitOr:									16rFF000000).					"Mix colors"					sourceWord := self alphaBlendScaled: sourceWord with: destWord.					"And dither"					sourceWord := self dither32To16: sourceWord threshold: ditherThreshold.					sourceWord = 0 						ifTrue:[sourceWord := 1 << srcShift]						ifFalse:[sourceWord := sourceWord << srcShift].					"Store back"					self dstLongAt: dstIndex put: sourceWord mask: dstMask.				].			].			srcIndex := srcIndex + 4.			destMSB				ifTrue:[srcShift = 0 ifTrue:[dstIndex := dstIndex + 4]]				ifFalse:[srcShift = 0 ifFalse:[dstIndex := dstIndex + 4]].			srcShift := srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask := dstMask bitInvert32. "Mask other half word"		].		srcY := srcY + 1.		dstY := dstY + 1.	].! !!BitBltPure methodsFor: 'inner loop' stamp: 'tfel 1/17/2014 21:04'!alphaSourceBlendBits32	"This version assumes 		combinationRule = 34		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special cases of srcAlpha = 0.0 and srcAlpha = 1.0 	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY srcY dstY |	"Give the compile a couple of hints"	"The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does)"	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		srcIndex := (srcY * sourcePitch) + (sx).		dstIndex := (dstY * destPitch) + (dx).		deltaX := bbW + 1. "So we can pre-decrement"		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			sourceWord := self srcLongAt: srcIndex.			srcAlpha := sourceWord >> 24.			srcAlpha = 255 ifTrue:[				self dstLongAt: dstIndex put: sourceWord.				srcIndex := srcIndex + 1.				dstIndex := dstIndex + 1.				"Now copy as many words as possible with alpha = 255"				[(deltaX := deltaX - 1) ~= 0 and:[					(sourceWord := self srcLongAt: srcIndex) >> 24 = 255]]						whileTrue:[							self dstLongAt: dstIndex put: sourceWord.							srcIndex := srcIndex + 1.							dstIndex := dstIndex + 1.						].				"Adjust deltaX"				deltaX := deltaX + 1.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[					srcIndex := srcIndex + 1.					dstIndex := dstIndex + 1.					"Now skip as many words as possible,"					[(deltaX := deltaX - 1) ~= 0 and:[						(sourceWord := self srcLongAt: srcIndex) >> 24 = 0]]						whileTrue:[							srcIndex := srcIndex + 1.							dstIndex := dstIndex + 1.						].					"Adjust deltaX"					deltaX := deltaX + 1.				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord := self dstLongAt: dstIndex.					destWord := self alphaBlendScaled: sourceWord with: destWord.					self dstLongAt: dstIndex put: destWord.					srcIndex := srcIndex + 1.					dstIndex := dstIndex + 1.				].			].		].		srcY := srcY + 1.		dstY := dstY + 1.	].! !!BitBltPure methodsFor: 'inner loop' stamp: 'tfel 1/17/2014 19:07'!alphaSourceBlendBits8	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust mappingTable mapperFlags |	mappingTable := self default8To32Table.	mapperFlags := cmFlags bitAnd: ColorMapNewStyle bitInvert32.	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	mask1 := ((dx bitAnd: 3) * 8).	destMSB ifTrue:[mask1 := 24 - mask1].	mask2 := AllOnes bitXor:(16rFF << mask1).	(dx bitAnd: 1) = 0 		ifTrue:[adjust := 0]		ifFalse:[adjust := 16r1F1F1F1F].	(dy bitAnd: 1) = 0		ifTrue:[adjust := adjust bitXor: 16r1F1F1F1F].	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		adjust := adjust bitXor: 16r1F1F1F1F.		srcIndex := sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex := destBits + (dstY * destPitch) + (dx // 4 * 4).		deltaX := bbW + 1. "So we can pre-decrement"		srcShift := mask1.		dstMask := mask2.		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			sourceWord := ((self srcLongAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha := sourceWord >> 24.			srcAlpha > 31 ifTrue:["Everything below 31 is transparent"				srcAlpha < 224 ifTrue:["Everything above 224 is opaque"					destWord := self dstLongAt: dstIndex.					destWord := destWord bitAnd: dstMask bitInvert32.					destWord := destWord >> srcShift.					destWord := mappingTable at: destWord.					sourceWord := self alphaBlendScaled: sourceWord with: destWord.				].				sourceWord := self mapPixel: sourceWord flags: mapperFlags.				sourceWord := sourceWord << srcShift.				"Store back"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			].			srcIndex := srcIndex + 4.			destMSB ifTrue:[				srcShift = 0 					ifTrue:[dstIndex := dstIndex + 4.							srcShift := 24.							dstMask := 16r00FFFFFF]					ifFalse:[srcShift := srcShift - 8.							dstMask := (dstMask >> 8) bitOr: 16rFF000000].			] ifFalse:[				srcShift = 24					ifTrue:[dstIndex := dstIndex + 4.							srcShift := 0.							dstMask := 16rFFFFFF00]					ifFalse:[srcShift := srcShift + 8.							dstMask := dstMask << 8 bitOr: 255].			].			adjust := adjust bitXor: 16r1F1F1F1F.		].		srcY := srcY + 1.		dstY := dstY + 1.	].! !!BitBltPure methodsFor: 'inner loop' stamp: 'tfel 1/18/2014 14:57'!copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask destWord |	"This version of the inner loop assumes noSource = false."	hInc := hDir.	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew := unskew := skewMask := 0]		ifFalse: [skew < 0			ifTrue:				[unskew := skew+32.				skewMask := AllOnes << (0-skew)]			ifFalse:				[skew = 0					ifTrue:						[unskew := 0.						skewMask := AllOnes]					ifFalse:						[unskew := skew-32.						skewMask := AllOnes >> skew]]].	notSkewMask := skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord := AllOnes.  halftoneHeight := 0]		ifFalse: [halftoneWord := self halftoneAt: 0].	y := dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord := self halftoneAt: y.			y := y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord := self srcLongAt: sourceIndex.			sourceIndex := sourceIndex + hInc]			ifFalse:			[prevWord := 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask := mask1.			thisWord := self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex := sourceIndex + hInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord := thisWord.			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord) with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask := AllOnes.combinationRule = 3ifTrue: [(skew = 0) & (halftoneWord = AllOnes)		ifTrue: 		["Very special inner loop for STORE mode with no skew -- just move words"		hDir = -1		ifTrue: ["Woeful patch: revert to older code for hDir = -1"				2 to: nWords-1 do: 					[ :word |					thisWord := self srcLongAt: sourceIndex.					sourceIndex := sourceIndex + hInc.					self dstLongAt: destIndex put: thisWord.					destIndex := destIndex + hInc]]		ifFalse: [2 to: nWords-1 do: 					[ :word |  "Note loop starts with prevWord loaded (due to preload)"					self dstLongAt: destIndex put: prevWord.					destIndex := destIndex + hInc.					prevWord := self srcLongAt: sourceIndex.					sourceIndex := sourceIndex + hInc]]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord := self srcLongAt: sourceIndex.			sourceIndex := sourceIndex + hInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord := thisWord.			self dstLongAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex := destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord := self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex := sourceIndex + hInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord := thisWord.			mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)							with: (self dstLongAt: destIndex).			self dstLongAt: destIndex put: mergeWord.			destIndex := destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask := mask2.			thisWord := self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex := sourceIndex + hInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord) with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + hInc].	sourceIndex := sourceIndex + sourceDelta.	destIndex := destIndex + destDelta]! !!BitBltPure methodsFor: 'inner loop' stamp: 'tfel 1/17/2014 20:36'!copyLoopNoSource	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	| halftoneWord mergeWord destWord |	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord := AllOnes]			ifFalse: [halftoneWord := self halftoneAt: dy+i-1].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask := mask1.			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: halftoneWord							with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr: 							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + 1.		"This central horizontal loop requires no store masking"			destMask := AllOnes.			combinationRule = 3 ifTrue: ["Special inner loop for STORE"				destWord := halftoneWord.				2 to: nWords-1 do:[ :word |					self dstLongAt: destIndex put: destWord.					destIndex := destIndex + 1].			] ifFalse:[ "Normal inner loop does merge"				2 to: nWords-1 do:[ :word | "Normal inner loop does merge"					destWord := self dstLongAt: destIndex.					mergeWord := self mergeFn: halftoneWord with: destWord.					self dstLongAt: destIndex put: mergeWord.					destIndex := destIndex + 1].			].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask := mask2.			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: halftoneWord with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + 1].	destIndex := destIndex + destDelta].! !!BitBltPure methodsFor: 'inner loop' stamp: 'tfel 1/18/2014 14:59'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	"ar 12/7/1999:	The loop has been rewritten to use only one pickSourcePixels call.	The idea is that the call itself could be inlined. If we decide not	to inline pickSourcePixels we could optimize the loop instead."	| skewWord halftoneWord mergeWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nPix srcShift dstShift destWord words srcShiftInc dstShiftInc dstShiftLeft mapperFlags |	"Additional inits peculiar to unequal source and dest pix size..."	sourcePPW := 32//sourceDepth.	sourcePixMask := maskTable at: sourceDepth.	destPixMask := maskTable at: destDepth.	mapperFlags := cmFlags bitAnd: ColorMapNewStyle bitInvert32.	sourceIndex := (sy * sourcePitch) + ((sx // sourcePPW)).	scrStartBits := sourcePPW - (sx bitAnd: sourcePPW-1).	bbW < scrStartBits		ifTrue: [nSourceIncs := 0]		ifFalse: [nSourceIncs := (bbW - scrStartBits)//sourcePPW + 1].	sourceDelta := sourcePitch - (nSourceIncs).	"Note following two items were already calculated in destmask setup!!"	startBits := destPPW - (dx bitAnd: destPPW-1).	endBits := ((dx + bbW - 1) bitAnd: destPPW-1) + 1.	bbW < startBits ifTrue:[startBits := bbW].	"Precomputed shifts for pickSourcePixels"	srcShift := ((sx bitAnd: sourcePPW - 1) * sourceDepth).	dstShift := ((dx bitAnd: destPPW - 1) * destDepth).	srcShiftInc := sourceDepth.	dstShiftInc := destDepth.	dstShiftLeft := 0.	sourceMSB ifTrue:[		srcShift := 32 - sourceDepth - srcShift.		srcShiftInc := 0 - srcShiftInc].	destMSB ifTrue:[		dstShift := 32 - destDepth - dstShift.		dstShiftInc := 0 - dstShiftInc.		dstShiftLeft := 32 - destDepth].	1 to: bbH do: "here is the vertical loop"		[ :i |		"*** is it possible at all that noHalftone == false? ***"		noHalftone			ifTrue:[halftoneWord := AllOnes]			ifFalse: [halftoneWord := self halftoneAt: dy+i-1].		"setup first load"		srcBitShift := srcShift.		dstBitShift := dstShift.		destMask := mask1.		nPix := startBits.		"Here is the horizontal loop..."		words := nWords.			["pick up the word"			skewWord := self pickSourcePixels: nPix flags: mapperFlags 								srcMask: sourcePixMask destMask: destPixMask								srcShiftInc: srcShiftInc dstShiftInc: dstShiftInc.			"align next word to leftmost pixel"			dstBitShift := dstShiftLeft.			destMask = AllOnes ifTrue:["avoid read-modify-write"				mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)								with: (self dstLongAt: destIndex).				self dstLongAt: destIndex put: (destMask bitAnd: mergeWord).			] ifFalse:[ "General version using dest masking"				destWord := self dstLongAt: destIndex.				mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)								with: (destWord bitAnd: destMask).				destWord := (destMask bitAnd: mergeWord) bitOr:								(destWord bitAnd: destMask bitInvert32).				self dstLongAt: destIndex put: destWord.			].			destIndex := destIndex + 1.			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask := mask2.						nPix := endBits]				ifFalse:["use fullword mask for inner loop"						destMask := AllOnes.						nPix := destPPW].			(words := words - 1) = 0] whileFalse.		"--- end of inner loop ---"		sourceIndex := sourceIndex + sourceDelta.		destIndex := destIndex + destDelta]! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 20:32'!checkSourceOverlap	"check for possible overlap of source and destination"	"ar 10/19/1999: This method requires surfaces to be locked."	| t |	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir := -1.			sy := sy + bbH - 1.			dy := dy + bbH - 1]		ifFalse:			[(dy = sy) & (dx > sx) ifTrue:				["y's are equal, but x's are backward"				hDir := -1.				sx := sx + bbW - 1.				"start at right"				dx := dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t := mask1.					mask1 := mask2.					mask2 := t]]].		"Dest inits may be affected by this change"		destIndex := (dy * destPitch) + ((dx // destPPW)).		destDelta := (destPitch * vDir) - ((nWords * hDir))]! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 19:52'!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	destX >= clipX		ifTrue: [sx := sourceX.				dx := destX.				bbW := width]		ifFalse: [sx := sourceX + (clipX - destX).				bbW := width - (clipX - destX).				dx := clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW := bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy := sourceY.				dy := destY.				bbH := height]		ifFalse: [sy := sourceY + clipY - destY.				bbH := height - (clipY - destY).				dy := clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH := bbH - ((dy + bbH) - (clipY + clipHeight))].	noSource = true ifTrue: [^ nil].	sx < 0		ifTrue: [dx := dx - sx.				bbW := bbW + sx.				sx := 0].	sx + bbW > sourceWidth		ifTrue: [bbW := bbW - (sx + bbW - sourceWidth)].	sy < 0		ifTrue: [dy := dy - sy.				bbH := bbH + sy.				sy := 0].	sy + bbH > sourceHeight		ifTrue: [bbH := bbH - (sy + bbH - sourceHeight)]! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/18/2014 16:04'!copyBits	"This function is exported for the Balloon engine"	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL := affectedR := affectedT := affectedB := 0.		^ true].	"Lock the surfaces"	^ self copyBitsLockedAndClipped.! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 19:08'!copyBits: op Fallback: flags! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 19:08'!copyBitsFastPathSpecialised	"Perform the actual copyBits operation using the fast path specialised code; fail some cases by falling back to normal code.	Assume: Surfaces have been locked and clipping was performed."! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/18/2014 15:44'!copyBitsFrom: startX to: stopX at: yValue	"Support for the balloon engine."	destX := startX.	destY := yValue.	sourceX := startX.	width := (stopX - startX).	self copyBits.	self showDisplayBits.! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 20:36'!copyBitsLockedAndClipped	"Perform the actual copyBits operation.	Assume: Surfaces have been locked and clipping was performed."	| done |	self copyBitsRule41Test ifFalse: [^ false]. 	"Try a shortcut for stuff that should be run as quickly as possible"	done := self tryCopyingBitsQuickly.	done ifTrue:[^ true].	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy methodArgumentCount = 1			ifTrue: [sourceAlpha := interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	bitCount := 0.	"Choose and perform the actual copy loop."	self performCopyLoop.	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL := affectedR := affectedT := affectedB := 0]. 	hDir > 0		ifTrue: [affectedL := dx.				affectedR := dx + bbW]		ifFalse: [affectedL := dx - bbW + 1.				affectedR := dx + 1].	vDir > 0		ifTrue: [affectedT := dy.				affectedB := dy + bbH]		ifFalse: [affectedT := dy - bbH + 1.				affectedB := dy + 1].	^ true! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 19:56'!copyBitsRule41Test	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	| gammaLookupTableOop ungammaLookupTableOop |	combinationRule = 41		ifTrue:["fetch the forecolor into componentAlphaModeColor."			componentAlphaModeAlpha := 255.			componentAlphaModeColor := 16777215.			gammaLookupTable := nil.			ungammaLookupTable := nil.			interpreterProxy methodArgumentCount >= 2				ifTrue:[					componentAlphaModeAlpha := interpreterProxy stackIntegerValue: (interpreterProxy methodArgumentCount - 2).					(interpreterProxy failed not)						ifFalse: [^ interpreterProxy primitiveFail].					componentAlphaModeColor := interpreterProxy stackIntegerValue: (interpreterProxy methodArgumentCount - 1).					(interpreterProxy failed not)						ifFalse: [^ interpreterProxy primitiveFail].					interpreterProxy methodArgumentCount = 4						ifTrue:[							gammaLookupTableOop := interpreterProxy stackObjectValue: 1.							(interpreterProxy isBytes: gammaLookupTableOop) 								ifTrue:[gammaLookupTable := interpreterProxy firstIndexableField: gammaLookupTableOop.].							ungammaLookupTableOop := interpreterProxy stackObjectValue: 0.							(interpreterProxy isBytes: ungammaLookupTableOop) 								ifTrue:[ungammaLookupTable := interpreterProxy firstIndexableField: ungammaLookupTableOop]]]				ifFalse:[					interpreterProxy methodArgumentCount = 1						ifTrue: [							componentAlphaModeColor := interpreterProxy stackIntegerValue: 0.							(interpreterProxy failed not)								ifFalse: [^ interpreterProxy primitiveFail]]						ifFalse:[^ interpreterProxy primitiveFail]]].		^ true! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 20:33'!destMaskAndPointerInit	"Compute masks for left and right destination words"	| startBits pixPerM1 endBits |	pixPerM1 := destPPW - 1.  "A mask, assuming power of two"	"how many pixels in first word"	startBits := destPPW - (dx bitAnd: pixPerM1).	destMSB		ifTrue:[ mask1 := AllOnes >> (32 - (startBits*destDepth))] 		ifFalse:[ mask1 := AllOnes << (32 - (startBits*destDepth))].	"how many pixels in last word"	endBits := ((dx + bbW - 1) bitAnd: pixPerM1) + 1.	destMSB 		ifTrue:[mask2 := AllOnes << (32 - (endBits*destDepth))] 		ifFalse:[mask2 := AllOnes >> (32 - (endBits*destDepth))].	"determine number of words stored per line; merge masks if only 1"	bbW < startBits		ifTrue: [mask1 := mask1 bitAnd: mask2.				mask2 := 0.				nWords := 1]		ifFalse: [nWords := (bbW - startBits) + pixPerM1 // destPPW + 1].	hDir := vDir := 1. "defaults for no overlap with source"	"calculate byte addr and delta, based on first word of data"	"Note pitch is bytes and nWords is longs, not bytes"	destIndex := (dy * destPitch) + ((dx // destPPW)).	destDelta := destPitch * vDir - ((nWords * hDir)).  "byte addr delta"! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 19:16'!ignoreSourceOrHalftone: formPointer	formPointer = nil ifTrue: [ ^true ].	combinationRule = 0 ifTrue: [ ^true ].	combinationRule = 5 ifTrue: [ ^true ].	combinationRule = 10 ifTrue: [ ^true ].	combinationRule = 15 ifTrue: [ ^true ].	^false! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 20:35'!performCopyLoop	"Based on the values provided during setup choose and	perform the appropriate inner loop function."	self destMaskAndPointerInit.	^ noSource ifTrue: ["Simple fill loop"		self copyLoopNoSource.	] ifFalse: ["Loop using source and dest"		self checkSourceOverlap.		(sourceDepth ~= destDepth or: [(cmFlags ~= 0) or:[sourceMSB ~= destMSB]]) ifTrue: [			"If we must convert between pixel depths or use			color lookups or swap pixels use the general version"			self copyLoopPixMap.		] ifFalse: [			"Otherwise we simple copy pixels and can use a faster version"			self sourceSkewAndPointerInit.			self copyLoop.		]	].! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 20:32'!sourceSkewAndPointerInit	"This is only used when source and dest are same depth,	ie, when the barrel-shift copy loop is used."	| dWid sxLowBits dxLowBits pixPerM1 |	pixPerM1 := destPPW - 1.  "A mask, assuming power of two"	sxLowBits := sx bitAnd: pixPerM1.	dxLowBits := dx bitAnd: pixPerM1.	"check if need to preload buffer	(i.e., two words of source needed for first word of destination)"	hDir > 0 ifTrue:		["n Bits stored in 1st word of dest"		dWid := bbW min: destPPW - dxLowBits.		preload := (sxLowBits + dWid) > pixPerM1]	ifFalse:		[dWid := bbW min: dxLowBits + 1.		preload := (sxLowBits - dWid + 1) < 0].	"calculate right-shift skew from source to dest"	sourceMSB		ifTrue:[skew := (sxLowBits - dxLowBits) * destDepth] 		ifFalse:[skew := (dxLowBits - sxLowBits) * destDepth].  " -32..32 "	preload ifTrue: 		[skew < 0			ifTrue: [skew := skew+32]			ifFalse: [skew := skew-32]].	"Calc byte addr and delta from longWord info"	sourceIndex := (sy * sourcePitch) + ((sx // (32//sourceDepth))).	"calculate increments from end of 1 line to start of next"	sourceDelta := (sourcePitch * vDir) - ((nWords * hDir)).	preload ifTrue:		["Compensate for extra source word fetched"		sourceDelta := sourceDelta - (hDir)].! !!BitBltPure methodsFor: 'setup' stamp: 'tfel 1/17/2014 19:13'!tryCopyingBitsQuickly	"Shortcut for stuff that's being run from the balloon engine.	Since we do this at each scan line we should avoid the expensive 	setup for source and destination."	"We need a source."	noSource ifTrue:[^false].	"We handle only combinationRule 34 and combinationRule 41"		(combinationRule = 34 or:[combinationRule = 41]) ifFalse:[^false].	"We handle only sourceDepth 32"	(sourceDepth = 32) ifFalse:[^false].	"We don't handle overlaps"	(sourceForm = destForm) ifTrue:[^false].		(combinationRule = 41)		ifTrue:[			destDepth = 32 				ifTrue:[					self rgbComponentAlpha32.					affectedL := dx.					affectedR := dx + bbW.					affectedT := dy.					affectedB := dy + bbH.					^true].			destDepth = 16 				ifTrue:[					self rgbComponentAlpha16.					affectedL := dx.					affectedR := dx + bbW.					affectedT := dy.					affectedB := dy + bbH.					^true].			destDepth = 8 				ifTrue:[					self rgbComponentAlpha8.					affectedL := dx.					affectedR := dx + bbW.					affectedT := dy.					affectedB := dy + bbH.					^true].			^false].		"We need at least 8bit deep dest forms"	(destDepth < 8) ifTrue:[^false].	"If 8bit, then we want a color map"	(destDepth = 8 and:[(cmFlags bitAnd: ColorMapPresent) = 0]) ifTrue:[^false].	destDepth = 32 		ifTrue:[self alphaSourceBlendBits32].	destDepth = 16		ifTrue:[self alphaSourceBlendBits16].	destDepth = 8		ifTrue:[self alphaSourceBlendBits8].	affectedL := dx.	affectedR := dx + bbW.	affectedT := dy.	affectedB := dy + bbH.	^true! !!BitBltPure methodsFor: 'pixel mapping' stamp: 'tfel 1/18/2014 15:46'!default8To32Table	"Return the default translation table from 1..8 bit indexed colors to 32bit"	"The table has been generated by the following statements"	"| pvs hex |	String streamContents:[:s|		s nextPutAll:'static unsigned int theTable[256] = { '.		pvs := (Color colorMapIfNeededFrom: 8 to: 32) asArray.		1 to: pvs size do:[:i|			i > 1 ifTrue:[s nextPutAll:', '].			(i-1 \\ 8) = 0 ifTrue:[s cr].			s nextPutAll:'0x'.			hex := (pvs at: i) printStringBase: 16.			s nextPutAll: (hex copyFrom: 4 to: hex size).		].		s nextPutAll:'};'.	]."	| theTable |	^theTable! !!BitBltPure methodsFor: 'pixel mapping' stamp: 'tfel 1/17/2014 19:09'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments."	x2 > x1		ifTrue: [^ x2 - x1 + FixedPt1 // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + FixedPt1 // (n+1) + 1)]! !!BitBltPure methodsFor: 'pixel mapping' stamp: 'tfel 1/18/2014 15:09'!dither32To16: srcWord threshold: ditherValue	"Dither the given 32bit word to 16 bit. Ignore alpha."	| addThreshold  |	addThreshold := ditherValue bitShift: 8.	^((dither8Lookup at: ((addThreshold+((srcWord bitShift: -16) bitAnd: 255)) + 1)) bitShift: 10) + 		((dither8Lookup at: ((addThreshold+((srcWord bitShift: -8) bitAnd: 255))+ 1)) bitShift: 5) + 		(dither8Lookup at: ((addThreshold+(srcWord bitAnd: 255)) + 1)).! !!BitBltPure methodsFor: 'pixel mapping' stamp: 'tfel 1/17/2014 19:12'!pickWarpPixelAtX: xx y: yy	"Pick a single pixel from the source for WarpBlt.	Note: This method is crucial for WarpBlt speed w/o smoothing	and still relatively important when smoothing is used."	| x y srcIndex sourceWord sourcePix |	"note: it would be much faster if we could just	avoid these stupid tests for being inside sourceForm."	(xx < 0 or:[yy < 0 or:[		(x := xx >> BinaryPoint) >= sourceWidth or:[			(y := yy >> BinaryPoint) >= sourceHeight]]]) ifTrue:[^0]. "out of bounds"	"Fetch source word.	Note: We should really update srcIndex with sx and sy so that	we don't have to do the computation below. We might even be	able to simplify the out of bounds test from above."	srcIndex := sourceBits + (y * sourcePitch) + (x >> warpAlignShift * 4).	sourceWord := self srcLongAt: srcIndex.	"Extract pixel from word"	srcBitShift := warpBitShiftTable at: (x bitAnd: warpAlignMask).	sourcePix := sourceWord >> srcBitShift bitAnd: warpSrcMask.	^sourcePix! !!BitBltPure methodsFor: 'pixel mapping' stamp: 'tfel 1/17/2014 19:12'!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	(d := nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask := (1 << nBitsIn) - 1.  "Transfer mask"			srcPix := sourcePixel << d.			mask := mask << d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue:				[nBitsIn = 5 ifTrue:					["Sometimes called with 16 bits, though pixel is 15,					but we must never return more than 15."					^ sourcePixel bitAnd: 16r7FFF].				nBitsIn = 8 ifTrue:					["Sometimes called with 32 bits, though pixel is 24,					but we must never return more than 24."					^ sourcePixel bitAnd: 16rFFFFFF].				^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d := nBitsIn - nBitsOut.			mask := (1 << nBitsOut) - 1.  "Transfer mask"			srcPix := sourcePixel >> d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix >> d.			destPix := destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !!BitBltPure methodsFor: 'pixel mapping' stamp: 'tfel 1/17/2014 19:13'!warpLoopSetup	"Setup values for faster pixel fetching."	| words |	"warpSrcShift = log2(sourceDepth)"	warpSrcShift := 0.	words := sourceDepth. "recycle temp"	[words = 1] whileFalse:[		warpSrcShift := warpSrcShift + 1.		words := words >> 1].	"warpSrcMask = mask for extracting one pixel from source word"	warpSrcMask := maskTable at: sourceDepth.	"warpAlignShift: Shift for aligning x position to word boundary"	warpAlignShift := 5 - warpSrcShift.	"warpAlignMask: Mask for extracting the pixel position from an x position"	warpAlignMask := 1 << warpAlignShift - 1.	"Setup the lookup table for source bit shifts"	"warpBitShiftTable: given an sub-word x value what's the bit shift?"	0 to: warpAlignMask do:[:i|		sourceMSB			ifTrue:[warpBitShiftTable at: i put: 32 - ( i + 1 << warpSrcShift )]			ifFalse:[warpBitShiftTable at: i put: (i << warpSrcShift)]].! !!BitBltPure methodsFor: 'pixel mapping' stamp: 'tfel 1/17/2014 19:13'!warpPickSmoothPixels: nPixels	xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	sourceMap: sourceMap	smoothing: n	dstShiftInc: dstShiftInc	"Pick n (sub-) pixels from the source form, mapped by sourceMap,	average the RGB values, map by colorMap and return the new word.	This version is only called from WarpBlt with smoothingCount > 1"	| rgb x y a r g b xx yy xdh ydh xdv ydv dstMask destWord i j k nPix |	dstMask := maskTable at: destDepth.	destWord := 0.	n = 2 "Try avoiding divides for most common n (divide by 2 is generated as shift)"		ifTrue:[xdh := xDeltah // 2. ydh := yDeltah // 2. 				xdv := xDeltav // 2. ydv := yDeltav // 2]		ifFalse:[xdh := xDeltah // n. ydh := yDeltah // n. 				xdv := xDeltav // n. ydv := yDeltav // n].	i := nPixels.	[		x := sx. y := sy.		a := r := g := b := 0.		"Pick and average n*n subpixels"		nPix := 0.  "actual number of pixels (not clipped and not transparent)"		j := n.		[			xx := x. yy := y.			k := n.			[				"get a single subpixel"				rgb := self pickWarpPixelAtX: xx y: yy.				(combinationRule=25 "PAINT" and: [rgb = 0]) ifFalse:[					"If not clipped and not transparent, then tally rgb values"					nPix := nPix + 1.					sourceDepth < 16 ifTrue:[						"Get RGBA values from sourcemap table"						rgb := self long32At: sourceMap + (rgb << 2).					] ifFalse:["Already in RGB format"						sourceDepth = 16 								ifTrue:[rgb := self rgbMap16To32: rgb]								ifFalse:[rgb := self rgbMap32To32: rgb]].					b := b + (rgb bitAnd: 255).					g := g + (rgb >> 8 bitAnd: 255).					r := r + (rgb >> 16 bitAnd: 255).					a := a + (rgb >> 24)].				xx := xx + xdh.				yy := yy + ydh.			(k := k - 1) = 0] whileFalse.			x := x + xdv.			y := y + ydv.		(j := j - 1) = 0] whileFalse.		(nPix = 0 or: [combinationRule=25 "PAINT" and: [nPix < (n * n // 2)]]) ifTrue:[			rgb := 0  "All pixels were 0, or most were transparent"		] ifFalse:[			"normalize rgba sums"			nPix = 4 "Try to avoid divides for most common n"				ifTrue:[r := r >> 2.	g := g >> 2.	b := b >> 2.	a := a >> 2]				ifFalse:[	r := r // nPix.	g := g // nPix.	b := b // nPix.	a := a // nPix].			rgb := (a << 24) + (r << 16) + (g << 8) + b.			"map the pixel"			rgb = 0 ifTrue: [				"only generate zero if pixel is really transparent"				(r + g + b + a) > 0 ifTrue: [rgb := 1]].			rgb := self mapPixel: rgb flags: cmFlags.		].		"Mix it in"		destWord := destWord bitOr: (rgb bitAnd: dstMask) << dstBitShift.		dstBitShift := dstBitShift + dstShiftInc.		sx := sx + xDeltah.		sy := sy + yDeltah.	(i := i - 1) = 0] whileFalse.	^destWord! !!BitBltPure methodsFor: 'pixel mapping' stamp: 'tfel 1/17/2014 19:13'!warpPickSourcePixels: nPixels	xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	dstShiftInc: dstShiftInc	flags: mapperFlags	"Pick n pixels from the source form,	map by colorMap and return aligned by dstBitShift.	This version is only called from WarpBlt with smoothingCount = 1"	| dstMask destWord nPix sourcePix destPix |	dstMask := maskTable at: destDepth.	destWord := 0.	nPix := nPixels.	(mapperFlags = (ColorMapPresent bitOr: ColorMapIndexedPart)) ifTrue:[		"a little optimization for (pretty crucial) blits using indexed lookups only"		[	"grab, colormap and mix in pixel"			sourcePix := self pickWarpPixelAtX: sx y: sy.			destPix := cmLookupTable at: (sourcePix bitAnd: cmMask).			destWord := destWord bitOr: (destPix bitAnd: dstMask) << dstBitShift.			dstBitShift := dstBitShift + dstShiftInc.			sx := sx + xDeltah.			sy := sy + yDeltah.		(nPix := nPix - 1) = 0] whileFalse.	] ifFalse:[		[	"grab, colormap and mix in pixel"			sourcePix := self pickWarpPixelAtX: sx y: sy.			destPix := self mapPixel: sourcePix flags: mapperFlags.			destWord := destWord bitOr: (destPix bitAnd: dstMask) << dstBitShift.			dstBitShift := dstBitShift + dstShiftInc.			sx := sx + xDeltah.			sy := sy + yDeltah.		(nPix := nPix - 1) = 0] whileFalse.	].	^destWord! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:01'!drawLoopX: xDelta Y: yDelta 	"This is the primitive implementation of the line-drawing loop.	See the comments in BitBlt>>drawLoopX:Y:"	| dx1 dy1 px py P affL affR affT affB |	xDelta > 0		ifTrue: [dx1 := 1]		ifFalse: [xDelta = 0				ifTrue: [dx1 := 0]				ifFalse: [dx1 := -1]].	yDelta > 0		ifTrue: [dy1 := 1]		ifFalse: [yDelta = 0				ifTrue: [dy1 := 0]				ifFalse: [dy1 := -1]].	px := yDelta abs.	py := xDelta abs.	affL := affT := 9999.  "init null rectangle"	affR := affB := -9999.	py > px		ifTrue: 			["more horizontal"			P := py // 2.			1 to: py do: 				[:i |				destX := destX + dx1.				(P := P - px) < 0 ifTrue: 					[destY := destY + dy1.					P := P + py].				i < py ifTrue:					[self copyBits.					interpreterProxy failed ifTrue:						[^ nil "bail out now on failure -- avoid storing x,y"].					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL := affL min: affectedL.						affR := affR max: affectedR.						affT := affT min: affectedT.						affB := affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL := affL.  affectedR := affR.							affectedT := affT.  affectedB := affB.							self showDisplayBits.							affL := affT := 9999.  "init null rectangle"							affR := affB := -9999]].					]]]		ifFalse: 			["more vertical"			P := px // 2.			1 to: px do:				[:i |				destY := destY + dy1.				(P := P - py) < 0 ifTrue: 					[destX := destX + dx1.					P := P + px].				i < px ifTrue:					[self copyBits.					interpreterProxy failed ifTrue:						[^ nil "bail out now on failure -- avoid storing x,y"].					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL := affL min: affectedL.						affR := affR max: affectedR.						affT := affT min: affectedT.						affB := affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL := affL.  affectedR := affR.							affectedT := affT.  affectedB := affB.							self showDisplayBits.							affL := affT := 9999.  "init null rectangle"							affR := affB := -9999]].					]]].	"Remaining affected rect"	affectedL := affL.  affectedR := affR.	affectedT := affT.  affectedB := affB.	"store destX, Y back"		interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.	interpreterProxy storeInteger: BBDestYIndex ofObject: bitBltOop withValue: destY.! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:16'!fetchIntOrFloat: fieldIndex ofObject: objectPointer	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	| fieldOop floatValue |	fieldOop := interpreterProxy fetchPointer: fieldIndex ofObject: objectPointer.	(interpreterProxy isIntegerObject: fieldOop)		ifTrue:[^interpreterProxy integerValueOf: fieldOop].	floatValue := interpreterProxy floatValueOf: fieldOop.	(-2147483648.0 <= floatValue and:[floatValue <= 2147483647.0])		ifFalse:[interpreterProxy primitiveFail. ^0].	^floatValue asInteger! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:16'!fetchIntOrFloat: fieldIndex ofObject: objectPointer ifNil: defaultValue	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	| fieldOop floatValue |	fieldOop := interpreterProxy fetchPointer: fieldIndex ofObject: objectPointer.	(interpreterProxy isIntegerObject: fieldOop)		ifTrue:[^interpreterProxy integerValueOf: fieldOop].	(fieldOop = interpreterProxy nilObject) ifTrue:[^defaultValue].	floatValue := interpreterProxy floatValueOf: fieldOop.	(-2147483648.0 <= floatValue and:[floatValue <= 2147483647.0])		ifFalse:[interpreterProxy primitiveFail. ^0].	^floatValue asInteger! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:32'!isIdentityMap: shifts with: masks	"Return true if shiftTable/maskTable define an identity mapping."	(shifts == nil or:[masks == nil]) ifTrue:[^true].	((shifts at: RedIndex) = 0 		and:[(shifts at: GreenIndex) = 0		and:[(shifts at: BlueIndex) = 0 		and:[(shifts at: AlphaIndex) = 0			and:[((masks at: RedIndex) = 16rFF0000)			and:[((masks at: GreenIndex) = 16r00FF00)			and:[((masks at: BlueIndex) = 16r0000FF)			and:[((masks at: AlphaIndex) = 16rFF000000)]]]]]]])		ifTrue:[^true].	^false! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 20:11'!loadBitBltDestForm	"Load the dest form for BitBlt. Return false if anything is wrong, true otherwise."	| destBitsSize |	destBits := destForm bits.	destWidth := destForm width.	destHeight := destForm height.	(destWidth >= 0 and: [destHeight >= 0])		ifFalse: [^ false].	destDepth := destForm depth.	destMSB := destDepth > 0.	destDepth < 0 ifTrue:[destDepth := 0 - destDepth].	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	destBits isInteger ifTrue:[		^ false	] ifFalse:[		destPPW := 32 // destDepth.		destPitch := destWidth + (destPPW-1) // destPPW.		destBitsSize := destBits size.		((destBits class isWords or: [destBits class isBytes])			and: [destBitsSize = (destPitch * destHeight)])			ifFalse: [^ false].	].	^true! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 20:08'!loadBitBltFrom: bbObj	"Load BitBlt from the oop.	This function is exported for the Balloon engine."	^self loadBitBltFrom: bbObj warping: false.! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:24'!loadBitBltFrom: bbObj warping: aBool	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| ok |	bitBltOop := bbObj.	isWarping := aBool.	(combinationRule < 0 or: [combinationRule > (OpTableSize - 2)])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	noSource := self ignoreSourceOrHalftone: sourceForm.	noHalftone := self ignoreSourceOrHalftone: halftoneForm.	(destForm class isPointers)		ifFalse: [^ false].	ok := self loadBitBltDestForm.	ok ifFalse:[^false].	destX ifNil: [destX := 0].	destY ifNil: [destY := 0].	noSource ifTrue:		[sourceX := sourceY := 0]		ifFalse: 		[(sourceForm class isPointers)			ifFalse: [^ false].		ok := self loadBitBltSourceForm.		ok ifFalse:[^false].		ok := self loadColorMap.		ok ifFalse:[^false].		"Need the implicit setup here in case of 16<->32 bit conversions"		(cmFlags bitAnd: ColorMapNewStyle) = 0 ifTrue:[self setupColorMasks].		sourceX ifNil: [sourceX := 0].		sourceY ifNil: [sourceY := 0]].	ok := self loadHalftoneForm.	ok ifFalse:[^false].	clipX ifNil: [clipX := 0].	clipY ifNil: [clipY := 0].	clipX < 0 ifTrue: [clipWidth := clipWidth + clipX.  clipX := 0].	clipY < 0 ifTrue: [clipHeight := clipHeight + clipY.  clipY := 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth := destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight := destHeight - clipY].	^ true! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 20:12'!loadBitBltSourceForm	"Load the source form for BitBlt. Return false if anything is wrong, true otherwise."	| sourceBitsSize |	sourceBits := sourceForm bits.	sourceWidth := sourceForm width.	sourceHeight := sourceForm height.	(sourceWidth >= 0 and: [sourceHeight >= 0])		ifFalse: [^ false].	sourceDepth := sourceForm depth.	sourceMSB := sourceDepth > 0.	sourceDepth < 0 ifTrue:[sourceDepth := 0 - sourceDepth].	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(sourceBits isInteger) ifTrue:[^ false]	ifFalse:[		sourcePPW := 32 // sourceDepth.		sourcePitch := sourceWidth + (sourcePPW-1) // sourcePPW.		sourceBitsSize := sourceBits size.		((sourceBits class isWords or: [sourceBits class isBytes])			and: [sourceBitsSize = (sourcePitch * sourceHeight)])			ifFalse: [^ false].	].	^true! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:31'!loadColorMap	"ColorMap, if not nil, must be longWords, and 	2^N long, where N = sourceDepth for 1, 2, 4, 8 bits, 	or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."	| cmSize oldStyle oop cmOop |	cmFlags := cmMask := cmBitsPerColor := 0.	cmShiftTable := nil.	cmMaskTable := nil.	cmLookupTable := nil.	cmOop := nil.	cmOop = nil ifTrue:[^true].	cmFlags := ColorMapPresent. "even if identity or somesuch - may be cleared later"	oldStyle := false.	(cmOop class isWords) ifTrue:[		"This is an old-style color map (indexed only, with implicit RGBA conversion)"		cmSize := cmOop basicSize + cmOop class instSize.		cmLookupTable := cmOop.		oldStyle := true.		self assert: cmLookupTable unitSize = 4.	] ifFalse: [		"A new-style color map (fully qualified)"		((cmOop class isPointers) 			and:[(cmOop class instSize) >= 3]) ifFalse:[^false].		cmShiftTable := self loadColorMapShiftOrMaskFrom:			(cmOop instVarAt: 1).		cmMaskTable := self loadColorMapShiftOrMaskFrom:			(cmOop instVarAt: 2).		oop := cmOop instVarAt: 3.		oop = nil			ifTrue:[cmSize := 0]			ifFalse:[(oop class isWords) ifFalse:[^false].					cmSize := (oop basicSize + oop class instSize).					cmLookupTable := oop].		cmFlags := cmFlags bitOr: ColorMapNewStyle.		self assert: cmShiftTable unitSize = 4.		self assert: cmMaskTable unitSize = 4.		self assert: cmLookupTable unitSize = 4.	].	(cmSize bitAnd: cmSize - 1) = 0 ifFalse:[^false].	cmMask := cmSize - 1.	cmBitsPerColor := 0.	cmSize = 512 ifTrue: [cmBitsPerColor := 3].	cmSize = 4096 ifTrue: [cmBitsPerColor := 4].	cmSize = 32768 ifTrue: [cmBitsPerColor := 5].	cmSize = 0		ifTrue:[cmLookupTable := nil. cmMask := 0]		ifFalse:[cmFlags := cmFlags bitOr: ColorMapIndexedPart].	oldStyle "needs implicit conversion"		ifTrue:[	self setupColorMasks].	"Check if colorMap is just identity mapping for RGBA parts"	(self isIdentityMap: cmShiftTable with: cmMaskTable)		ifTrue:[ cmMaskTable := nil. cmShiftTable := nil ]		ifFalse:[ cmFlags := cmFlags bitOr: ColorMapFixedPart].	^true! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:33'!loadColorMapShiftOrMaskFrom: mapOop		mapOop = nil ifTrue:[^nil].	(mapOop isInteger) 		ifTrue:[^ nil].	((mapOop class isWords) 		and:[(mapOop basicSize + mapOop class instSize) = 4])			ifFalse:[^ nil].	^ mapOop! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 20:38'!loadHalftoneForm	"Load the halftone form"	| halftoneBits |	noHalftone ifTrue:[		halftoneBase := nil.		^true].	((halftoneForm class isPointers) and: [(halftoneForm basicSize + halftoneForm class instSize) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits := halftoneForm bits.		halftoneHeight := halftoneForm height.		(halftoneBits class isWords)			ifFalse: [noHalftone := true]]		ifFalse:		["New spec accepts, basically, a word array"		((halftoneForm class isPointers) not			and: [halftoneForm class isWords])			ifFalse: [^ false].		halftoneBits := halftoneForm.		halftoneHeight := halftoneBits basicSize + halftoneBits class instSize].	halftoneBase := halftoneBits.	^true! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:01'!loadWarpBltFrom: bbObj	^self loadBitBltFrom: bbObj warping: true! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 19:01'!setupColorMasks	"WARNING: For WarpBlt w/ smoothing the source depth is wrong here!!"	| bits targetBits |	bits := targetBits := 0.	sourceDepth <= 8 ifTrue:[^nil].	sourceDepth = 16 ifTrue:[bits := 5].	sourceDepth = 32 ifTrue:[bits := 8].	cmBitsPerColor = 0		ifTrue:["Convert to destDepth"				destDepth <= 8 ifTrue:[^nil].				destDepth = 16 ifTrue:[targetBits := 5].				destDepth = 32 ifTrue:[targetBits := 8]]		ifFalse:[targetBits := cmBitsPerColor].	self setupColorMasksFrom: bits to: targetBits! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/18/2014 15:42'!setupColorMasksFrom: srcBits to: targetBits	"Setup color masks for converting an incoming RGB pixel value from srcBits to targetBits."	| mask shifts masks deltaBits |		shifts := (IntegerArray new: 4).	masks := (WordArray new: 4).	deltaBits := targetBits - srcBits.	deltaBits = 0 ifTrue:[^0].	deltaBits <= 0		ifTrue:[	mask := 1 << targetBits - 1.				"Mask for extracting a color part of the source"				masks at: RedIndex + 1 put: mask << (srcBits*2 - deltaBits).				masks at: GreenIndex + 1 put: mask << (srcBits - deltaBits).				masks at: BlueIndex + 1 put: mask << (0 - deltaBits).				masks at: AlphaIndex + 1 put: 0]		ifFalse:[	mask := 1 << srcBits - 1.				"Mask for extracting a color part of the source"				masks at: RedIndex + 1 put: mask << (srcBits*2).				masks at: GreenIndex + 1 put: mask << srcBits.				masks at: BlueIndex + 1 put: mask].	"Shifts for adjusting each value in a cm RGB value"	shifts at: RedIndex + 1 put: deltaBits * 3.	shifts at: GreenIndex + 1 put: deltaBits * 2.	shifts at: BlueIndex + 1 put: deltaBits.	shifts at: AlphaIndex + 1 put: 0.	cmShiftTable := shifts.	cmMaskTable := masks.	cmFlags := cmFlags bitOr: (ColorMapPresent bitOr: ColorMapFixedPart).! !!BitBltPure methodsFor: 'interpreter interface' stamp: 'tfel 1/17/2014 20:37'!showDisplayBits	^ true! !!BitBltPure methodsFor: 'memory access' stamp: 'tfel 1/17/2014 20:03'!dstLongAt: idx	^ destBits at: idx + 1! !!BitBltPure methodsFor: 'memory access' stamp: 'tfel 1/17/2014 20:14'!dstLongAt: idx put: value	destBits size <= idx ifTrue: [1 halt. "too large" ^ value].	^ destBits at: idx + 1 put: value! !!BitBltPure methodsFor: 'memory access' stamp: 'tfel 1/17/2014 19:09'!dstLongAt: idx put: srcValue mask: dstMask	"Store the given value back into destination form, using dstMask	to mask out the bits to be modified. This is an essiantial	read-modify-write operation on the destination form."	| dstValue |	dstValue := self dstLongAt: idx.	dstValue := dstValue bitAnd: dstMask.	dstValue := dstValue bitOr: srcValue.	self dstLongAt: idx put: dstValue.! !!BitBltPure methodsFor: 'memory access' stamp: 'tfel 1/18/2014 14:59'!halftoneAt: idx	"Return a value from the halftone pattern."	^ halftoneBase at: (idx \\ halftoneHeight) + 1! !!BitBltPure methodsFor: 'memory access' stamp: 'tfel 1/17/2014 20:42'!srcLongAt: idx	sourceBits size = idx ifTrue: ["one over ok?"		^ sourceBits at: idx].	^ sourceBits at: idx + 1! !!BitBltPure methodsFor: 'memory access' stamp: 'tfel 1/17/2014 20:04'!tallyMapAt: idx	"Return the word at position idx from the colorMap"	^cmLookupTable at: (idx bitAnd: cmMask) + 1! !!BitBltPure methodsFor: 'memory access' stamp: 'tfel 1/17/2014 19:01'!tallyMapAt: idx put: value	"Store the word at position idx in the colorMap"	^cmLookupTable at: (idx bitAnd: cmMask) put: value! !!BitBltPure methodsFor: 'initialize-release' stamp: 'tfel 1/18/2014 17:55'!initBBOpTable	opTable := OpTable.	maskTable := MaskTable.	self initializeDitherTables.	warpBitShiftTable := (Array new: 32).! !!BitBltPure methodsFor: 'initialize-release' stamp: 'tfel 1/18/2014 17:57'!initialize	self initBBOpTable.! !!BitBltPure methodsFor: 'initialize-release' stamp: 'tfel 1/18/2014 17:59'!initializeDitherTables	ditherMatrix4x4 := DitherMatrix4x4.	ditherThresholds16 := DitherThresholds16.	ditherValues16 := DitherValues16.	dither8Lookup := Dither8Lookup.! !!BitBltPure methodsFor: 'surface support' stamp: 'tfel 1/17/2014 19:40'!lockSurfaces	"Get a pointer to the bits of any OS surfaces."	"Notes: 	* For equal source/dest handles only one locking operation is performed.	This is to prevent locking of overlapping areas which does not work with	certain APIs (as an example, DirectDraw prevents locking of overlapping areas). 	A special case for non-overlapping but equal source/dest handle would 	be possible but we would have to transfer this information over to 	unlockSurfaces somehow (currently, only one unlock operation is 	performed for equal source and dest handles). Also, this would require	a change in the notion of ioLockSurface() which is right now interpreted	as a hint and not as a requirement to lock only the specific portion of	the surface.	* The arguments in ioLockSurface() provide the implementation with	an explicit hint what area is affected. It can be very useful to	know the max. affected area beforehand if getting the bits requires expensive	copy operations (e.g., like a roundtrip to the X server or a glReadPixel op).	However, the returned pointer *MUST* point to the virtual origin of the surface	and not to the beginning of the rectangle. The promise made by BitBlt	is to never access data outside the given rectangle (aligned to 4byte boundaries!!)	so it is okay to return a pointer to the virtual origin that is actually outside	the valid memory area.	* The area provided in ioLockSurface() is already clipped (e.g., it will always	be inside the source and dest boundingBox) but it is not aligned to word boundaries	yet. It is up to the support code to compute accurate alignment if necessary.	* Warping always requires the entire source surface to be locked because	there is no beforehand knowledge about what area will actually be traversed.	"	hasSurfaceLock := false.	destBits = 0 ifTrue:[^ false].	(sourceBits == 0 and:[noSource not]) ifTrue:[^ false].	^destBits ~~ 0 and:[sourceBits ~~ 0 or:[noSource]].! !!BitBltPure methodsFor: 'surface support' stamp: 'tfel 1/17/2014 19:01'!querySourceSurface: handle	"Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller."	querySurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^false]].	^(self cCode:' ((sqInt (*) (sqInt, sqInt*, sqInt*, sqInt*, sqInt*))querySurfaceFn)		(handle, &sourceWidth, &sourceHeight, &sourceDepth, &sourceMSB)'			inSmalltalk:[false])! !!BitBltPure methodsFor: 'color mapping' stamp: 'tfel 1/17/2014 19:12'!mapPixel: sourcePixel flags: mapperFlags	"Color map the given source pixel."	| pv |	pv := sourcePixel.	(mapperFlags bitAnd: ColorMapPresent) ~= 0 ifTrue:[		(mapperFlags bitAnd: ColorMapFixedPart) ~= 0 ifTrue:[			pv := self rgbMapPixel: sourcePixel flags: mapperFlags.			"avoid introducing transparency by color reduction"			(pv = 0 and:[sourcePixel ~= 0]) ifTrue:[pv := 1]].		(mapperFlags bitAnd: ColorMapIndexedPart) ~= 0			ifTrue:[pv := cmLookupTable at: (pv bitAnd: cmMask)].	].	^pv! !!BitBltPure methodsFor: 'color mapping' stamp: 'tfel 1/17/2014 19:01'!rgbMap16To32: sourcePixel	"Convert the given 16bit pixel value to a 32bit RGBA value. 	Note: This method is intended to deal with different source formats."	^(((sourcePixel bitAnd: 31) << 3) bitOr:		((sourcePixel bitAnd: 16r3E0) << 6)) bitOr:			((sourcePixel bitAnd: 16r7C00) << 9)! !!BitBltPure methodsFor: 'color mapping' stamp: 'tfel 1/17/2014 19:01'!rgbMap32To32: sourcePixel	"Convert the given 32bit pixel value to a 32bit RGBA value. 	Note: This method is intended to deal with different source formats."	^sourcePixel "For now do it simple"! !!BitBltPure methodsFor: 'color mapping' stamp: 'tfel 1/18/2014 15:42'!rgbMapPixel: sourcePixel flags: mapperFlags	"Perform the RGBA conversion for the given source pixel"	| val |	val := 			((sourcePixel bitAnd: (cmMaskTable at: 1)) bitShift: (cmShiftTable at: 1)).	val := val bitOr: ((sourcePixel bitAnd: (cmMaskTable at: 2)) bitShift: (cmShiftTable at: 2)).	val := val bitOr: ((sourcePixel bitAnd: (cmMaskTable at: 3)) bitShift: (cmShiftTable at: 3)).		  ^val bitOr: ((sourcePixel bitAnd: (cmMaskTable at: 4)) bitShift: (cmShiftTable at: 4)).! !!BitBltPure methodsFor: 'primitives' stamp: 'tfel 1/17/2014 20:56'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr := self.	(self loadBitBltFrom: rcvr)  ifFalse:[^ false].	self copyBits ifFalse: [^ false].	self showDisplayBits ifFalse: [^ false].	(combinationRule = 22) | (combinationRule = 32) ifTrue:[		^ bitCount].	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BitBltPure class	instanceVariableNames: ''!!BitBltPure class methodsFor: 'system simulation' stamp: 'tfel 1/17/2014 19:01'!copyBitsFrom: aBitBlt	"Simulate the copyBits primitive"	| proxy bb |	proxy := InterpreterProxy new.	proxy loadStackFrom: thisContext sender home.	bb := self simulatorClass new.	bb initialiseModule.	bb setInterpreter: proxy.	proxy success: (bb loadBitBltFrom: aBitBlt).	bb copyBits.	proxy failed ifFalse:[		proxy showDisplayBits: aBitBlt destForm Left: bb affectedLeft Top: bb affectedTop Right: bb affectedRight Bottom: bb affectedBottom].	^proxy stackValue: 0! !!BitBltPure class methodsFor: 'system simulation' stamp: 'tfel 1/17/2014 19:01'!simulatorClass	^BitBltSimulator! !!BitBltPure class methodsFor: 'system simulation' stamp: 'tfel 1/17/2014 19:01'!warpBitsFrom: aBitBlt	"Simulate the warpBits primitive"	| proxy bb |	proxy := InterpreterProxy new.	proxy loadStackFrom: thisContext sender home.	bb := self simulatorClass new.	bb initialiseModule.	bb setInterpreter: proxy.	proxy success: (bb loadWarpBltFrom: aBitBlt).	bb warpBits.	proxy failed ifFalse:[		proxy showDisplayBits: aBitBlt destForm Left: bb affectedLeft Top: bb affectedTop Right: bb affectedRight Bottom: bb affectedBottom].	^proxy stackValue: 0! !!BitBltPure class methodsFor: 'translation' stamp: 'tfel 1/17/2014 19:01'!moduleName	^'BitBltPlugin'! !!BitBltPure class methodsFor: 'translation' stamp: 'tfel 1/17/2014 19:01'!opTable	^ OpTable! !!BitBltPure class methodsFor: 'translation' stamp: 'tfel 1/17/2014 19:01'!requiredMethodNames	^(self opTable, #(copyBits:Fallback:)) asSet! !!BitBltPure class methodsFor: 'initialization' stamp: 'tfel 1/18/2014 18:02'!expensiveDither32To16: srcWord threshold: ditherValue	"Dither the given 32bit word to 16 bit. Ignore alpha."	| pv threshold value out |	pv := srcWord bitAnd: 255.	threshold := DitherThresholds16 at: (pv bitAnd: 7) + 1.	value := DitherValues16 at: (pv bitShift: -3) + 1.	ditherValue < threshold		ifTrue:[out := value + 1]		ifFalse:[out := value].	pv := (srcWord bitShift: -8) bitAnd: 255.	threshold := DitherThresholds16 at: (pv bitAnd: 7) + 1.	value := DitherValues16 at: (pv bitShift: -3) + 1.	ditherValue < threshold		ifTrue:[out := out bitOr: (value+1 bitShift:5)]		ifFalse:[out := out bitOr: (value bitShift: 5)].	pv := (srcWord bitShift: -16) bitAnd: 255.	threshold := DitherThresholds16 at: (pv bitAnd: 7) + 1.	value := DitherValues16 at: (pv bitShift: -3) + 1.	ditherValue < threshold		ifTrue:[out := out bitOr: (value+1 bitShift:10)]		ifFalse:[out := out bitOr: (value bitShift: 10)].	^out! !!BitBltPure class methodsFor: 'initialization' stamp: 'tfel 1/18/2014 18:01'!initBBOpTables	MaskTable := Array new: 32.	#(1 2 4 5 8 16 32) do:[:i| MaskTable at: i put: (1 << i)-1].! !!BitBltPure class methodsFor: 'initialization' stamp: 'tfel 1/18/2014 18:00'!initDither8Lookup		0 to: 255 do: [:b | 		0 to: 15 do: [:t | | value |			value := self expensiveDither32To16: b threshold: t.			Dither8Lookup at: (((t << 8)+b) + 1) put: value]].	! !!BitBltPure class methodsFor: 'initialization' stamp: 'tfel 1/18/2014 18:01'!initialize	"self initialize"	self initializeRuleTable.	self initBBOpTables.	self initializeDitherTables.	"Mask constants"	AllOnes := 16rFFFFFFFF.	BinaryPoint := 14.	FixedPt1 := 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun := 257.	CrossedX := 258. 	"Form fields"	FormBitsIndex := 0.	FormWidthIndex := 1.	FormHeightIndex := 2.	FormDepthIndex := 3. 	"BitBlt fields"	BBDestFormIndex := 0.	BBSourceFormIndex := 1.	BBHalftoneFormIndex := 2.	BBRuleIndex := 3.	BBDestXIndex := 4.	BBDestYIndex := 5.	BBWidthIndex := 6.	BBHeightIndex := 7.	BBSourceXIndex := 8.	BBSourceYIndex := 9.	BBClipXIndex := 10.	BBClipYIndex := 11.	BBClipWidthIndex := 12.	BBClipHeightIndex := 13.	BBColorMapIndex := 14.	BBWarpBase := 15.	BBLastIndex := 15.	BBXTableIndex := 16.	"RGBA indexes"	RedIndex := 0.	GreenIndex := 1.	BlueIndex := 2.	AlphaIndex := 3.	"Color map flags"	ColorMapPresent := 1.		"do we have one?"	ColorMapFixedPart := 2.		"does it have a fixed part?"	ColorMapIndexedPart := 4.	"does it have an indexed part?"	ColorMapNewStyle := 8.		"new style color map"! !!BitBltPure class methodsFor: 'initialization' stamp: 'tfel 1/18/2014 18:00'!initializeDitherTables	DitherMatrix4x4 := #(	0	8	2	10			12	4	14	6			3	11	1	9			15	7	13	5).	DitherThresholds16 := #(0 2 4 6 8 10 12 14 16).	DitherValues16 := #(0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14		15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30).	Dither8Lookup := (Array new: 4096).	self initDither8Lookup.! !!BitBltPure class methodsFor: 'initialization' stamp: 'tfel 1/17/2014 19:01'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable := #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:		"34" alphaBlendScaled:with:		"35" alphaBlendScaled:with:	"unused here - only used by FXBlt"		"36" alphaBlendScaled:with:	"unused here - only used by FXBlt"		"37" rgbMul:with:		"38" pixSwap:with:		"39" pixClear:with:		"40" fixAlpha:with:		"41" rgbComponentAlpha:with:	).	OpTableSize := OpTable size + 1.  "0-origin indexing"! !!BitBltPure class methodsFor: 'testing' stamp: 'tfel 1/17/2014 19:01'!test2	"BitBltSimulation test2"	| f |	Display fillWhite: (0 @ 0 extent: 300 @ 140).	1 to: 12 do: [:i | 			f := (Form extent: i @ 5) fillBlack.			0 to: 20 do: [:x | f displayOn: Display at: x * 13 @ (i * 10)]]! !!BitBltPure class methodsFor: 'testing' stamp: 'tfel 1/17/2014 19:01'!timingTest: extent 	"BitBltSimulation timingTest: 640@480"	| f f2 map |	f := Form extent: extent depth: 8.	f2 := Form extent: extent depth: 8.	map := Bitmap new: 1 << f2 depth.	^ Array		with: (Time millisecondsToRun: [100 timesRepeat: [f fillWithColor: Color white]])		with: (Time millisecondsToRun: [100 timesRepeat: [f copy: f boundingBox from: 0 @ 0 in: f2 rule: Form over]])		with: (Time millisecondsToRun: [100 timesRepeat: [f copyBits: f boundingBox from: f2 at: 0 @ 0 colorMap: map]])! !BitBlt subclass: #BitBltSmalltalk	instanceVariableNames: ''	classVariableNames: 'CachedFontColorMaps ColorConvertingMaps SubPixelRenderColorFonts SubPixelRenderFonts'	poolDictionaries: ''	category: 'BitBltPureSmalltalk'!!BitBltSmalltalk commentStamp: '<historical>' prior: 0!WARNING: BitBlt's shape cannot be modified since WarpBlt relies on the exact layout.I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBltSmalltalk methodsFor: 'copying' stamp: 'tfel 1/18/2014 16:07'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	self copyBitsSmalltalk ifTrue: [^ self].	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap := colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[self roundVariables. ^self copyBitsAgain].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	self roundVariables.	^ self copyBitsAgain! !!BitBltSmalltalk methodsFor: 'copying' stamp: 'tfel 1/18/2014 16:06'!copyBitsSmalltalk	| bb |	bb := BitBltPure new		destForm: destForm;		sourceForm: sourceForm;		halftoneForm: halftoneForm;		combinationRule: combinationRule;		destX: destX;		destY: destY;		width: width;		height: height;		sourceX: sourceX;		sourceY: sourceY;		clipX: clipX;		clipY: clipY;		clipWidth: clipWidth;		clipHeight: clipHeight;		colorMap: colorMap.	^ bb primitiveCopyBits! !!BitBltSmalltalk methodsFor: 'copying' stamp: 'tfel 1/18/2014 16:08'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	self copyBitsSmalltalk ifTrue: [^ self].	"Check for compressed source, destination or halftone forms"	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !!BitBltSmalltalk methodsFor: 'private' stamp: 'tfel 1/18/2014 16:07'!copyBitsAgain	"Primitive. See BitBlt|copyBits, also a Primitive. Essential. See Object	documentation whatIsAPrimitive."	^ self copyBitsSmalltalk		ifTrue: [self]		ifFalse: [self primitiveFailed]! !!BitBltSmalltalk methodsFor: 'FreeType-addition' stamp: 'tfel 1/18/2014 16:08'!copyBitsColor: argbColorSmallInteger alpha: argbAlphaSmallInteger gammaTable: gammaByteArray ungammaTable: ungammaByteArray	"This entry point to BitBlt supplies an extra argument to specify the fore color	argb value for operation 41. This is split into an alpha value and an rgb value,	so that both can be passed as smallIntegers to the primitive.  	rgbColorInteger must be a smallInteger between 0 and 16rFFFFFF.	alpha must be a smallInteger between 0 and 16rFF."	self copyBitsSmalltalk ifTrue: [^ self].	"Check for compressed source, destination or halftone forms"	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsColor: argbColorSmallInteger alpha: argbAlphaSmallInteger gammaTable: gammaByteArray ungammaTable: ungammaByteArray].	((destForm isForm) and: [destForm unhibernate ])		ifTrue: [^ self copyBitsColor: argbColorSmallInteger alpha: argbAlphaSmallInteger gammaTable: gammaByteArray ungammaTable: ungammaByteArray].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsColor: argbColorSmallInteger alpha: argbAlphaSmallInteger gammaTable: gammaByteArray ungammaTable: ungammaByteArray].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BitBltSmalltalk class	instanceVariableNames: ''!!BitBltSmalltalk class methodsFor: 'benchmarks' stamp: 'tfel 1/17/2014 19:45'!benchDiffsFrom: before to: afterwards	"Given two outputs of BitBlt>>benchmark show the relative improvements."	| old new log oldLine newLine oldVal newVal improvement |	log := WriteStream on: String new.	old := ReadStream on: before.	new := ReadStream on: afterwards.	[old atEnd or:[new atEnd]] whileFalse:[		oldLine := old nextLine.		newLine := new nextLine.		(oldLine includes: Character tab) ifTrue:[			oldLine := ReadStream on: oldLine.			newLine := ReadStream on: newLine.			Transcript cr; show: (oldLine upTo: Character tab); tab.			log cr; nextPutAll: (newLine upTo: Character tab); tab.			[oldLine skipSeparators. newLine skipSeparators.			oldLine atEnd] whileFalse:[				oldVal := Integer readFrom: oldLine.				newVal := Integer readFrom: newLine.				improvement := oldVal asFloat / newVal asFloat roundTo: 0.01.				Transcript show: improvement printString; tab; tab.				log print: improvement; tab; tab].		] ifFalse:[			Transcript cr; show: oldLine.			log cr; nextPutAll: oldLine.		].	].	^log contents! !!BitBltSmalltalk class methodsFor: 'benchmarks' stamp: 'tfel 1/17/2014 19:45'!benchmark		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| destRect log |	log := WriteStream on: String new.	destRect := 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth| | dest |			dest := nil.			dest := Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth| | t source bb |				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source := nil. bb := nil.				source := Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb := WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededFor: dest).				bb combinationRule: rule.				"Measure speed of copyBits"				t := Time millisecondsToRun:[bb copyBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!BitBltSmalltalk class methodsFor: 'benchmarks' stamp: 'tfel 1/17/2014 19:45'!benchmark2		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| destRect log |	log := WriteStream on: String new.	destRect := 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth| | dest |			dest := nil.			dest := Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth| | t bb source |				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source := nil. bb := nil.				source := Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb := WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededFor: dest).				bb combinationRule: rule.				"Measure speed of copyBits"				t := Time millisecondsToRun:[1 to: 10 do:[:i| bb copyBits]].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t := Time millisecondsToRun:[1 to: 4 do:[:i| bb warpBits]].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!BitBltSmalltalk class methodsFor: 'benchmarks' stamp: 'tfel 1/17/2014 19:45'!benchmark3		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| destRect log |	log := WriteStream on: String new.	destRect := 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth| | dest |			dest := nil.			dest := Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth| | t source bb |				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source := nil. bb := nil.				source := Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb := WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededFor: dest).				bb combinationRule: rule.				"Measure speed of copyBits"				t := Time millisecondsToRun:[1 to: 10 do:[:i| bb copyBits]].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t := Time millisecondsToRun:[1 to: 4 do:[:i| bb warpBits]].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!BitBltSmalltalk class methodsFor: 'examples' stamp: 'tfel 1/17/2014 19:45'!alphaBlendDemo	"To run this demo, use...		Display restoreAfter: [BitBlt alphaBlendDemo]		Displays 10 alphas, then lets you paint.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 := Color cachedColormapFrom: Display depth to: 32.		map32toD := Color cachedColormapFrom: 32 to: Display depth].	"display 10 different alphas, across top of screen"	buff := Form extent: 500@50 depth: 32.	dispToBuff := BitBlt toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay := BitBlt toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush := Form extent: 30@30 depth: 32.	1 to: 5 do: 		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: brush extent // 2].	"Now paint with the brush using alpha blending."	buffSize := 100.	buff := Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"	dispToBuff := BitBlt toForm: buff.  "This is from Display to buff"	dispToBuff colorMap: mapDto32.	brushToBuff := BitBlt toForm: buff.  "This is from brush to buff"	brushToBuff sourceForm: brush; sourceOrigin: 0@0.	brushToBuff combinationRule: Form blend.	buffToBuff := BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP := nil.		buffRect := Sensor cursorPoint - (buffSize // 2) extent: buff extent.		dispToBuff copyFrom: buffRect in: Display to: 0@0.		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p := Sensor cursorPoint - (brush extent // 2).			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP := p].				(p dist: prevP) > buffSize ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta := (p-prevP) theta.					p := ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].				brushRect := p extent: brush extent.				(buffRect containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta := brushRect amountToTranslateWithin: buffRect.					buffToBuff copyFrom: buff boundingBox in: buff to: delta.					newBuffRect := buffRect translateBy: delta negated.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].					buffRect := newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP - buffRect origin									to: p - buffRect origin									withFirstPoint: false.				"Update (only) the altered pixels of the destination"				updateRect := (p min: prevP) corner: (p max: prevP) + brush extent.				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.				prevP := p]]]! !!BitBltSmalltalk class methodsFor: 'examples' stamp: 'tfel 1/17/2014 21:04'!alphaBlendDemoJustDraw	"To run this demo, use...		self alphaBlendDemoJustDraw.		Display forceDisplayUpdate; forceToScreen.	Displays 10 alphas"	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 := Color cachedColormapFrom: Display depth to: 32.		map32toD := Color cachedColormapFrom: 32 to: Display depth].	"display 10 different alphas, across top of screen"	buff := Form extent: 500@50 depth: 32.	dispToBuff := self toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay := self toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush := Form extent: 30@30 depth: 32.	1 to: 5 do: 		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: brush extent // 2].! !!BitBltSmalltalk class methodsFor: 'examples' stamp: 'tfel 1/17/2014 19:45'!antiAliasDemo 	"To run this demo, use...		Display restoreAfter: [BitBlt antiAliasDemo]	Goes immediately into on-screen paint mode.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"		"This version also uses WarpBlt to paint into twice as large a buffer,	and then use smoothing when reducing back down to the display.	In fact this same routine will now work for 3x3 soothing as well.	Remove the statements 'buff displayAt: 0@0' to hide the buffer. - di 3/19/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect scale p0 |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 := Color cachedColormapFrom: Display depth to: 32.		map32toD := Color cachedColormapFrom: 32 to: Display depth].	"Create a brush with radially varying alpha"	brush := Form extent: 3@3 depth: 32.	brush fill: brush boundingBox fillColor: (Color red alpha: 0.05).	brush fill: (1@1 extent: 1@1) fillColor: (Color red alpha: 0.2).	scale := 2.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush := brush magnify: brush boundingBox by: scale.	"Now paint with the brush using alpha blending."	buffSize := 100.	buff := Form extent: (brush extent + buffSize) * scale depth: 32.  "Travelling 32-bit buffer"	dispToBuff := (WarpBlt toForm: buff)  "From Display to buff - magnify by 2"		sourceForm: Display;		colorMap: mapDto32;		combinationRule: Form over.	brushToBuff := (BitBlt toForm: buff)  "From brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	buffToDisplay := (WarpBlt toForm: Display)  "From buff to Display - shrink by 2"		sourceForm: buff;		colorMap: map32toD;		cellSize: scale;  "...and use smoothing"		combinationRule: Form over.	buffToBuff := BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP := nil.		buffRect := Sensor cursorPoint - (buff extent // scale // 2) extent: buff extent // scale.		p0 := (buff extent // 2) - (buffRect extent // 2).		dispToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.buff displayAt: 0@0.  "** remove to hide sliding buffer **"		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p := Sensor cursorPoint - buffRect origin + p0.  "p, prevP are rel to buff origin"			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP := p].				(p dist: prevP) > (buffSize-1) ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta := (p-prevP) theta.					p := ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].				brushRect := p extent: brush extent.				((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta := (brushRect amountToTranslateWithin: (buff boundingBox insetBy: scale)) // scale.					buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.					newBuffRect := buffRect translateBy: delta negated.					p := p translateBy: delta*scale.					prevP := prevP translateBy: delta*scale.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyQuad: r innerCorners toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].					buffRect := newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP to: p withFirstPoint: false.buff displayAt: 0@0.  "** remove to hide sliding buffer **"				"Update (only) the altered pixels of the destination"				updateRect := (p min: prevP) corner: (p max: prevP) + brush extent.				updateRect := updateRect origin // scale * scale						corner: updateRect corner + scale // scale * scale.				buffToDisplay copyQuad: updateRect innerCorners							toRect: (updateRect origin // scale + buffRect origin										extent: updateRect extent // scale).				prevP := p]]]! !!BitBltSmalltalk class methodsFor: 'examples' stamp: 'tfel 1/17/2014 21:03'!displayString: aString at: aDisplayPoint	"	1 to: 100000 do: [:i | Display bits at: i put: 0]	self displayString: 'foobar' at: 20@20.	Display forceDisplayUpdate; forceToScreen.	'foobar' displayAt: 20@20	"	| form1 text |	text := aString asDisplayText.	form1 := text form.	((self		destForm: Display		sourceForm: form1		fillColor: nil		combinationRule: 34		destOrigin: aDisplayPoint + form1 offset		sourceOrigin: 0@0		extent: form1 extent		clipRect: Display boundingBox) colorMap: nil) copyBits! !!BitBltSmalltalk class methodsFor: 'examples' stamp: 'tfel 1/17/2014 19:45'!exampleColorMap	"BitBlt exampleColorMap"	"This example shows what one can do with the fixed part of a color map. The color map, as setup below, rotates the bits of a pixel all the way around. Thus you'll get a (sometime strange looking ;-) animation of colors which will end up exactly the way it looked at the beginning. The example is given to make you understand that the masks and shifts can be used for a lot more than simply color converting pixels. In this example, for instance, we use only two of the four independent shifters."	| cc bb |	cc := ColorMap masks: {		1 << (Display depth-1). "mask out high bit of color component"		1 << (Display depth-1) - 1. "mask all other bits"		0.		0}		shifts: {			1 - Display depth. "shift right to bottom most position"			1. "shift all other pixels one bit left"			0.			0}.	bb := BitBlt toForm: Display.	bb 		sourceForm: Display;		combinationRule: 3;		colorMap: cc.	1 to: Display depth do:[:i|		bb copyBits.		Display forceDisplayUpdate.	].! !!BitBltSmalltalk class methodsFor: 'examples' stamp: 'tfel 1/18/2014 16:10'!exampleColorMapPure	"self exampleColorMapPure"	"This example shows what one can do with the fixed part of a color map. The color map, as setup below, rotates the bits of a pixel all the way around. Thus you'll get a (sometime strange looking ;-) animation of colors which will end up exactly the way it looked at the beginning. The example is given to make you understand that the masks and shifts can be used for a lot more than simply color converting pixels. In this example, for instance, we use only two of the four independent shifters."	| cc bb |	cc := ColorMap masks: {		1 << (Display depth-1). "mask out high bit of color component"		1 << (Display depth-1) - 1. "mask all other bits"		0.		0}		shifts: {			1 - Display depth. "shift right to bottom most position"			1. "shift all other pixels one bit left"			0.			0}.	bb := self toForm: Display.	bb 		sourceForm: Display;		combinationRule: 3;		colorMap: cc.	1 to: Display depth do:[:i|		bb copyBits.		Display forceDisplayUpdate.	].! !!BitBltSmalltalk class methodsFor: 'examples' stamp: 'tfel 1/18/2014 14:56'!exampleOne	"This tests BitBlt by displaying the result of all sixteen combination rules that BitBlt is capable of using. (Please see the comment in BitBlt for the meaning of the combination rules). This only works at Display depth of 1. (Rule 15 does not work?)"	| pathClass path displayDepth |	displayDepth := Display depth.	Display newDepth: 1.	(Smalltalk hasClassNamed: #Path)		ifTrue: [pathClass := Smalltalk at: #Path]		ifFalse: [^self inform: 'MVC class Path not present in this image'].	path := pathClass new.	0 to: 3 do: [:i | 0 to: 3 do: [:j | path add: j * 100 @ (i * 75)]].	Display fillWhite.	path := path translateBy: 60 @ 40.	1 to: 16 do: [:index | self			exampleAt: (path at: index)			rule: index - 1			fillColor: nil].	[Sensor anyButtonPressed] whileFalse: [].	Display newDepth: displayDepth.	"self exampleOne"! !!BitBltSmalltalk class methodsFor: 'examples' stamp: 'tfel 1/18/2014 15:11'!exampleTwo	"This is to test painting with a gray tone. It also tests that the seaming with gray patterns is correct in the microcode. Lets you paint for a while and then automatically stops. This only works at Depth of 1."	| f aBitBlt displayDepth |	"create a small black Form source as a brush. "	displayDepth := Display depth.	Display newDepth: 1.	f := Form extent: 20 @ 20.	f fillBlack.	"create a BitBlt which will OR gray into the display. "	aBitBlt := self		destForm: Display		sourceForm: f		fillColor: Color gray		combinationRule: Form over		destOrigin: Sensor cursorPoint		sourceOrigin: 0 @ 0		extent: f extent		clipRect: Display computeBoundingBox.	"paint the gray Form on the screen for a while. "	[Sensor anyButtonPressed] whileFalse: 		[aBitBlt destOrigin: Sensor cursorPoint.		aBitBlt copyBits].	Display newDepth: displayDepth.	"self exampleTwo"! !!BitBltSmalltalk class methodsFor: 'instance creation' stamp: 'tfel 1/17/2014 19:45'!bitPeekerFromForm: sourceForm	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."	| pixPerWord |	pixPerWord := 32 // sourceForm depth.	sourceForm unhibernate.	^ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)	 	sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: (pixPerWord - 1)@0		sourceOrigin: 0@0		extent: 1@1		clipRect: (0@0 extent: pixPerWord@1)! !!BitBltSmalltalk class methodsFor: 'instance creation' stamp: 'tfel 1/17/2014 19:45'!bitPokerToForm: destForm	"Answer an instance to be used for valueAt: aPoint put: pixValue.	The source for a 1x1 copyBits will be the low order of (bits at: 1)"	| pixPerWord |	pixPerWord := 32//destForm depth.	destForm unhibernate.	^ self destForm: destForm	 	sourceForm: (Form extent: pixPerWord@1 depth: destForm depth)		halftoneForm: nil combinationRule: Form over		destOrigin: 0@0 sourceOrigin: (pixPerWord-1)@0		extent: 1@1 clipRect: (0@0 extent: destForm extent)! !!BitBltSmalltalk class methodsFor: 'instance creation' stamp: 'tfel 1/17/2014 19:45'!current	"Return the class currently to be used for BitBlt"	^self! !!BitBltSmalltalk class methodsFor: 'instance creation' stamp: 'tfel 1/17/2014 19:45'!destForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect 	"Answer an instance of me with values set according to the arguments."	^ self new		setDestForm: df		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: sourceOrigin		extent: extent		clipRect: clipRect! !!BitBltSmalltalk class methodsFor: 'instance creation' stamp: 'tfel 1/17/2014 19:45'!destForm: df sourceForm: sf halftoneForm: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect 	"Answer an instance of me with values set according to the arguments."	^ self new		setDestForm: df		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: sourceOrigin		extent: extent		clipRect: clipRect! !!BitBltSmalltalk class methodsFor: 'instance creation' stamp: 'tfel 1/17/2014 19:45'!toForm: aForm	^ self new setDestForm: aForm! !!BitBltSmalltalk class methodsFor: 'private' stamp: 'tfel 1/17/2014 19:45'!exampleAt: originPoint rule: rule fillColor: mask 	"This builds a source and destination form and copies the source to the	destination using the specifed rule and mask. It is called from the method	named exampleOne. Only works with Display depth of 1"	| s d border aBitBlt | 	border:=Form extent: 32@32.	border fillBlack.	border fill: (1@1 extent: 30@30) fillColor: Color white.	s := Form extent: 32@32.	s fillWhite.	s fillBlack: (7@7 corner: 25@25).	d := Form extent: 32@32.	d fillWhite.	d fillBlack: (0@0 corner: 32@16).	s displayOn: Display at: originPoint.	border displayOn: Display at: originPoint rule: Form under.	d displayOn: Display at: originPoint + (s width @0).	border displayOn: Display at: originPoint + (s width @0) rule: Form under.	d displayOn: Display at: originPoint + (s extent // (2 @ 1)). 	aBitBlt := BitBlt		destForm: Display		sourceForm: s		fillColor: mask		combinationRule: rule		destOrigin: originPoint + (s extent // (2 @ 1))		sourceOrigin: 0 @ 0		extent: s extent		clipRect: Display computeBoundingBox.	aBitBlt copyBits.	border 		displayOn: Display at: originPoint + (s extent // (2 @ 1))		rule: Form under.	"BitBlt exampleAt: 100@100 rule: 0 fillColor: nil"  ! !!BitBltSmalltalk class methodsFor: 'private' stamp: 'tfel 1/17/2014 19:45'!recreateColorMaps	CachedFontColorMaps := ColorConvertingMaps := nil! !!BitBltSmalltalk class methodsFor: 'class initialization' stamp: 'tfel 1/17/2014 19:45'!cleanUp	"Flush caches"	self recreateColorMaps.! !!BitBltSmalltalk class methodsFor: 'class initialization' stamp: 'tfel 1/17/2014 19:45'!initialize	self recreateColorMaps! !!BitBltSmalltalk class methodsFor: 'preferences' stamp: 'tfel 1/17/2014 19:45'!subPixelRenderColorFonts	<preference: 'Subpixel font rendering for color fonts'	category: 'Graphics'	description: 'If true, non-black opaque fonts are rendered using subpixel combination rules by BitBlt. Subpixel font rendering has to be enabled to take effect.'	type: #Boolean>	^SubPixelRenderColorFonts ifNil: [ true ]	! !!BitBltSmalltalk class methodsFor: 'preferences' stamp: 'tfel 1/17/2014 19:45'!subPixelRenderColorFonts: aBoolean	SubPixelRenderColorFonts := aBoolean	! !!BitBltSmalltalk class methodsFor: 'preferences' stamp: 'tfel 1/17/2014 19:45'!subPixelRenderFonts	<preference: 'Subpixel font rendering'	category: 'Graphics'	description: 'If true, black fonts are rendered using subpixel combination rules by BitBlt.'	type: #Boolean>	^SubPixelRenderFonts ifNil: [ true ]	! !!BitBltSmalltalk class methodsFor: 'preferences' stamp: 'tfel 1/17/2014 19:45'!subPixelRenderFonts: aBoolean	SubPixelRenderFonts := aBoolean	! !!BitBltSmalltalk class methodsFor: 'Morphic' stamp: 'tfel 1/18/2014 15:37'!asGrafPort	"Return the GrafPort associated with the receiver"	^ GrafPortSmalltalk! !GrafPort subclass: #GrafPortSmalltalk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BitBltPureSmalltalk'!!GrafPortSmalltalk methodsFor: 'copying' stamp: 'tfel 1/18/2014 16:33'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31]) 		ifTrue: [			self copyBitsTranslucent: (alpha ifNil: [255])]		ifFalse: [self superCopyBits]! !!GrafPortSmalltalk methodsFor: 'copying' stamp: 'tfel 1/18/2014 16:33'!copyBitsSmalltalk	| bb |	bb := BitBltPure new		destForm: destForm;		sourceForm: sourceForm;		halftoneForm: halftoneForm;		combinationRule: combinationRule;		destX: destX;		destY: destY;		width: width;		height: height;		sourceX: sourceX;		sourceY: sourceY;		clipX: clipX;		clipY: clipY;		clipWidth: clipWidth;		clipHeight: clipHeight;		colorMap: colorMap.	^ bb primitiveCopyBits! !!GrafPortSmalltalk methodsFor: 'copying' stamp: 'tfel 1/18/2014 16:33'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	self copyBitsSmalltalk ifTrue: [^ self].	"Check for compressed source, destination or halftone forms"	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !!GrafPortSmalltalk methodsFor: 'copying' stamp: 'tfel 1/18/2014 16:33'!superCopyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	self copyBitsSmalltalk ifTrue: [^ self].	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap := colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[self roundVariables. ^self copyBitsAgain].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	self roundVariables.	^ self copyBitsAgain! !!GrafPortSmalltalk methodsFor: 'private' stamp: 'tfel 1/18/2014 16:34'!copyBitsAgain	"Primitive. See BitBlt|copyBits, also a Primitive. Essential. See Object	documentation whatIsAPrimitive."	^ self copyBitsSmalltalk		ifTrue: [self]		ifFalse: [self primitiveFailed]! !!GrafPortSmalltalk methodsFor: 'FreeType-addition' stamp: 'tfel 1/18/2014 16:34'!copyBitsColor: argbColorSmallInteger alpha: argbAlphaSmallInteger gammaTable: gammaByteArray ungammaTable: ungammaByteArray	"This entry point to BitBlt supplies an extra argument to specify the fore color	argb value for operation 41. This is split into an alpha value and an rgb value,	so that both can be passed as smallIntegers to the primitive.  	rgbColorInteger must be a smallInteger between 0 and 16rFFFFFF.	alpha must be a smallInteger between 0 and 16rFF."	self copyBitsSmalltalk ifTrue: [^ self].	"Check for compressed source, destination or halftone forms"	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsColor: argbColorSmallInteger alpha: argbAlphaSmallInteger gammaTable: gammaByteArray ungammaTable: ungammaByteArray].	((destForm isForm) and: [destForm unhibernate ])		ifTrue: [^ self copyBitsColor: argbColorSmallInteger alpha: argbAlphaSmallInteger gammaTable: gammaByteArray ungammaTable: ungammaByteArray].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsColor: argbColorSmallInteger alpha: argbAlphaSmallInteger gammaTable: gammaByteArray ungammaTable: ungammaByteArray].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !Form subclass: #SimulationForm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BitBltPureSmalltalk'!!SimulationForm methodsFor: 'converting' stamp: 'tfel 1/18/2014 15:21'!asFormOfDepth: d	| newForm |	d = self depth ifTrue:[^self].	newForm := Form extent: self extent depth: d.	(BitBltSmalltalk toForm: newForm)		colorMap: (self colormapIfNeededFor: newForm);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	"Special case: For a 16 -> 32 bit conversion fill the alpha channel because it gets lost in translation."	(self depth = 16 and:[d= 32]) ifTrue:[newForm fillAlpha: 255].	^newForm! !!SimulationForm methodsFor: 'converting' stamp: 'tfel 1/18/2014 15:21'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	self depth = 32 ifFalse: [		f32 := Form extent: width@height depth: 32.		self displayOn: f32.		^ f32 asGrayScale].	self unhibernate.	srcForm := Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result := ColorForm extent: width@height depth: 8.	map := Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb := (BitBltSmalltalk toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map := Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBltSmalltalk toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays := (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!SimulationForm methodsFor: 'bordering' stamp: 'tfel 1/18/2014 15:21'!border: rect width: borderWidth rule: rule fillColor: fillColor        "Paint a border whose rectangular area is defined by rect. Thewidth of the border of each side is borderWidth. Uses fillColor for drawingthe border."        | blt |        blt := (BitBltSmalltalk toForm: self) combinationRule: rule; fillColor: fillColor.        blt sourceOrigin: 0@0.        blt destOrigin: rect origin.        blt width: rect width; height: borderWidth; copyBits.        blt destY: rect corner y - borderWidth; copyBits.        blt destY: rect origin y + borderWidth.        blt height: rect height - borderWidth - borderWidth; width:borderWidth; copyBits.        blt destX: rect corner x - borderWidth; copyBits! !!SimulationForm methodsFor: 'bordering' stamp: 'tfel 1/18/2014 15:22'!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm := self deepCopy.	all := bigForm boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBltSmalltalk toForm: smearForm.	sharpen ifTrue:		[cornerForm := Form extent: self extent.		cornerPort := BitBltSmalltalk toForm: cornerForm].	nbrs := (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!SimulationForm methodsFor: 'copying' stamp: 'tfel 1/18/2014 15:22'!copy: destRectangle from: sourcePt in: sourceForm rule: rule 	"Make up a BitBlt table and copy the bits."	(BitBltSmalltalk toForm: self)		copy: destRectangle		from: sourcePt in: sourceForm		fillColor: nil rule: rule! !!SimulationForm methodsFor: 'copying' stamp: 'tfel 1/18/2014 15:22'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBltSmalltalk 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f := Form fromUser. f2 := Form fromDisplay: (0@0 extent: f extent). f3 := f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 := f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!SimulationForm methodsFor: 'copying' stamp: 'tfel 1/18/2014 15:22'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm 	"Make up a BitBlt table and copy the bits."	(BitBltSmalltalk		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) copyBits! !!SimulationForm methodsFor: 'copying' stamp: 'tfel 1/18/2014 15:23'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map	"Make up a BitBlt table and copy the bits.  Use a colorMap."	((BitBltSmalltalk		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) colorMap: map) copyBits! !!SimulationForm methodsFor: 'copying' stamp: 'tfel 1/18/2014 15:23'!copyBits: sourceRect from: sourceForm at: destOrigin colorMap: map 	"Make up a BitBlt table and copy the bits with the given colorMap."	((BitBltSmalltalk 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: self boundingBox) colorMap: map) copyBits! !!SimulationForm methodsFor: 'displaying' stamp: 'tfel 1/18/2014 15:23'!displayResourceFormOn: aForm	"a special display method for blowing up resource thumbnails"	| engine tx cmap blitter |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	engine := Smalltalk at: #B3DRenderEngine ifPresent:		[:engineClass | engineClass defaultForPlatformOn: aForm].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	tx := self asTexture.	(blitter := BitBltSmalltalk toForm: tx)		sourceForm: self; destRect: aForm boundingBox;		sourceOrigin: 0@0;		combinationRule: Form paint.	"map transparency to current World background color"	(World color respondsTo: #pixelWordForDepth:) ifTrue: [		cmap := Bitmap new: (self depth <= 8 ifTrue: [1 << self depth] ifFalse: [4096]).		cmap at: 1 put: (tx pixelWordFor: World color).		blitter colorMap: cmap.	].	blitter copyBits.	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: tx.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.	"the above, using bilinear interpolation doesn't leave transparent pixel values intact"	(WarpBlt toForm: aForm)		sourceForm: self destRect: aForm boundingBox;		combinationRule: Form and;		colorMap: (Color maskingMap: self depth);		warpBits.! !!SimulationForm methodsFor: 'displaying' stamp: 'tfel 1/18/2014 15:23'!drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Refer to the comment in 	DisplayMedium|drawLine:from:to:clippingBox:rule:mask:." 		| dotSetter |	"set up an instance of BitBlt for display"	dotSetter := BitBltSmalltalk		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: anInteger		destOrigin: beginPoint		sourceOrigin: 0 @ 0		extent: sourceForm extent		clipRect: clipRect.	dotSetter drawFrom: beginPoint to: endPoint! !!SimulationForm methodsFor: 'displaying' stamp: 'tfel 1/18/2014 15:25'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBltSmalltalk destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f := Form fromUser. f replaceColor: f peripheralColor withColor: Color transparent.f2 := Form fromDisplay: (0@0 extent: f extent). f3 := f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 := f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!SimulationForm methodsFor: 'filling' stamp: 'tfel 1/18/2014 15:23'!eraseShape: bwForm	"use bwForm as a mask to clear all pixels where bwForm has 1's"	((BitBltSmalltalk destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.! !!SimulationForm methodsFor: 'filling' stamp: 'tfel 1/18/2014 15:23'!fill: aRectangle rule: anInteger fillColor: aForm 	"Replace a rectangular area of the receiver with the pattern described by aForm 	according to the rule anInteger."	(BitBltSmalltalk toForm: self)		copy: aRectangle		from: 0@0 in: nil		fillColor: aForm rule: anInteger! !!SimulationForm methodsFor: 'filling' stamp: 'tfel 1/18/2014 15:24'!fillFromXYColorBlock: colorBlock	"General Gradient Fill.	Supply relative x and y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| poker yRel xRel |	poker := BitBltSmalltalk bitPokerToForm: self.	0 to: height-1 do:		[:y | yRel := y asFloat / (height-1) asFloat.		0 to: width-1 do:			[:x |  xRel := x asFloat / (width-1) asFloat.			poker pixelAt: x@y				put: ((colorBlock value: xRel value: yRel) pixelWordForDepth: self depth)]]" | d |((Form extent: 100@20 depth: Display depth)	fillFromXYColorBlock:	[:x :y | d := 1.0 - (x - 0.5) abs - (y - 0.5) abs.	Color r: d g: 0 b: 1.0-d]) display"! !!SimulationForm methodsFor: 'filling' stamp: 'tfel 1/18/2014 15:24'!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all := self boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBltSmalltalk toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0 @ 0 rule: Form erase.  "Clear any in black"	previousSmear := smearForm deepCopy.	count := 1.	[count = 10 and:   "check for no change every 10 smears"		[count := 1.		previousSmear copy: all from: 0 @ 0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1 @ 0 rule: Form under.			smearPort copyForm: smearForm to: -1 @ 0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0 @ 0 rule: Form erase.			smearPort copyForm: smearForm to: 0 @ 1 rule: Form under.			smearPort copyForm: smearForm to: 0 @ -1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0 @ 0 rule: Form erase.			count := count + 1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0 @ 0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!SimulationForm methodsFor: 'filling' stamp: 'tfel 1/18/2014 15:24'!floodFill2: aColor at: interiorPoint	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.	NOTE: This is a less optimized variant for flood filling which is precisely along the lines of Heckbert's algorithm. For almost all cases #floodFill:at: will be faster (see the comment there) but this method is left in both as reference and as a fallback if such a strange case is encountered in reality."	| poker stack old new x y top x1 x2 dy left goRight |	poker := BitBltSmalltalk bitPokerToForm: self.	stack := OrderedCollection new: 50.	"read old pixel value"	old := self pixelValueAt: interiorPoint.	"compute new value"	new := self pixelValueFor: aColor.	old = new ifTrue:[^self]. "no point, is there?!!"	x := interiorPoint x.	y := interiorPoint y.	(y >= 0 and:[y < height]) ifTrue:[		stack addLast: {y. x. x. 1}. "y, left, right, dy"		stack addLast: {y+1. x. x. -1}].	[stack isEmpty] whileFalse:[		top := stack removeLast.		y := top at: 1. x1 := top at: 2. x2 := top at: 3. dy := top at: 4.		y := y + dy.		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.		Now explore adjacent pixels in scanline y."		x := x1.		[x >= 0 and:[(self pixelValueAt: x@y) = old]] whileTrue:[			poker pixelAt: x@y put: new.			x := x - 1].		goRight := x < x1.		left := x+1.		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].		goRight ifTrue:[x := x1 + 1].		[			goRight ifTrue:[				[x < width and:[(self pixelValueAt: x@y) = old]] whileTrue:[					poker pixelAt: x@y put: new.					x := x + 1].				(y+dy >= 0 and:[y+dy < height]) 					ifTrue:[stack addLast: {y. left. x-1. dy}].				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].			[(x := x + 1) <= x2 and:[(self pixelValueAt: x@y) ~= old]] whileTrue.			left := x.			goRight := true.		x <= x2] whileTrue.	].! !!SimulationForm methodsFor: 'filling' stamp: 'tfel 1/18/2014 15:24'!floodFill: aColor at: interiorPoint tolerance: tolerance	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.	NOTE (ar): This variant has been heavily optimized to prevent the overhead of repeated calls to BitBlt. Usually this is a really big winner but the runtime now depends a bit on the complexity of the shape to be filled. For extremely complex shapes (say, a Hilbert curve) with very few pixels to fill it can be slower than #floodFill2:at: since it needs to repeatedly read the source bits. However, in all practical cases I found this variant to be 15-20 times faster than anything else.	Further note (di):  I have added a feature that allows this routine to fill areas of approximately constant color (such as  photos, scans, and jpegs).  It does this by computing a color map for the peeker that maps all colors close to 'old' into colors identical to old.  This mild colorblindness achieves the desired effect with no further change or degradation of the algorithm.  tolerance should be 0 (exact match), or a value corresponding to those returned by Color>>diff:, with 0.1 being a reasonable starting choice."	| peeker poker stack old new x y top x1 x2 dy left goRight span spanBits w box debug |	debug := false. "set it to true to see the filling process"	box := interiorPoint extent: 1@1.	span := Form extent: width@1 depth: 32.	spanBits := span bits.	peeker := BitBltSmalltalk toForm: span.	peeker 		sourceForm: self; 		combinationRule: 3; 		width: width; 		height: 1.	"read old pixel value"	peeker sourceOrigin: interiorPoint; destOrigin: interiorPoint x @ 0; width: 1; copyBits.	old := spanBits at: interiorPoint x + 1.	"compute new value (take care since the algorithm will fail if old = new)"	new := self privateFloodFillValue: aColor.	old = new ifTrue: [^ box].	tolerance > 0 ifTrue:		["Set up color map for approximate fills"		peeker colorMap: (self floodFillMapFrom: self to: span mappingColorsWithin: tolerance to: old)].	poker := BitBltSmalltalk toForm: self.	poker 		fillColor: aColor;		combinationRule: 3;		width: width;		height: 1.	stack := OrderedCollection new: 50.	x := interiorPoint x.	y := interiorPoint y.	(y >= 0 and:[y < height]) ifTrue:[		stack addLast: {y. x. x. 1}. "y, left, right, dy"		stack addLast: {y+1. x. x. -1}].	[stack isEmpty] whileFalse:[		debug ifTrue:[self displayOn: Display].		top := stack removeLast.		y := top at: 1. x1 := top at: 2. x2 := top at: 3. dy := top at: 4.		y := y + dy.		debug ifTrue:[			Display 				drawLine: (Form extent: 1@1 depth: 8) fillWhite				from: (x1-1)@y to: (x2+1)@y 				clippingBox: Display boundingBox				rule: Form over fillColor: nil].		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.		Now explore adjacent pixels in scanline y."		peeker sourceOrigin: 0@y; destOrigin: 0@0; width: width; copyBits.			"Note: above is necessary since we don't know where we'll end up filling"		x := x1.		w := 0.		[x >= 0 and:[(spanBits at: x+1) = old]] whileTrue:[			w := w + 1.			x := x - 1].		w > 0 ifTrue:[			"overwrite pixels"			poker destOrigin: x+1@y; width: w; copyBits.			box := box quickMerge: ((x+1@y) extent: w@1)].		goRight := x < x1.		left := x+1.		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].		goRight ifTrue:[x := x1 + 1].		[			goRight ifTrue:[				w := 0.				[x < width and:[(spanBits at: x+1) = old]] whileTrue:[					w := w + 1.					x := x + 1].				w > 0 ifTrue:[					"overwrite pixels"					poker destOrigin: (x-w)@y; width: w; copyBits.					box := box quickMerge: ((x-w@y) extent: w@1)].				(y+dy >= 0 and:[y+dy < height]) 					ifTrue:[stack addLast: {y. left. x-1. dy}].				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].			[(x := x + 1) <= x2 and:[(spanBits at: x+1) ~= old]] whileTrue.			left := x.			goRight := true.		x <= x2] whileTrue.	].	^box! !!SimulationForm methodsFor: 'color mapping' stamp: 'tfel 1/18/2014 15:25'!mapColor: oldColor to: newColor	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	map := (Color cachedColormapFrom: self depth to: self depth) copy.	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).	(BitBltSmalltalk toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!SimulationForm methodsFor: 'color mapping' stamp: 'tfel 1/18/2014 15:25'!mapColors: oldColorBitsCollection to: newColorBits	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	self depth < 16		ifTrue: [map := (Color cachedColormapFrom: self depth to: self depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map := Color computeRGBColormapFor: self depth bitsPerColor: 5].	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].	(BitBltSmalltalk toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!SimulationForm methodsFor: 'analyzing' stamp: 'tfel 1/18/2014 15:25'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord := 32//self depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBltSmalltalk toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp := self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBltSmalltalk toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f := Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff := f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!SimulationForm methodsFor: 'analyzing' stamp: 'tfel 1/18/2014 15:25'!primCountBits	"Count the non-zero pixels of this form."	self depth > 8 ifTrue:		[^(self asFormOfDepth: 8) primCountBits].	^ (BitBltSmalltalk toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!SimulationForm methodsFor: 'analyzing' stamp: 'tfel 1/18/2014 15:26'!rectangleEnclosingPixelsNotOfColor: aColor	"Answer the smallest rectangle enclosing all the pixels of me that are different from the given color. Useful for extracting a foreground graphic from its background."	| cm slice copyBlt countBlt top bottom newH left right |	"map the specified color to 1 and all others to 0"	cm := Bitmap new: (1 bitShift: (self depth min: 15)).	cm primFill: 1.	cm at: (aColor indexInMap: cm) put: 0.	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of interest"	slice := Form extent: width@1 depth: 1.	copyBlt := (BitBltSmalltalk toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: 1;		colorMap: cm.	countBlt := (BitBltSmalltalk toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from top and bottom"	top := (0 to: height)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0]		ifNone: [^ 0@0 extent: 0@0].	bottom := (height - 1 to: top by: -1)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0].	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of interest"	newH := bottom - top + 1.	slice := Form extent: 1@newH depth: 1.	copyBlt := (BitBltSmalltalk toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: 1 height: newH;		colorMap: cm.	countBlt := (BitBltSmalltalk toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from left and right"	left := (0 to: width)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	right := (width - 1 to: left by: -1)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	^ left@top corner: (right + 1)@(bottom + 1)! !!SimulationForm methodsFor: 'analyzing' stamp: 'tfel 1/18/2014 15:26'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."	(BitBltSmalltalk toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		tallyMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r := Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies := (Display copy: r) tallyPixelValues.	nonZero := (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!SimulationForm methodsFor: 'analyzing' stamp: 'tfel 1/18/2014 15:26'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm := self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice := Form extent: 1@height.	copyBlt := (BitBltSmalltalk destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt := (BitBltSmalltalk toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!SimulationForm methodsFor: 'analyzing' stamp: 'tfel 1/18/2014 15:27'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm := self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice := Form extent: width@1.	copyBlt := (BitBltSmalltalk destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt := (BitBltSmalltalk toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!SimulationForm methodsFor: 'pixel access' stamp: 'tfel 1/18/2014 15:25'!pixelValueAt: aPoint put: pixelValue	"Store the given raw pixel value at the given point. Typical clients use colorAt:put: to store a color. "	(BitBltSmalltalk bitPokerToForm: self) pixelAt: aPoint put: pixelValue.! !!SimulationForm methodsFor: 'pixel access' stamp: 'tfel 1/18/2014 15:25'!primPixelValueAtX: x y: y 	"Return the raw pixel value at the given point. This pixel value depends on the receiver's depth. Typical clients use colorAt: to get a Color. Make sure the colorMap is nil for ColorForms "	"<primitive: 'primitivePixelValueAt' module:'BitBltPlugin'>"	^(BitBltSmalltalk bitPeekerFromForm: self) colorMap: nil;  pixelAt: x@y! !!SimulationForm methodsFor: 'image manipulation' stamp: 'tfel 1/18/2014 15:26'!replaceColor: oldColor withColor: newColor	"Replace one color with another everywhere is this form"	| cm newInd target ff |	self depth = 32		ifTrue: [cm := (Color  cachedColormapFrom: 16 to: 32) copy]		ifFalse: [cm := Bitmap new: (1 bitShift: (self depth min: 15)).				1 to: cm size do: [:i | cm at: i put: i - 1]].	newInd := newColor pixelValueForDepth: self depth.	cm at: (oldColor pixelValueForDepth: (self depth min: 16))+1 put: newInd.	target := newColor isTransparent 		ifTrue: [ff := Form extent: self extent depth: depth.			ff fillWithColor: newColor.  ff]		ifFalse: [self].	(BitBltSmalltalk toForm: target)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form paint;		destX: 0 destY: 0 width: width height: height;		colorMap: cm;		copyBits.	newColor = Color transparent 		ifTrue: [target displayOn: self].! !!SimulationForm methodsFor: 'image manipulation' stamp: 'tfel 1/18/2014 15:26'!smear: dir distance: dist	"Smear any black pixels in this form in the direction dir in Log N steps"	| skew bb |	bb := BitBltSmalltalk destForm: self sourceForm: self fillColor: nil		combinationRule: Form under destOrigin: 0@0 sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox.	skew := 1.	[skew < dist] whileTrue:		[bb destOrigin: dir*skew; copyBits.		skew := skew+skew]! !!SimulationForm methodsFor: 'image manipulation' stamp: 'tfel 1/18/2014 15:30'!stencil	"return a 1-bit deep, black-and-white stencil of myself"	| canvas |	canvas := SimulationFormCanvas extent: self extent depth: 1.	canvas fillColor: (Color white).	canvas stencil: self at: 0@0  				sourceRect: (Rectangle origin: 0@0 corner: self extent) color: Color black.	^ canvas form! !!SimulationForm methodsFor: 'accessing' stamp: 'tfel 1/18/2014 15:30'!defaultCanvasClass	"Return the default canvas used for drawing onto the receiver"	^ SimulationFormCanvas! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SimulationForm class	instanceVariableNames: ''!!SimulationForm class methodsFor: 'instance creation' stamp: 'tfel 1/18/2014 15:27'!dotOfSize: diameter	"Create a form which contains a round black dot."	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |	radius := diameter//2.	form := self extent: diameter@diameter offset: (0@0) - (radius@radius).		bb := (BitBltSmalltalk toForm: form)		sourceX: 0; sourceY: 0;		combinationRule: Form over;		fillColor: Color black.	rect := form boundingBox.	centerX := rect center x.	centerY := rect center y.	centerYBias := rect height odd ifTrue: [0] ifFalse: [1].	centerXBias := rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared := (rect height asFloat / 2.0) squared - 0.01.	xOverY := rect width asFloat / rect height asFloat.	maxy := rect height - 1 // 2.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx := ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		bb	destX: centerX - centerXBias - dx			destY: centerY - centerYBias - dy			width: dx + dx + centerXBias + 1			height: 1;			copyBits.		bb	destY: centerY + dy;			copyBits].	^ form"Time millisecondsToRun:	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]"! !!SimulationForm class methodsFor: 'examples' stamp: 'tfel 1/18/2014 16:16'!drawWorld	"	self drawWorld	"	| form |	form := self extent: World extent depth: 32.	World fullDrawOn: form getCanvas.	form displayOn: Display.	[Sensor anyButtonPressed] whileFalse: [].	Display restore.! !!SimulationForm class methodsFor: 'examples' stamp: 'tfel 1/18/2014 15:27'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors := Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade := Form extent: diam@diam offset: (diam // -2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam // 2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x * diam // 5) displayOn: facade			at: (diam * 2 // 5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball := Form dotOfSize: diam.	color := 8.	[port := BitBltSmalltalk toForm: Display.	"Expand 1-bit forms to any pixel depth"	port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	queue := OrderedCollection new: 32.	16 timesRepeat: [queue addLast: -20 @ -20].	Sensor waitButton.	Sensor yellowButtonPressed ifTrue: [^ self].	filter := Sensor cursorPoint.	colr := colors atWrap: (color := color + 5).  "choose increment relatively prime to colors size"	colr2 := colr alphaMixed: 0.3 with: Color white.	[Sensor redButtonPressed or: [queue size > 0]] whileTrue:		[filter := filter * 4 + Sensor cursorPoint  //  5.		point := Sensor redButtonPressed			ifTrue: [filter] ifFalse: [-20 @ -20].		port copyForm: ball to: point rule: Form paint fillColor: colr.		(q := queue removeFirst) == nil ifTrue: [^ self].	"exit"		Display depth = 1			ifTrue: [port copyForm: facade to: q rule: Form erase]			ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].		Sensor redButtonPressed ifTrue: [queue addLast: point]]] repeat.! !FormCanvas subclass: #SimulationFormCanvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BitBltPureSmalltalk'!!SimulationFormCanvas methodsFor: 'private' stamp: 'tfel 1/18/2014 15:29'!portClass	"Return the class used as port"	^BitBltSmalltalk asGrafPort! !!SimulationFormCanvas methodsFor: 'other' stamp: 'tfel 1/18/2014 15:29'!showAt: pt invalidRects: updateRects	| blt |	blt := (BitBltSmalltalk toForm: Display)		sourceForm: form;		combinationRule: Form over.	updateRects do:		[:rect |		blt sourceRect: rect;			destOrigin: rect topLeft + pt;			copyBits]! !BitBltPure initialize!BitBltSmalltalk initialize!