
----STARTUP----{15 January 2014 . 2:16:33 pm} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/15/2014 14:33' prior: 42646392!benchStm	[(1 to: 1000)		do: [:t1 | SPyVM print: 'Thread 1 reporting!!']] parallelFork.	[(1 to: 1000)		do: [:t1 | SPyVM print: 'Thread 2 reporting!!']] parallelFork.	[(1 to: 1000)		do: [:t1 | SPyVM print: 'Thread 3 reporting!!']] parallelFork.	[(1 to: 1000)		do: [:t1 | SPyVM print: 'Thread 4 reporting!!']] parallelFork.	(1 to: 1000)		do: [:x | SPyVM print: '* spinlock *'].	^ 42 printString! !----SNAPSHOT----{15 January 2014 . 2:33:47 pm} Squeak4.5-12568.image priorSource: 9103122!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/15/2014 14:35' prior: 42656801!benchStm3	| t1 t2 |	t1 := [(1 to: 100)				do: [:t3 | SPyVM print: 'Thread 1 reporting!!']] parallelFork.	t2 := [(1 to: 100)				do: [:t3 | SPyVM print: 'Thread 2 reporting!!']] parallelFork.	SPyVM print: 'Waiting for Task 1'.	t1 wait.	SPyVM print: 'Waiting for Task 2'.	t2 wait.	SPyVM print: 'Finished waiting.'! !----SNAPSHOT----{15 January 2014 . 2:36:01 pm} Squeak4.5-12568.image priorSource: 594!!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/15/2014 14:37' prior: 42653846!wait	<primitive: 789>	SPyVM print: ' Failed to wait for process!! '! !----SNAPSHOT----{15 January 2014 . 2:37:09 pm} Squeak4.5-12568.image priorSource: 1091!----STARTUP----{16 January 2014 . 9:13:20 pm} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!BlockClosure methodsFor: 'scheduling' stamp: 'toma 1/16/2014 21:13' prior: 42654183!parallelFork	^ (self newSTMProcess) fork; yourself! !----SNAPSHOT----{16 January 2014 . 9:14:01 pm} Squeak4.5-12568.image priorSource: 1345!!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 21:14'!primWait	<primitive: 789>	SPyVM print: ' Failed to wait for process!! '! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 21:15' prior: 33555705!wait		SPyVM print: '[squeak] wait'	self primWait! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 21:15' prior: 33556450!wait		SPyVM print: '[squeak] wait'.	self primWait! !----SNAPSHOT----{16 January 2014 . 9:15:29 pm} Squeak4.5-12568.image priorSource: 1681!!BasicClassOrganizer methodsFor: 'accessing' stamp: 'toma 1/16/2014 22:18' prior: 17298983!classComment	classComment		ifNil: [^ ''].	^ [classComment text ifNil: ['']] on: Error do: [^ ''].! !Object subclass: #SPySTM	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SPy-Benchmarks'!Object subclass: #SPySTM	instanceVariableNames: ''	classVariableNames: 'Shared'	poolDictionaries: ''	category: 'SPy-Benchmarks'!!SPySTM class methodsFor: 'nil' stamp: 'toma 1/16/2014 22:22'!shared		^self Shared! !!SPySTM class methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:23' prior: 33557264!shared		^Shared! !!SPySTM class methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:23'!shared: aValue		Shared := aValue! !----SNAPSHOT----{16 January 2014 . 10:24:08 pm} Squeak4.5-12568.image priorSource: 2221!Object subclass: #STMAtomic	instanceVariableNames: 'lock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!STMAtomic methodsFor: 'nil' stamp: 'toma 1/16/2014 22:28'!primEnter	<primitive: 790>! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:28' prior: 33557810!primEnter	<primitive: 790>	SPyVM print: 'primEnter failed'.! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:28' prior: 33557933!primEnter	<primitive: 790>		SPyVM print: 'primEnter failed'.! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:29'!primLeave	<primitive: 791>		SPyVM print: 'primLeave failed'.! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:29'!value		self primEnter.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:29' prior: 33558376!value		| result |		self primEnter.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:30' prior: 33558498!value		| result |		self primEnter.	result := self.	self primLeave	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:30' prior: 33558634!value		| result |		self primEnter.	result := self.	self primLeave.	! !Object subclass: #STMAtomic	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:31' prior: 33558803!value		| result |		self primEnter.	result := self block value.	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:31' prior: 33559111!value		| result error |		self primEnter.	result := self block value.	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:32' prior: 33559293!value		| result error |		self primEnter.	[result := self block value.] on: Error do: [:err | error := err]	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:32' prior: 33559481!value		| result error |		self primEnter.	error := nil.		[result := self block value.] on: Error do: [:err | error := err]	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:32' prior: 33559707!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Error do: [:err | error := err]	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:32' prior: 33559950!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Error do: [:err | error := err].	self primLeave.	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:33' prior: 33560207!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Error do: [:err | error := err].	self primLeave.	error ifNotNil: [error raise]	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:33' prior: 33560465!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Exception do: [:err | error := err].	self primLeave.	error ifNotNil: [error raise]	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:35' prior: 33560754!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Exception do: [:err | error := err].	self primLeave.	error ifNotNil: [error pass]	! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:35' prior: 33561047!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Exception do: [:err | error := err].	self primLeave.	error ifNotNil: [error pass]		! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:35' prior: 33561339!value		| result error |		self primEnter.	error := nil.	result := nil.	[result := self block value.] on: Exception do: [:err | error := err].	self primLeave.	error ifNotNil: [error pass].	^result	! !!STMAtomic class methodsFor: 'nil' stamp: 'toma 1/16/2014 22:36'!from: aBlock		^ (STMAtomic new)		block: aBlock;		yourself.! !!STMAtomic class methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:36' prior: 33561909!from: aBlock		^ (STMAtomic new)		block: aBlock;		yourself! !!BlockClosure methodsFor: 'nil' stamp: 'toma 1/16/2014 22:37'!atomic		^STMAtomic from: self! !SystemOrganization addCategory: #'Kernel-STM'!SystemOrganization classify: #STMAtomic under: #'Kernel-STM'!SystemOrganization classify: #STMProcess under: #'Kernel-STM'!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:40'!benchStmAtomic	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:40' prior: 33562476!benchStmAtomic		| sum |	sum := 0.	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:40' prior: 33562577!benchStmAtomic		| sum |	sum := 0.	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:40' prior: 33562700!benchStmAtomic		| sum |	sum := 0.		! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:41'!benchStmParallel		| sum |	sum := 0.		! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:41' prior: 33562933!benchStmParallel		| sum |	sum := 0.		(1 to: self) do: [ :i |		[(1 to: 100) do: [ :k | sum := sum + k ]]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:42' prior: 33563060!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[(1 to: 100) do: [ :k | sum := sum + k ]]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:42' prior: 33563258!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[(i to: (i + 1000)) do: [ :k | sum := sum + k ]]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:42' prior: 33563453!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k ]]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:43' prior: 33563655!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k ]] parallelFork		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:43' prior: 33563872!benchStmParallel		| sum |	sum := 0.		(1 to: 8) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k. ]] parallelFork.		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:43' prior: 33564102!benchStmParallel		| sum |	sum := 0.		(0 to: 7) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k. ]] parallelFork.		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:43' prior: 33564334!benchStmParallel		| sum |	sum := 0.		(0 to: 7) do: [ :i |		[((i * 1000) to: ((i + 1) * 1000)) do: [ :k | sum := sum + k. ]] parallelFork.		]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:46' prior: 33564566!benchStmParallel		| sum t |	sum := 0.		(0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				sum := sum + k. ]			] parallelFork		]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:46' prior: 33564800!benchStmParallel		| sum threads |	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				sum := sum + k. ]			] parallelFork		]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:46' prior: 33565051!benchStmParallel		| sum threads |	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait.]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:46' prior: 33565319!benchStmParallel		| sum threads |	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{16 January 2014 . 10:47:04 pm} Squeak4.5-12568.image priorSource: 3090!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:56' prior: 33562824!benchStmAtomic	| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:57' prior: 33566018!benchStmAtomic	| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000 - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:57' prior: 33565614!benchStmParallel		| sum threads |	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000 - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 22:57' prior: 33566678!benchStmParallel		| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * 1000) to: ((i + 1) * 1000 - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{16 January 2014 . 10:58:17 pm} Squeak4.5-12568.image priorSource: 11414!!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:01' prior: 33561633!value		| result  |		self primEnter.	result := self block value.	self primLeave.	^result	! !!STMAtomic methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:02'!block	^ block! !!STMAtomic methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:02'!block: anObject	block := anObject! ![ 1 + 1 ] atomic value![ 1 + 1 ] atomic value!----SNAPSHOT----{16 January 2014 . 11:03:21 pm} Squeak4.5-12568.image priorSource: 12802!----SNAPSHOT----{16 January 2014 . 11:03:41 pm} Squeak4.5-12568.image priorSource: 13325!----SNAPSHOT----{16 January 2014 . 11:03:45 pm} Squeak4.5-12568.image priorSource: 13416!BlockClosure organization addCategory: #STM!BlockClosure organization classify: #atomic under: #STM!!BlockClosure methodsFor: 'STM' stamp: 'toma 1/16/2014 22:37' prior: 33562201!atomic		^STMAtomic from: self! !BlockClosure organization classify: #newSTMProcess under: #STM!!BlockClosure methodsFor: 'STM' stamp: '' prior: 42643259!newSTMProcess	^ STMProcess forContext: [self value] asContext priority: Processor activePriority! !!BlockClosure methodsFor: 'STM' stamp: '' prior: 33568373!newSTMProcess	^ STMProcess forContext: [self value] asContext priority: Processor activePriority! !BlockClosure organization classify: #parallelFork under: #STM!!BlockClosure methodsFor: 'STM' stamp: 'toma 1/16/2014 21:13' prior: 33556059!parallelFork	^ (self newSTMProcess) fork; yourself! !Object subclass: #STMFuture	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMFuture	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:33'!block	^ block! !!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:33'!block: anObject	block := anObject! !!STMFuture methodsFor: 'nil' stamp: 'toma 1/16/2014 23:34'!invoke		! !Object subclass: #STMFuture	instanceVariableNames: 'block process'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:34'!process	^ process! !!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:34'!process: anObject	process := anObject! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:35' prior: 33569341!invoke		self process: (self block parallelFork)! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:35'!value	! !Object subclass: #STMFuture	instanceVariableNames: 'block process result'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:35'!result	^ result! !!STMFuture methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:35'!result: anObject	result := anObject! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:36' prior: 33569785!invoke		self process: ([self result: self block value] parallelFork)! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:36' prior: 33569914!value		self process wait.! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:36' prior: 33570525!value		self process wait.	^self result! !!STMFuture class methodsFor: 'nil' stamp: 'toma 1/16/2014 23:37'!invoke: aBlock		^(STMFuture new)		block: aBlock;		invoke;		yourself! !!BlockClosure methodsFor: 'STM' stamp: 'toma 1/16/2014 23:38'!async	^STMFuture invoke: self! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:38'!benchStmFuture		! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:39' prior: 33570998!benchStmFuture		| futures | 	! !(1 to: 100) sum!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:40' prior: 33571101!benchStmFuture		| futures | 	futures := (0 to: 7) collect: [ :id |		[(1 to: 1000) sum ]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:41' prior: 33571236!benchStmFuture		| futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:41' prior: 33571416!benchStmFuture		| futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async]	! !(1 to: 100) inject: 0 into: [ :i :k | i + k]!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:43' prior: 33571596!benchStmFuture		| sum futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :s :f | s + (f value)]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:44' prior: 33571825!benchStmFuture		| sum futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/16/2014 23:44' prior: 33572069!benchStmFuture		| sum futures | 	futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !----SNAPSHOT----{16 January 2014 . 11:45:18 pm} Squeak4.5-12568.image priorSource: 13507!----SNAPSHOT----{16 January 2014 . 11:45:23 pm} Squeak4.5-12568.image priorSource: 18085!----SNAPSHOT----{16 January 2014 . 11:46:35 pm} Squeak4.5-12568.image priorSource: 18176!Object subclass: #STMWorker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMWorker	instanceVariableNames: 'queue'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:23' prior: 33570359!invoke	self process ifNil: [		self process: ([self result: self block value] parallelFork)		] ifNotNil: [		]! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:23' prior: 33573142!invoke	self process ifNil: [		self process: ([self result: self block value] parallelFork)	] ifNotNil: [			]! !self!!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:23' prior: 33573350!invoke	self process ifNil: [		self process: ([self result: self block value] parallelFork)	] ifNotNil: [		self error: 'Future already invoked'	]! !!STMFuture methodsFor: 'nil' stamp: 'toma 1/17/2014 00:24'!initialize		super initialize.! !STMFuture removeSelector: #initialize!!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:26' prior: 33570648!value		self process ifNotNil: [		self process wait.		^self result	] ifNil: [		self error: 'Future not invoked'	]	! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:26' prior: 33573946!value		self process ifNotNil: [		self wait.		^self result	] ifNil: [		self error: 'Future not invoked'	]	! !!STMFuture methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:26'!wait		self process wait.! !!STMWorker methodsFor: 'nil' stamp: 'toma 1/17/2014 00:28'!submit: aBlock callback: aUnaryBlock		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:30'!send: aSymbol with: anArgument	! !STMWorker removeSelector: #submit:callback:!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:30'!on: aSymbol do: aBlock	! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:30' prior: 33574724!on: aSymbol do: aBlock		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:31'!onMessage: aSymbol do: aBlock		! !STMWorker removeSelector: #on:do:!Object subclass: #STMWorker	instanceVariableNames: 'queue handlers'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMWorker methodsFor: 'nil' stamp: 'toma 1/17/2014 00:31'!initialize		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:31' prior: 33575225!initialize		handlers := Dictionary new.! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:32'!queue	^ queue! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:32'!queue: anObject	queue := anObject! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:32'!handlers	^ handlers! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:32'!handlers: anObject	handlers := anObject! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:32' prior: 33575335!initialize		self handlers: Dictionary new.! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:32' prior: 33574951!onMessage: aSymbol do: aBlock		self handlers at: aSymbol put: aBlock! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:32' prior: 33574566!send: aSymbol with: anArgument	! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:32' prior: 33576170!send: aSymbol with: anArgument		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:34' prior: 33576299!send: aSymbol with: anArgument		! !Object subclass: #STMMessage	instanceVariableNames: 'queue handlers'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMMessage	instanceVariableNames: 'name arg'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMMessage	instanceVariableNames: 'name args'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!{1. 2.}!{1. 2. World.}![:i :j | i + j]![:i :j | i + j] valueWithArguments: {1. 2.}!!STMMessage class methodsFor: 'nil' stamp: 'toma 1/17/2014 00:39'!named: aSymbol withArgs: anArray		^(self new)		name: aSymbol;		arguments: anArray;		yourself! !Object subclass: #STMMessage	instanceVariableNames: 'name arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:39'!name: anObject	name := anObject! !!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:39'!arguments	^ arguments! !!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:39'!arguments: anObject	arguments := anObject! !Object subclass: #STMMessage	instanceVariableNames: 'messageName arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:40'!messageName	^ messageName! !!STMMessage methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:40'!messageName: anObject	messageName := anObject! !STMMessage removeSelector: #name:!!STMMessage class methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:40' prior: 33577040!named: aSymbol withArgs: anArray		^(self new)		messageName: aSymbol;		arguments: anArray;		yourself! !a := {1. 2. 3.}!a := OrderedCollection new!a add: 5!a!a add: 5!a!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:44' prior: 33576429!send: aSymbol with: anArgument		self queue! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:44' prior: 33575864!initialize		self handlers: Dictionary new.	self queue: Stack new.! !a := Stack new!a := Stack new!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:47' prior: 33578512!initialize		self handlers: Dictionary new.	self queue: LinkedList new.! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:48' prior: 33578372!send: aSymbol with: anArgument		self queue addLast: (STMMessage named: aSymbol with: {anArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:48' prior: 33578879!send: aSymbol with: anArgument		self queue addLast: (STMMessage named: aSymbol withArgs: {anArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:48' prior: 33579075!send: aSymbol with: anArgument		self queue addLast: (		STMMessage named: aSymbol withArgs: {anArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:49'!send: aSymbol with: anArgument with: anotherArgument		self queue addLast: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument.})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:49'!send: aSymbol with: anArgument and: anotherArgument		self queue addLast: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument.})! !STMWorker removeSelector: #send:with:with:!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:49'!send: aSymbol with: anArgument and: anotherArgument and: aThirdArgument		self queue addLast: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument. aThirdArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:50'!loop	! !Object subclass: #STMWorker	instanceVariableNames: 'queue handlers active'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:50'!active	^ active! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:50'!active: anObject	active := anObject! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:50' prior: 33580221!loop		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:51' prior: 33580665!loop		self active: true.	[self active] whileTrue: [	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:51' prior: 33580769!loop		self active: true.	[self active] whileTrue: [			]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:52' prior: 33580922!loop		self active: true.	[self active] whileTrue: [		[self queue isEmpty] ifFalse: [					]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:52' prior: 33581078!loop		self active: true.	[self active] whileTrue: [		[self queue isEmpty] ifFalse: [			| message | 			[message := self queue removeFirst]		]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:52' prior: 33581273!loop		self active: true.	[self active] whileTrue: [		| message | 		[self queue isEmpty] ifFalse: [						[message := self queue removeFirst]		]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:53' prior: 33581519!loop		self active: true.	[self active] whileTrue: [		| message | 		message := nil.		[self queue isEmpty] ifFalse: [						[message := self queue removeFirst]		]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:53' prior: 33581768!loop		self active: true.	[self active] whileTrue: [		| message | 		message := nil.		[ [self queue isEmpty] ifFalse: [				[message := self queue removeFirst]		] ] atomic value.	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:53' prior: 33582035!loop		self active: true.	[self active] whileTrue: [		| message | 		message := nil.		[ [self queue isEmpty] ifFalse: [				[message := self queue removeFirst]		] ] atomic value.			]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:54'!receive		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:54' prior: 33582318!loop		self active: true.	[self active] whileTrue: [					]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:54' prior: 33582587!receive		| message | 		message := nil.		[ [self queue isEmpty] ifFalse: [				[message := self queue removeFirst]		] ] atomic value.! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:54' prior: 33582853!receive		| message | 		message := nil.	[ [self queue isEmpty] ifFalse: [				[message := self queue removeFirst]] 	] atomic value.	^message! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:55' prior: 33575531!queue: aMessage		! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:55' prior: 33583328!queue: aMessage		[self queue addLast: aMessage] atomic value! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:56' prior: 33583443!queue: anObject		queue := anObject! !!STMWorker methodsFor: 'accessing' stamp: 'toma 1/17/2014 00:56'!schedule: aMessage	[self queue addLast: aMessage] atomic value! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:58' prior: 33579275!send: aSymbol with: anArgument		self schedule: (		STMMessage named: aSymbol withArgs: {anArgument})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:58' prior: 33579689!send: aSymbol with: anArgument and: anotherArgument		self schedule: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument.})! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:58' prior: 33579960!send: aSymbol with: anArgument and: anotherArgument and: aThirdArgument		self schedule: (		STMMessage named: aSymbol withArgs: {anArgument. anotherArgument. aThirdArgument})! !STMWorker organization classify: #schedule: under: #'as yet unclassified'!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 00:56' prior: 33583697!schedule: aMessage	[self queue addLast: aMessage] atomic value! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:00' prior: 33582694!loop		self active: true.	[self active] whileTrue: [		self receive ifNotNilDo: [ :m						]			]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:01' prior: 33584800!loop		self active: true.	[self active] whileTrue: [		self receive ifNotNilDo: [ :m |			(self handlers at: (m messageName))				valueWithArguments: (m arguments)			]			]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:01' prior: 33584997!loop		self active: true.	[self active] whileTrue: [		self receive ifNotNilDo: [ :m |			(self handlers at: (m messageName))				valueWithArguments: (m arguments)			]	]! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:01'!stop	self active: False! !!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:01'!start		[self loop] parallelFork! !w := STMWorker new!w onMessage: #test do: [:i | Transcript show: i]!w start!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:03' prior: 33583086!receive		| message | 		message := nil.	[ (self queue isEmpty) ifFalse: [				[message := self queue removeFirst]] 	] atomic value.	^message! !w stop!!STMWorker methodsFor: 'as yet unclassified' stamp: 'toma 1/17/2014 01:04' prior: 33585522!stop	self active: false! !Smalltalk renameClassNamed: #STMWorker as: #STMActor!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:06'!benchStmActor		| a1 a2 |	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:06' prior: 33586238!benchStmActor		| a1 a2 |		a1 := STMActor new.	a2 := STMActor new.	! !1 printString!1 printString!1 printString!'1'!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:14' prior: 33586352!benchStmActor		| a |		a := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		(n < 1) 			ifTrue: [SPyVM print: (sum2 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		]! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:14' prior: 33586563!benchStmActor		| a |		a := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		]	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:15' prior: 33586879!benchStmActor		| a |		a := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		]	a start.	! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:18' prior: 33587197!benchStmActor		| a b |		a := STMActor new.	b := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'a'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [b send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	b onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'b'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	a start.	b start.	a send: #fibonacci with: self and: 1 and: 1.! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:19' prior: 33587525!benchStmActor		| a b |		a := STMActor new.	b := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'a'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [b send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	b onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'b'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	a start.	b start.	a send: #fibonacci with: self and: 1 and: 1.	(1 to: 1000) do: [:i | SPyVM print: '.']! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:19' prior: 33588158!benchStmActor		| a b |		a := STMActor new.	b := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'a'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [b send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	b onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'b'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	a start.	b start.	a send: #fibonacci with: self and: 1 and: 1.	(1 to: 1000) do: [:i | SPyVM print: '.']	a stop.	b stop.! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 01:19' prior: 33588833!benchStmActor		| a b |		a := STMActor new.	b := STMActor new.	a onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'a'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [b send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	b onMessage: #fibonacci do: [ :n :sum1 :sum2 | 		SPyVM print: 'b'.		(n < 1) 			ifTrue: [SPyVM print: (sum1 printString) ] 			ifFalse: [a send: #fibonacci with: (n - 1) and: sum2 and: (sum1 + sum2)]		].	a start.	b start.	a send: #fibonacci with: self and: 1 and: 1.	(1 to: 1000) do: [:i | SPyVM print: '.'].	a stop.	b stop.! !----SNAPSHOT----{17 January 2014 . 1:19:41 am} Squeak4.5-12568.image priorSource: 18267!----SNAPSHOT----{17 January 2014 . 1:23 am} Squeak4.5-12568.image priorSource: 35706!10 benchStmActor!----QUIT/NOSAVE----{17 January 2014 . 1:24:53 am} Squeak4.5-12568.image priorSource: 35796!----STARTUP----{17 January 2014 . 5:10:50 pm} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:00' prior: 33566346!benchStmAtomic	| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{17 January 2014 . 7:00:29 pm} Squeak4.5-12568.image priorSource: 35796!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:01' prior: 33566996!benchStmParallel		| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * 1000 - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:01' prior: 33591037!benchStmParallel		| sum threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{17 January 2014 . 7:01:14 pm} Squeak4.5-12568.image priorSource: 36433!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:18' prior: 33591357!benchStmParallel		| sum num threads |		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:20' prior: 33591767!benchStmParallel		| sum num threads |		num := self \\ 100.	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:20' prior: 33592091!benchStmParallel		| sum num threads max |		num := self \\ 100.	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:20' prior: 33592436!benchStmParallel		| sum num threads max |		num := self \\ 100.	max := self - num.	sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33592785!benchStmParallel		| sum num threads max |		num := self \\ 100.	max := self - num.	sum := 0.		threads := (0 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33590615!benchStmAtomic	| sum threads max num |		num := self \\ 100.	max := self - num.	sum := 0.		sum := 0.		threads := (0 to: 7) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33593523!benchStmAtomic	| sum threads max num |		num := self \\ 100.	max := self - num.	sum := 0.		sum := 0.		threads := (0 to: num) collect: [ :i | 		 [((i * self) to: ((i + 1) * self - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33593917!benchStmAtomic	| sum threads max num |		num := self \\ 100.	max := self - num.	sum := 0.		sum := 0.		threads := (0 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:21' prior: 33594313!benchStmAtomic	| sum threads max num |		num := self \\ 100.	max := self - num.	sum := 0.		threads := (0 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				[sum := sum + k. ] atomic value]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !----SNAPSHOT----{17 January 2014 . 7:21:58 pm} Squeak4.5-12568.image priorSource: 37163!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:25' prior: 33572325!benchStmFuture		| sum num threads max futures |		num := self \\ 100.	max := self - num.	sum := 0.		futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:25' prior: 33595178!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := self - num.	sum := 0.		futures := (0 to: 7) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:25' prior: 33595523!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := self - num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: 1000) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:25' prior: 33595860!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := self - num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:26' prior: 33596199!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := (self - num) \\ num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:26' prior: 33596537!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := (self - num) // num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/17/2014 19:26' prior: 33596884!benchStmFuture		| sum num max futures |		num := self \\ 100.	max := self // num.	sum := 0.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !----SNAPSHOT----{17 January 2014 . 7:26:27 pm} Squeak4.5-12568.image priorSource: 40574!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:20' prior: 33597231!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.			futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].	^ sum printString! !Time now!Time now!Time now!Time now!Time now asNanoSeconds!Time now asNanoSeconds!Time now asNanoSeconds!Time now asNanoSeconds!Time now asNanoSeconds!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:25' prior: 33597660!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: 'µs'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:25' prior: 33598176!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: 'µs inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:25' prior: 33598657!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] µs inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!Time now asNanoSeconds // 1000000!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 15:26' prior: 33599153!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 3:26:07 pm} Squeak4.5-12568.image priorSource: 43056!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 16:30' prior: 33599946!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (0 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 16:31' prior: 33600550!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := self // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 16:36' prior: 33601163!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 4:36:36 pm} Squeak4.5-12568.image priorSource: 45946!----SNAPSHOT----{18 January 2014 . 4:36:48 pm} Squeak4.5-12568.image priorSource: 47883!----STARTUP----{18 January 2014 . 10:05:52 pm} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:06' prior: 33593154!benchStmParallel		| sum num threads max start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		threads := (0 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:06' prior: 33602684!benchStmParallel		| sum num threads max start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:07' prior: 33603203!benchStmParallel		| sum num threads max start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				sum := sum + k. ]			] parallelFork		].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:07' prior: 33594707!benchStmAtomic		| sum num threads max start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		threads := (1 to: num) collect: [ :i | 		 [((i * max) to: ((i + 1) * max - 1)) do: [ :k | 				[sum := sum + k.] atomic value. ]			] parallelFork		].	threads do: [:t | t wait].	SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.	^ sum printString! !----SNAPSHOT----{18 January 2014 . 10:07:37 pm} Squeak4.5-12568.image priorSource: 47973!----SNAPSHOT----{18 January 2014 . 10:48:10 pm} Squeak4.5-12568.image priorSource: 50518!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:59' prior: 33601776!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0.  [(1 to: max) do: [:i | s := s + 1] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:59'!benchStmFuture2		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0.  [(1 to: max) do: [:i | s := s + 1] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:59' prior: 33605214!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0.  [(1 to: max) do: [:i | s := s + 1] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 22:59' prior: 33606505!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0.  [(1 to: max) do: [:i | s := s + 1] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 16:36' prior: 33607158!benchStmFuture		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 11:01:12 pm} Squeak4.5-12568.image priorSource: 50609!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:13'!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [(1 to: max) sum] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:14' prior: 33608507!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | [ (1 to: max) inject: 1 into: [:next :each | (next + each) \\ 1000000 ] ] async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 11:14:38 pm} Squeak4.5-12568.image priorSource: 53918!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:27' prior: 33609129!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s:=0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1] ]  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:27' prior: 33609898!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s:=0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1] ]  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:27' prior: 33610601!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s:=0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33611305!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33612021!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33612739!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33613460!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [			:i | i isPrime ifTrue:[s := s + 1]]. s yourself.  ]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33614183!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [			:i | i isPrime ifTrue:[s := s + 1]			]. s yourself.  ]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33614910!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [			:i | i isPrime ifTrue:[s := s + 1]		]. s yourself.  ]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:28' prior: 33615641!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) max do: [			:i | i isPrime ifTrue:[s := s + 1]			]. s yourself.  		]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 11:28:45 pm} Squeak4.5-12568.image priorSource: 55293!0 isPrime!1 isPrime!2 isPrime!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/18/2014 23:33' prior: 33616371!benchStmFuture3		| sum num max futures start |		num := self \\ 100.	max := (self - num) // num.	sum := 0.	SPyVM print: ('Threads:', (num printString)).	SPyVM print: ('Items/Thread:', (max printString)).		start := Time now asNanoSeconds.		futures := (1 to: num) collect: [ :id | |s| 		s := 0. 		[ (id - 1 * max) to: (id * max - 1) do: [			:i | i isPrime ifTrue:[s := s + 1]			]. s yourself.  		]  async	].	sum := futures inject: 0 into: [ :next :each | next + (each value)].		SPyVM print: '[squeak] milliseconds inside method:'.	SPyVM print: (((Time now asNanoSeconds) - start) // 1000000) printString.		^ sum printString! !----SNAPSHOT----{18 January 2014 . 11:33:23 pm} Squeak4.5-12568.image priorSource: 62591!----STARTUP----{21 January 2014 . 10:50:25 am} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!SystemOrganization addCategory: #'VM-GameOfLife'!Object subclass: #GameOfLifeField	instanceVariableNames: 'data height width'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #GameOfLifeField
	instanceVariableNames: 'data height width'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VM-GameOfLife'!!GameOfLifeField methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:23'!cellAliveAt: x at: y

	^ (self at: x at: y) = 1! !!GameOfLifeField methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:14'!rows: numberOfRows columns: numberOfColumns

	self height: numberOfRows.
	self width: numberOfColumns.
	self data: (Matrix rows: numberOfRows columns: numberOfColumns element: 0).
	! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:25'!at: x at:y
	
	((x < 1) or: [x > self width]) ifTrue: [ ^ 0 ].
      ((y < 1) or: [y > self height]) ifTrue: [ ^ 0 ].

	^ self data at: y at: x! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:25'!at: x at:y put: aValue

	self data at: y at: x put: aValue.! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:02'!atRow: rowNumber put: aRow

	self data atRow: rowNumber put: aRow! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!data

	^ data! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!data: anObject

	data := anObject! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!height

	^ height! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!height: anObject

	height := anObject! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:52'!print

	| resultString |
	resultString := ''.
	(1 to: self height) do: [:y |
		(1 to: self width) do: [ :x |
			resultString := resultString , (self data at: y at: x).].
		resultString := resultString , Character cr ].
	^ resultString			! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!rowSlice: sliceSize collect: aBlock

	! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:28'!rowwiseFrom: startRow to: endRow collect: aBlock

	| newField |
	newField := GameOfLifeFieldSlice from: startRow to: endRow width: self width.
	(startRow to: endRow) do: [ :y | 
		(1 to: self width) do: [ :x | newField at: x at: y put: (aBlock value: self value: x value: y) ] ].
	^ newField! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!width

	^ width! !!GameOfLifeField methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:45'!width: anObject

	width := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GameOfLifeField class
	instanceVariableNames: ''!!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:44'!gliderFieldRows: numberOfRows columns: numberOfColumns

	| newField |
	newField := self new rows: numberOfRows columns: numberOfColumns.
	
	newField 
		at: 8 at: 5 put: 1;
		at: 9 at: 5 put: 1;	 
		at: 10 at: 5 put: 1;
		at: 10 at: 4 put: 1;
		at: 9 at: 3 put: 1.
		
	^ newField! !!GameOfLifeField class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 20:43'!rows: numberOfRows columns: numberOfColumns

	^ self new rows: numberOfRows columns: numberOfColumns! !GameOfLifeField subclass: #GameOfLifeFieldSlice	instanceVariableNames: 'startRow endRow'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!GameOfLifeField subclass: #GameOfLifeFieldSlice
	instanceVariableNames: 'startRow endRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VM-GameOfLife'!!GameOfLifeFieldSlice methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 10:22'!from: startRow to: endRow width: width

	self startRow: startRow;
		endRow: endRow;
		width: width;
		height: (endRow - startRow + 1);
		data: (Matrix rows: (endRow - startRow + 1) columns: width).
		
	^ self! !!GameOfLifeFieldSlice methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 21:31'!rowwiseDo: aBlock

	self startRow to: self endRow do: [ :rowNumber |
		aBlock value: rowNumber value: (self data atRow: (rowNumber - self startRow) + 1).
	].! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:30'!at: x at:y put: aValue

	self data at: y +  1 - self startRow at: x put: aValue.! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11'!endRow

	^ endRow! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11'!endRow: anObject

	endRow := anObject! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11'!startRow

	^ startRow! !!GameOfLifeFieldSlice methodsFor: 'accessing' stamp: 'pre 1/19/2014 21:11'!startRow: anObject

	startRow := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GameOfLifeFieldSlice class
	instanceVariableNames: ''!!GameOfLifeFieldSlice class methodsFor: 'as yet unclassified' stamp: 'pre 1/19/2014 20:53'!from: startRow to: endRow width: width

	^ self new from: startRow to: endRow width: width! !Object subclass: #STMSimulation	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #STMSimulation
	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VM-GameOfLife'!!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!initialField: aGameOfLifeField

	self field: aGameOfLifeField.
	self fieldNew: (GameOfLifeField rows: (aGameOfLifeField height) columns: (aGameOfLifeField width)).! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:50'!simulateRound: roundNumber 

	self processes: ((1 to: self numberOfProcesses) collect: [ :processNumber |
		[| rows |
		rows := self startProcess: processNumber.
		rows rowwiseDo: [ :rowNumber :aRow | self fieldNew atRow: rowNumber put: aRow ]] parallelFork. ]).
! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		"Transcript show: self fieldNew print.
		Transcript show: Character cr."
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!startProcess: processNumber

	| endOfSlice slice startOfSlice |
	slice := (self field height / self numberOfProcesses).
	startOfSlice := ((processNumber - 1) * slice) + 1.
	endOfSlice := processNumber * slice.

	^ self field rowwiseFrom: startOfSlice
					to: endOfSlice
					collect: [ :tempField :x :y | self thumbUpOrDownAt: x at: y on: tempField ]

	
	! !!STMSimulation methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!thumbUpOrDownAt: x at: y on: tempField 
	| liveCellCount |
	
	liveCellCount := (tempField at: x - 1 at: y - 1)
				+ (tempField at: x + 0 at: y - 1)
				+ (tempField at: x + 1 at: y - 1)
				+ (tempField at: x - 1 at: y + 0)
				+ (tempField at: x + 1 at: y + 0)
				+ (tempField at: x - 1 at: y + 1)
				+ (tempField at: x + 0 at: y + 1)
				+ (tempField at: x + 1 at: y + 1).
	
	(tempField cellAliveAt: x at: y)
		ifTrue: [((2 = liveCellCount)
					or: [liveCellCount = 3])
				ifTrue: [^ 1]
				ifFalse: [^ 0]]
		ifFalse: [(liveCellCount = 3)
				ifTrue: [^ 1]
				ifFalse: [^ 0]]! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!field

	^ field! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!field: anObject

	field := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!fieldNew

	^ fieldNew! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!fieldNew: anObject

	fieldNew := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!fieldSlices

	^ fieldSlices! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!fieldSlices: anObject

	fieldSlices := anObject! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!numberOfProcesses

	^ numberOfProcesses! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!numberOfProcesses: aNumber

	numberOfProcesses := aNumber
	! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!processes

	^ processes! !!STMSimulation methodsFor: 'accessing' stamp: 'pre 1/21/2014 09:44'!processes: anObject

	processes := anObject! !!STMSimulation methodsFor: 'initialize-release' stamp: 'pre 1/21/2014 09:44'!initialize

	self processes: OrderedCollection new.
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STMSimulation class
	instanceVariableNames: ''!!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!benchmark

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!benchmark2

	^ (1 to: 5) collect: [ :i |
			[ self standardSimulation2: (2 raisedTo: i) ] timeToRun ]! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!standardSimulation2: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !!STMSimulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/21/2014 09:44'!standardSimulation: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !Object subclass: #Simulation	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'	classVariableNames: ''	poolDictionaries: ''	category: 'VM-GameOfLife'!Object subclass: #Simulation
	instanceVariableNames: 'processes field numberOfProcesses fieldSlices fieldNew'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VM-GameOfLife'!!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:37'!initialField: aGameOfLifeField

	self field: aGameOfLifeField.
	self fieldNew: (GameOfLifeField rows: (aGameOfLifeField height) columns: (aGameOfLifeField width)).! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:44'!simulateRound: roundNumber 

	self processes: ((1 to: self numberOfProcesses) collect: [ :processNumber |
		| semaphore |
		semaphore := Semaphore new.
		[| rows |
		rows := self startProcess: processNumber.
		rows rowwiseDo: [ :rowNumber :aRow | self fieldNew atRow: rowNumber put: aRow ].
		semaphore signal] fork.
		semaphore ]).
! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:00'!simulateRounds: numberOfRounds
	
	| swapField |

	1 to: numberOfRounds do: [ :roundNumber |
		self simulateRound: roundNumber.
		self processes do: [ :semaphore | semaphore wait. ].
		
		"Transcript show: self fieldNew print.
		Transcript show: Character cr."
		
		swapField := self field.
		self field: self fieldNew.
		self fieldNew: swapField.
	].

	^ self field! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:34'!startProcess: processNumber

	| endOfSlice slice startOfSlice |
	slice := (self field height / self numberOfProcesses).
	startOfSlice := ((processNumber - 1) * slice) + 1.
	endOfSlice := processNumber * slice.

	^ self field rowwiseFrom: startOfSlice
					to: endOfSlice
					collect: [ :tempField :x :y | self thumbUpOrDownAt: x at: y on: tempField ]

	
	! !!Simulation methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 10:48'!thumbUpOrDownAt: x at: y on: tempField 
	| liveCellCount |
	
	liveCellCount := (tempField at: x - 1 at: y - 1)
				+ (tempField at: x + 0 at: y - 1)
				+ (tempField at: x + 1 at: y - 1)
				+ (tempField at: x - 1 at: y + 0)
				+ (tempField at: x + 1 at: y + 0)
				+ (tempField at: x - 1 at: y + 1)
				+ (tempField at: x + 0 at: y + 1)
				+ (tempField at: x + 1 at: y + 1).
	
	(tempField cellAliveAt: x at: y)
		ifTrue: [((2 = liveCellCount)
					or: [liveCellCount = 3])
				ifTrue: [^ 1]
				ifFalse: [^ 0]]
		ifFalse: [(liveCellCount = 3)
				ifTrue: [^ 1]
				ifFalse: [^ 0]]! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04'!field

	^ field! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04'!field: anObject

	field := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:06'!fieldNew

	^ fieldNew! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 22:06'!fieldNew: anObject

	fieldNew := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:30'!fieldSlices

	^ fieldSlices! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:30'!fieldSlices: anObject

	fieldSlices := anObject! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:09'!numberOfProcesses

	^ numberOfProcesses! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:09'!numberOfProcesses: aNumber

	numberOfProcesses := aNumber
	! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04'!processes

	^ processes! !!Simulation methodsFor: 'accessing' stamp: 'pre 1/19/2014 20:04'!processes: anObject

	processes := anObject! !!Simulation methodsFor: 'initialize-release' stamp: 'pre 1/19/2014 20:04'!initialize

	self processes: OrderedCollection new.
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Simulation class
	instanceVariableNames: ''!!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:08'!benchmark

	^ (1 to: 4) collect: [ :i |
			[ self standardSimulation: (2 raisedTo: i) ] timeToRun ]! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 14:09'!benchmark2

	^ (1 to: 5) collect: [ :i |
			[ self standardSimulation2: (2 raisedTo: i) ] timeToRun ]! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:59'!standardSimulation2: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !!Simulation class methodsFor: 'as yet unclassified' stamp: 'pre 1/20/2014 13:59'!standardSimulation: numberOfProcesses

	^ self new
			numberOfProcesses: numberOfProcesses;
			initialField: (GameOfLifeField gliderFieldRows: 32 columns: 32);
			simulateRounds: 5.
			
			! !----End fileIn of a stream----!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 10:55'!gol		STMSimulation benchmark! !!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 10:56' prior: 33632815!gol		STMSimulation benchmark printString! !----SNAPSHOT----{21 January 2014 . 10:56:17 am} Squeak4.5-12568.image priorSource: 63448!	^STMSimulation benchmark printString!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 10:59' prior: 33632930!gol		^STMSimulation benchmark printString! !----QUIT/NOSAVE----{21 January 2014 . 11:00:27 am} Squeak4.5-12568.image priorSource: 78543!----STARTUP----{21 January 2014 . 11:00:33 am} as /home/bot/lang-smalltalk/images/Squeak4.5-12568.image!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 11:00' prior: 33632930!gol		^ STMSimulation benchmark printString! !----SNAPSHOT----{21 January 2014 . 11:00:44 am} Squeak4.5-12568.image priorSource: 78543!!Integer methodsFor: 'benchmarks' stamp: 'toma 1/21/2014 11:04'!gol2		^ STMSimulation benchmark2 printString! !Simulation benchmark!----SNAPSHOT----{21 January 2014 . 11:06:45 am} Squeak4.5-12568.image priorSource: 79132!----STARTUP----{22 July 2014 . 10:01:01 pm} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!'From Squeak4.4 of 28 April 2013 [latest update: #12627] on 22 July 2014 at 9:39:32 pm'!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStar	instanceVariableNames: 'openList closedList graph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStar	instanceVariableNames: 'openList closedList graph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStarGraph	instanceVariableNames: 'nodes start target width'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStarGraph	instanceVariableNames: 'nodes start target width'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStarNode	instanceVariableNames: 'neighbours x y costsFromStart predecessor distanceMetric'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!Object subclass: #CPBAStarNode	instanceVariableNames: 'neighbours x y costsFromStart predecessor distanceMetric'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBAbstractConstraint	instanceVariableNames: 'strength'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBAbstractConstraint	instanceVariableNames: 'strength'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBAbstractConstraint commentStamp: '<historical>' prior: 0!I am an abstract class representing a system-maintainable relationship (or
"constraint") between a set of variables. I supply a strength instance
variable; concrete subclasses provide a means of storing the constrained
variables and other information required to represent a constraint.

Instance variables:
        strength                        the strength of this constraint <Strength>
!SystemOrganization addCategory: #'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!Object subclass: #CPBBenchmarkResultWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks'!CPBAbstractConstraint subclass: #CPBBinaryConstraint	instanceVariableNames: 'v1 v2 direction'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBAbstractConstraint subclass: #CPBBinaryConstraint	instanceVariableNames: 'v1 v2 direction'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBBinaryConstraint commentStamp: '<historical>' prior: 0!I am an abstract superclass for constraints having two possible output
variables.

Instance variables:
        v1, v2                possible output variables <Variable>
        direction                one of:
                                        #forward (v2 is output)
                                        #backward (        v1 is output)
                                        nil (not satisfied)!SystemOrganization addCategory: #'Cross-Plattform-Benchmarks-Blowfish'!Object subclass: #CPBBlowfish	instanceVariableNames: 'rounds piArray s0 s1 s2 s3 xl xr current key data index'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!Object subclass: #CPBBlowfish	instanceVariableNames: 'rounds piArray s0 s1 s2 s3 xl xr current key data index'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!!CPBBlowfish commentStamp: '<historical>' prior: 0!This is just enough of the Blowfish algorithm from 
http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/lib/libc/crypt/blowfish.c

to be able to run BCrypt.  


Instance Variables:
	rounds	<AbstractSound | CalendarDuration | Collection | Color | DateAndTime | DhbDecimalFloatingNumber | DhbMatrix | DhbPolynomial | Duration | InfiniteDuration | Number | PassportNotAMetanumber | Point | ScientificDuration | TemporalInterval | Timespan | TraitComposition | TraitDescription | TraitTransformation>
	piArray	<Object>
	s0	<Matrix>
	s1	<Object>
	s2	<Object>
	s3	<Object>
	s4	<ProtoObject | PseudoContext>
	xl	<Integer>
	xr	<Integer>
	current	<Integer>
	key	<ProtoObject | PseudoContext>
	data	<Object>!Object subclass: #CPBBlowfishProfiling	instanceVariableNames: 'keys clear encrypted'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!Object subclass: #CPBBlowfishProfiling	instanceVariableNames: 'keys clear encrypted'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!TestCase subclass: #CPBBlowfishTests	instanceVariableNames: 'keys clear encrypted'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!TestCase subclass: #CPBBlowfishTests	instanceVariableNames: 'keys clear encrypted'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-NBody'!Object subclass: #CPBBody	instanceVariableNames: 'x y z vx vy vz mass'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-NBody'!Object subclass: #CPBBody	instanceVariableNames: 'x y z vx vy vz mass'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-NBody'!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-Chameneos'!Object subclass: #CPBChameneos	instanceVariableNames: 'meetings color semaphore waitingForPair'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!Object subclass: #CPBChameneos	instanceVariableNames: 'meetings color semaphore waitingForPair'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBDeviceTask	instanceVariableNames: 'scheduler packet1'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBDeviceTask	instanceVariableNames: 'scheduler packet1'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!CPBBinaryConstraint subclass: #CPBEqualityConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBBinaryConstraint subclass: #CPBEqualityConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBEqualityConstraint commentStamp: '<historical>' prior: 0!I constrain two variables to have the same value: "v1 = v2".!Object subclass: #CPBHandlerTask	instanceVariableNames: 'scheduler v1 v2'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBHandlerTask	instanceVariableNames: 'scheduler v1 v2'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBIdleTask	instanceVariableNames: 'scheduler seed1 count'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBIdleTask	instanceVariableNames: 'scheduler seed1 count'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBInplaceComplex	instanceVariableNames: 'a b'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBInplaceComplex	instanceVariableNames: 'a b'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBMandelbrot	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBMandelbrot	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Matrix subclass: #CPBMandelbrotField	instanceVariableNames: 'form mode threadCount depth imageBounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Matrix subclass: #CPBMandelbrotField	instanceVariableNames: 'form mode threadCount depth imageBounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Morph subclass: #CPBMandelbrotMorph	instanceVariableNames: 'form mode threadCount depth imageBounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Morph subclass: #CPBMandelbrotMorph	instanceVariableNames: 'form mode threadCount depth imageBounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBMeetingPlace	instanceVariableNames: 'mutex first total max'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!Object subclass: #CPBMeetingPlace	instanceVariableNames: 'mutex first total max'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!Object subclass: #CPBPacket	instanceVariableNames: 'link id kind a1 a2'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!Object subclass: #CPBPacket	instanceVariableNames: 'link id kind a1 a2'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Richards'!OrderedCollection variableSubclass: #CPBPlan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!OrderedCollection variableSubclass: #CPBPlan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBPlan commentStamp: '<historical>' prior: 0!A Plan is an ordered list of constraints to be executed in sequence to
resatisfy all currently satisfiable constraints in the face of one or more
changing inputs.!Object subclass: #CPBPlanner	instanceVariableNames: 'currentMark'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBPlanner	instanceVariableNames: 'currentMark'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBPlanner commentStamp: '<historical>' prior: 0!This benchmark is an implementation of the DeltaBlue Constraint Solver
described in `The DeltaBlue Algorithm: An Incremental Constraint
Hierarchy Solver', by Bjorn N. Freeman-Benson and John Maloney,
Communications of the ACM, January 1990 (also as University of
Washington TR 89-08-06).

To run the benchmark, execute the expression `Planner standardBenchmark'.!CPBPlanner class	instanceVariableNames: 'currentPlanner'!CPBPlanner class	instanceVariableNames: 'currentPlanner'!CPBBinaryConstraint subclass: #CPBScaleConstraint	instanceVariableNames: 'scale offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBBinaryConstraint subclass: #CPBScaleConstraint	instanceVariableNames: 'scale offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBScaleConstraint commentStamp: '<historical>' prior: 0!I relate two variables by the linear scaling relationship:
"v2 = (v1 * scale) + offset". Either v1 or v2 may be changed to maintain this
relationship but the scale factor and offset are considered read-only.

Instance variables:
        scale                scale factor input variable <Variable>
        offset                offset input variable <Variable>!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-SplayTree'!Object subclass: #CPBSplaytree	instanceVariableNames: 'rootNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!Object subclass: #CPBSplaytree	instanceVariableNames: 'rootNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!Object subclass: #CPBSplaytreeNode	instanceVariableNames: 'key value left right'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!Object subclass: #CPBSplaytreeNode	instanceVariableNames: 'key value left right'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!Object subclass: #CPBStrength	instanceVariableNames: 'symbolicValue arithmeticValue'	classVariableNames: 'AbsoluteStrongest AbsoluteWeakest Required StrengthConstants StrengthTable'	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBStrength	instanceVariableNames: 'symbolicValue arithmeticValue'	classVariableNames: 'AbsoluteStrongest AbsoluteWeakest Required StrengthConstants StrengthTable'	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBStrength commentStamp: '<historical>' prior: 0!Strengths are used to measure the relative importance of constraints. The
hierarchy of available strengths is determined by the class variable
StrengthTable (see my class initialization method). Because Strengths are
invariant, references to Strength instances are shared (i.e. all references to
"Strength of: #required" point to a single, shared instance). New strengths may
be inserted in the strength hierarchy without disrupting current constraints.

Instance variables:
        symbolicValue                symbolic strength name (e.g. #required) <Symbol>
        arithmeticValue                index of the constraint in the hierarchy, used for comparisons <Number>
!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-BinaryTrees'!Object subclass: #CPBTreeNode	instanceVariableNames: 'left right item'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-BinaryTrees'!Object subclass: #CPBTreeNode	instanceVariableNames: 'left right item'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-BinaryTrees'!CPBAbstractConstraint subclass: #CPBUnaryConstraint	instanceVariableNames: 'output satisfied'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBAbstractConstraint subclass: #CPBUnaryConstraint	instanceVariableNames: 'output satisfied'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBUnaryConstraint commentStamp: '<historical>' prior: 0!I am an abstract superclass for constraints having a single possible output
variable.

Instance variables:
        output                possible output variable <Variable>
        satisfied                true if I am currently satisfied <Boolean>!CPBUnaryConstraint subclass: #CPBEditConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBUnaryConstraint subclass: #CPBEditConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBEditConstraint commentStamp: '<historical>' prior: 0!I am a unary input constraint used to mark a variable that the client
wishes to change.!CPBUnaryConstraint subclass: #CPBStayConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!CPBUnaryConstraint subclass: #CPBStayConstraint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBStayConstraint commentStamp: '<historical>' prior: 0!I mark variables that should, with some level of preference, stay the same.
I have one method with zero inputs and one output, which does nothing. Planners
may exploit the fact that, if I am satisfied, my output will not change during
plan execution. This is called "stay optimization."!Object subclass: #CPBVariable	instanceVariableNames: 'value constraints determinedBy walkStrength stay mark'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!Object subclass: #CPBVariable	instanceVariableNames: 'value constraints determinedBy walkStrength stay mark'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!!CPBVariable commentStamp: '<historical>' prior: 0!I represent a constrained variable. In addition to my value, I maintain the
structure of the constraint graph, the current dataflow graph, and various
parameters of interest to the DeltaBlue incremental constraint solver.

Instance variables:
        value                        my value; changed by constraints, read by client <Object>
        constraints                normal constraints that reference me <Array of Constraint>
        determinedBy        the constraint that currently determines
                                        my value (or nil if there isn't one) <Constraint>
        walkStrength                my walkabout strength <Strength>
        stay                        true if I am a planning-time constant <Boolean>
        mark                        used by the planner to mark constraints <Number>!Object subclass: #OSLock	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #OSLock	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!SystemOrganization addCategory: #SMark!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkHarness commentStamp: 'StefanMarr 12/30/2011 20:19' prior: 0!A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.

The simplest way to execute a benchmark suite is to use SMarkSuite >> #run.

However, directly using the harness classes gives more freedom on reporting and execution strategies.

A typical call of the harness from the commandline would result in the following invokation:
	SMarkHarness run: {'SMarkHarness'. 'SMarkLoops.benchIntLoop'. 1. 1. 5}!SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarness subclass: #ReBenchHarness	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 0!The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkHarnessArgumentParser	instanceVariableNames: 'runner reporter suiteOrBenchmark iterations processes problemSize i current numParams currentObj arguments suite specificBenchmark suiteClass harness'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkHarnessArgumentParser subclass: #ReBenchHarnessArgumentParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkReporter	instanceVariableNames: 'runner stream'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 0!PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkResult	instanceVariableNames: 'time benchName suite criteria'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 0!A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkRunner	instanceVariableNames: 'numIterations suite runner results currentBenchmark timers problemSize numProcesses'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkAutosizeRunner	instanceVariableNames: 'targetTime innerLoopIterations'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkCogRunner	instanceVariableNames: 'warmingUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkCogRunner commentStamp: 'StefanMarr 12/30/2011 23:24' prior: 0!This runner is doing warmup on for Cog VMs with just-in-time compilation.
The goal is to bring the JIT compiler into a steady state where no jitting is performed anymore during benchmarking.!SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkProfileRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkProfileRunner commentStamp: '<historical>' prior: 0!This runner profiles the benchmarks for better analysis. Unlike the classical benchmark runner this one will not collect the results. Instead it will execute the benchmarks in the system profiler.!SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkReporter subclass: #SMarkSimpleStatisticsReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkSimpleStatisticsReporter subclass: #ReBenchReporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkSuite	instanceVariableNames: 'runner selectedBenchmarks'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkSuite commentStamp: 'StefanMarr 12/4/2011 11:56' prior: 0!A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.

Usage:

 Choose a suite and use the class-side #run.
 Print the result of the following expression:
   SMarkCompiler run: 10!SMarkSuite subclass: #CPBAStarBenchmark	instanceVariableNames: 'graph1 graph2 astar'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!SMarkSuite subclass: #CPBAStarBenchmark	instanceVariableNames: 'graph1 graph2 astar'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-AStar'!SMarkSuite subclass: #CPBBinaryTreeBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-BinaryTrees'!SMarkSuite subclass: #CPBBinaryTreeBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-BinaryTrees'!SMarkSuite subclass: #CPBBlowfishSuite	instanceVariableNames: 'blowfish'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!SMarkSuite subclass: #CPBBlowfishSuite	instanceVariableNames: 'blowfish'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Plattform-Benchmarks-Blowfish'!SMarkSuite subclass: #CPBChameneosBenchmark	instanceVariableNames: 'c1 c2 c3 c4 mp nMeetings'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!SMarkSuite subclass: #CPBChameneosBenchmark	instanceVariableNames: 'c1 c2 c3 c4 mp nMeetings'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Chameneos'!SMarkSuite subclass: #CPBDeltaBlueBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!SMarkSuite subclass: #CPBDeltaBlueBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-DeltaBlue'!SMarkSuite subclass: #CPBMandelbrotBenchmarkSuite	instanceVariableNames: 'mandelbrotMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!SMarkSuite subclass: #CPBMandelbrotBenchmarkSuite	instanceVariableNames: 'mandelbrotMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!SMarkSuite subclass: #CPBNBodyBenchmark	instanceVariableNames: 'bodies'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-NBody'!SMarkSuite subclass: #CPBNBodyBenchmark	instanceVariableNames: 'bodies'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-NBody'!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-ParallelSum'!SMarkSuite subclass: #CPBParallelSumBenchmarkSuite	instanceVariableNames: 'mandelbrotMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-ParallelSum'!SMarkSuite subclass: #CPBParallelSumBenchmarkSuite	instanceVariableNames: 'mandelbrotMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-ParallelSum'!SystemOrganization addCategory: #'Cross-Platform-Benchmarks-Polymorphy'!SMarkSuite subclass: #CPBPolymorphyBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Polymorphy'!SMarkSuite subclass: #CPBPolymorphyBenchmark	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Polymorphy'!SMarkSuite subclass: #CPBSplayTreeBenchmark	instanceVariableNames: 'splayTree kSplayTreeSize kSplayTreeModifications kSplayTreePayloadDepth keyCounter'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!SMarkSuite subclass: #CPBSplayTreeBenchmark	instanceVariableNames: 'splayTree kSplayTreeSize kSplayTreeModifications kSplayTreePayloadDepth keyCounter'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-SplayTree'!Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTimer	instanceVariableNames: 'startTime elapsedTime name'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkTransporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!!SMarkTransporter commentStamp: 'StefanMarr 4/5/2012 21:43' prior: 0!SMarkTransporter is a used to interact with a git-fileout system used in the RoarVM project to manage Smalltalk source code.

SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!SMarkRunner subclass: #SMarkWeakScalingRunner	instanceVariableNames: 'numInnerIterations runningProcesses completionSignal runningProcessesMtx'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SMarkWeakScalingRunnerExecutor	instanceVariableNames: 'numInnerIterations benchmarkSelector suite runner'	classVariableNames: ''	poolDictionaries: ''	category: 'SMark'!Object subclass: #SPyRunner	instanceVariableNames: ''	classVariableNames: 'KernelTests'	poolDictionaries: ''	category: 'SPy-Benchmarks'!Object subclass: #SPyRunner	instanceVariableNames: ''	classVariableNames: 'KernelTests'	poolDictionaries: ''	category: 'SPy-Benchmarks'!Object subclass: #STMAtomic	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Object subclass: #STMAtomic	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Process subclass: #STMProcess	instanceVariableNames: 'lock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!Process subclass: #STMProcess	instanceVariableNames: 'lock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-STM'!!BlockClosure methodsFor: 'STM' stamp: 'toma 1/16/2014 23:38' prior: 33570898!async	^STMFuture invoke: self! !!BlockClosure methodsFor: 'STM' stamp: 'toma 1/16/2014 22:37' prior: 33568214!atomic		^STMAtomic from: self! !!BlockClosure methodsFor: 'STM' stamp: '' prior: 33568533!newSTMProcess	^ STMProcess forContext: [self value] asContext priority: Processor activePriority! !!BlockClosure methodsFor: 'STM' stamp: 'pre 6/22/2014 19:24' prior: 33568777!parallelFork		^ (self newSTMProcess) fork; yourself! !!CPBAStar methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 11:30'!initialize	openList := OrderedCollection new .	closedList := Set new .	graph := nil .! !!CPBAStar methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 15:05'!reset	self openList removeAll .	self closedList removeAll .! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!closedList	"Answer the value of closedList"	^ closedList! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!closedList: anObject	"Set the value of closedList"	closedList := anObject! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!graph	"Answer the value of graph"	^ graph! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!graph: anObject	"Set the value of graph"	graph := anObject! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!openList	"Answer the value of openList"	^ openList! !!CPBAStar methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:24'!openList: anObject	"Set the value of openList"	openList := anObject! !!CPBAStar methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 14:50'!draw	| form node |	form := Form extent: self graph nodes last x @ self graph nodes last y.	form floodFill: Color black at: 1@1.	node := self graph target.	[ node ] whileNotNil: [		form colorAt: (node x @ node) y put: Color white.		node := node predecessor.	].	^form.! !!CPBAStar methodsFor: 'as yet unclassified' stamp: 'MP 2/7/2014 11:59'!expandNode: node	(node neighbours) do: [:neighbour|		(self closedList includes: neighbour)			ifFalse: [				| costs |				costs := (node costsFromStart) + (node costsToNode: neighbour) .				((self openList includes: neighbour) and: (costs >= neighbour costsFromStart))					ifFalse: [						neighbour predecessor: node .						neighbour costsFromStart: costs.						(self openList includes: neighbour) ifFalse: [							self openList add: neighbour.]]]].! !!CPBAStar methodsFor: 'as yet unclassified' stamp: 'MP 2/7/2014 11:35'!findPath	| foundPath break |	foundPath := nil .	break := false .	self openList add: graph start .	[(break == false) and: ((self openList isEmpty) not)]		whileTrue: [			| currentNode |			currentNode := self nearestNode .			self openList remove: currentNode .			(currentNode == self graph target)				ifTrue: [					break:=true.					foundPath:=currentNode.]				ifFalse: [					self closedList add: currentNode .					self expandNode: currentNode .				].				] .		^ foundPath.! !!CPBAStar methodsFor: 'as yet unclassified' stamp: 'MP 2/7/2014 11:20'!nearestNode	"gets the node with the minimal costs to the target"	| min |	min := self openList first.	self openList		do: [:node | (node estimatedCostsToTarget: self graph target)					< (min estimatedCostsToTarget: self graph target)				ifTrue: [min := node]].	^ min! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'BS 2/7/2014 14:03'!nodeAt: aPoint	| index |	index := (aPoint y - 1) * width + aPoint x.	^self nodes at: index. ! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!nodes	"Answer the value of nodes"	^ nodes! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!nodes: anObject	"Set the value of nodes"	nodes := anObject! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!start	"Answer the value of start"	^ start! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!start: anObject	"Set the value of start"	start := anObject! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!target	"Answer the value of target"	^ target! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:36'!target: anObject	"Set the value of target"	target := anObject! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'BS 2/7/2014 13:30'!width	"Answer the value of width"	^ width! !!CPBAStarGraph methodsFor: 'accessing' stamp: 'BS 2/7/2014 13:30'!width: anObject	"Set the value of width"	width := anObject! !!CPBAStarGraph methodsFor: 'initialize-release' stamp: 'BS 2/7/2014 13:29'!initialize	nodes := OrderedCollection new.	width := 0.	start := nil .	target := nil .! !!CPBAStarGraph class methodsFor: 'instance creation' stamp: 'BS 2/7/2014 14:02'!fromString: aString	| tokens maze |	tokens := (aString findTokens: Character cr) collect: [:line| (line findTokens: ',') collect: [:t| t asInteger]].		maze := self new.	maze width: tokens first size.		tokens withIndexDo: [:line :y| line withIndexDo: [:token :x| | node |			node := (CPBAStarNode x: x y: y).			maze nodes add: node.			token == 1 ifTrue:[				((y > 1) and: [((tokens at: y-1) at: x) == 1]) ifTrue: [|other|					other := maze nodeAt: (x @ (y-1)).					other neighbours add: node.					node neighbours add: other.				].				((x > 1) and: [((tokens at: y) at: x-1) == 1]) ifTrue: [|other|					other := maze nodeAt: ((x-1) @ y).					other neighbours add: node.					node neighbours add: other.				].			]		]	].		^maze.	! !!CPBAStarGraph class methodsFor: 'instance creation' stamp: 'BS 2/7/2014 14:31'!testGraph	| maze |	maze := self fromString:'1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,1,1,1,2,1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,2,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,1,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,1,1,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,2,2,1,2,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,1,1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,2,2,1,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,2,1,2,2,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,1,1,1,2,2,1,2,2,2,1,2,1,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,2,2,1,1,1,2,2,1,2,2,2,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,2,1,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,2,2,1,1,1,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,1,1,1,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,'.	maze start: maze nodes first.	maze target: maze nodes last.		^maze.! !!CPBAStarGraph class methodsFor: 'instance creation' stamp: 'BS 2/7/2014 14:32'!testGraph2	| maze |	maze := self fromString:'1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,2,2,1,2,1,2,1,2,2,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,1,2,1,1,1,2,2,1,1,1,2,2,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,1,2,2,1,1,1,2,1,1,1,1,2,2,1,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,2,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,1,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,2,1,1,2,1,1,1,1,2,2,1,1,1,1,1,2,1,2,1,2,1,2,2,2,1,2,1,2,1,2,2,2,1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,1,1,2,1,1,1,2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,2,2,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,2,1,1,1,1,2,2,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,2,1,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,1,2,1,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,2,1,1,2,1,2,2,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,2,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,1,2,1,1,2,1,1,2,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,1,2,1,1,1,2,2,1,1,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,1,2,1,1,1,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,1,2,2,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,2,1,2,1,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,2,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,2,1,2,1,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,1,2,2,1,1,1,1,1,2,2,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,2,1,2,1,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,2,2,1,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,2,2,1,1,1,1,2,2,2,1,1,2,1,1,2,1,2,2,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,1,2,2,1,1,1,2,2,2,1,1,1,1,1,2,2,1,1,1,1,2,1,1,1,1,2,2,1,1,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,2,2,1,1,1,1,2,1,1,2,1,1,2,1,1,2,2,1,2,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,2,2,1,1,1,2,1,1,2,1,1,2,1,1,1,2,1,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,2,1,1,1,2,1,1,2,1,1,2,1,1,1,2,2,1,1,2,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,2,2,2,1,1,1,1,2,2,1,1,1,1,2,2,1,2,2,1,1,2,2,1,2,2,1,2,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,1,2,2,2,1,1,1,2,2,1,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1,2,2,2,2,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,2,2,1,1,1,2,2,1,2,2,1,1,2,1,1,2,1,1,1,1,1,1,1,2,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,2,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,2,1,1,1,1,1,2,2,1,1,1,2,1,1,1,2,1,1,2,1,1,2,2,1,2,2,2,2,2,2,2,2,1,1,2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,2,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,1,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,1,1,1,2,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,1,2,2,1,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,2,2,1,1,2,2,2,1,2,2,2,2,2,2,2,2,1,1,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,1,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,1,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,1,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,1,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,1,2,2,2,2,1,2,2,2,1,1,1,2,2,2,2,1,1,2,2,2,1,2,2,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,1,1,2,2,1,1,2,2,2,2,1,1,1,2,2,1,1,2,2,2,2,1,2,2,2,2,2,1,1,2,1,1,2,2,2,1,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,1,1,2,1,1,1,1,2,2,2,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1,2,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,'.	maze start: maze nodes first.	maze target: maze nodes last.		^maze.! !!CPBAStarNode methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 12:52'!initialize	neighbours := Set new .	x := 0 .	y := 0 .	costsFromStart := 0 .	predecessor := nil .	distanceMetric := #manhattan .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:19'!addNeighbour: neighbour	self neighbours add: neighbour .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:05'!costsFromStart	"Answer the value of costsFromStart"	^ costsFromStart! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:05'!costsFromStart: anObject	"Set the value of costsFromStart"	costsFromStart := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:58'!costsToNode: node	(self distanceMetric = #euclidian)		ifTrue: [			^ self euclideanDistanceTo: node . ]		ifFalse: [			(self distanceMetric = #manhattan)				ifTrue: [					^ self manhattanDistanceTo: node .]				ifFalse: [					^ 1 .				]		].! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:52'!distanceMetric	"Answer the value of distanceMetric"	^ distanceMetric! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:52'!distanceMetric: anObject	"Set the value of distanceMetric"	distanceMetric := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:18'!estimatedCostsToTarget: target	^ self costsFromStart + (self costsToNode: target) .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:55'!euclideanDistanceTo: node	| dX dY |	dX := node x - self x .	dY := node y - self y .	^ (dX*dX) + (dY*dY) .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 12:54'!manhattanDistanceTo: node	^ ((node x - self x) abs) + ((node y - self y) abs) .! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:05'!neighbours	"Answer the value of neighbours"	^ neighbours! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:05'!neighbours: anObject	"Set the value of neighbours"	neighbours := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:20'!predecessor	"Answer the value of predecessor"	^ predecessor! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 11:20'!predecessor: anObject	"Set the value of predecessor"	predecessor := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:10'!x	"Answer the value of x"	^ x! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:10'!x: anObject	"Set the value of x"	x := anObject! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:10'!y	"Answer the value of y"	^ y! !!CPBAStarNode methodsFor: 'accessing' stamp: 'MP 2/7/2014 10:10'!y: anObject	"Set the value of y"	y := anObject! !!CPBAStarNode class methodsFor: 'instance creation' stamp: 'MP 2/7/2014 10:12'!x: x y: y	| instance |	instance := self new .	instance		x: x;		y: y .	^ instance .! !!CPBAbstractConstraint methodsFor: 'accessing'!strength
        "Answer my strength."

        ^strength! !!CPBAbstractConstraint methodsFor: 'accessing' stamp: 'HW 1/25/2014 17:23'!strength: strengthSymbol
        "Set my strength."

        strength := CPBStrength of: strengthSymbol.! !!CPBAbstractConstraint methodsFor: 'queries'!isInput
        "Normal constraints are not input constraints. An input constraint is
         one that depends on external state, such as the mouse, the keyboard,
         a clock, or some arbitrary piece of imperative code."

        ^false! !!CPBAbstractConstraint methodsFor: 'queries'!isSatisfied
        "Answer true if this constraint is satisfied in the current solution."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'add/remove' stamp: 'HW 1/25/2014 17:22'!addConstraint
        "Activate this constraint and attempt to satisfy it."

        self addToGraph.
        CPBPlanner current incrementalAdd: self.! !!CPBAbstractConstraint methodsFor: 'add/remove'!addToGraph
        "Add myself to the constraint graph."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'add/remove' stamp: 'HW 1/25/2014 17:22'!destroyConstraint
        "Deactivate this constraint, remove it from the constraint graph,
         possibly causing other constraints to be satisfied, and destroy it."

        (self isSatisfied) ifTrue: [CPBPlanner current incrementalRemove: self].
        self removeFromGraph.
        self release.! !!CPBAbstractConstraint methodsFor: 'add/remove'!removeFromGraph
        "Remove myself from the constraint graph."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!chooseMethod: mark
        "Decide if I can be satisfied and record that decision. The output of
         the choosen method must not have the given mark and must have a
         walkabout strength less than that of this constraint."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!execute
        "Enforce this constraint. Assume that it is satisfied."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!inputsDo: aBlock
        "Assume that I am satisfied. Evaluate the given block on all my current
         input variables."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!inputsKnown: mark
        "Assume that I am satisfied. Answer true if all my current inputs are
         known. A variable is known if either a) it is 'stay' (i.e. it is a
         constant at plan execution time), b) it has the given mark (indicating
         that it has been computed by a constraint appearing earlier in the
         plan), or c) it is not determined by any constraint."

        self inputsDo:
                [: v |
                 ((v mark = mark) or: [(v stay) or: [v determinedBy == nil]]) ifFalse:
                        [^false]].
        ^true! !!CPBAbstractConstraint methodsFor: 'planning'!markUnsatisfied
        "Record the fact that I am unsatisfied."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!output
        "Answer my current output variable. Raise an error if I am not
         currently satisfied."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning'!recalculate
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
         the value for the current output of this constraint. Assume this
         constraint is satisfied."

        self subclassResponsibility! !!CPBAbstractConstraint methodsFor: 'planning' stamp: 'HW 1/25/2014 17:23'!satisfy: mark
        "Attempt to find a way to enforce this (still unsatisfied) constraint.
         If successful, record the solution, perhaps modifying the current
         dataflow graph. Answer the constraint that this constraint overrides,
         if there is one, or nil, if there isn't."

        | overridden out |
        self chooseMethod: mark.
        (self isSatisfied)
                ifTrue:                        "constraint can be satisfied"
                        ["mark inputs to allow cycle detection in addPropagate"
                         self inputsDo: [: in | in mark: mark].
                         out := self output.
                         overridden := out determinedBy.
                         (overridden == nil) ifFalse: [overridden markUnsatisfied].
                         out determinedBy: self.
                         (CPBPlanner current addPropagate: self mark: mark) ifFalse:
                                [self notify:
                                        ('Cycle encountered adding:\ ',
                                         self printString,
                                         '\Constraint removed.') withCRs.
                                 ^nil].
                         out mark: mark]
                ifFalse:                        "constraint cannot be satisfied"
                        [overridden := nil.
                         (strength sameAs: (CPBStrength required)) ifTrue:
                                [self notify: 'Failed to satisfy a required constraint']].
        ^overridden! !!CPBAbstractConstraint methodsFor: 'printing'!longPrintOn: aStream

        | bindings |
        aStream nextPut: $(.
        self shortPrintOn: aStream.
        aStream space; nextPutAll: self strength printString.
        (self isSatisfied)
                ifTrue:
                        [aStream cr; space; space; space.
                         self inputsDo:
                                [: in | aStream nextPutAll: 'v', in asOop printString, ' '].
                        aStream nextPutAll: '-> '.
                        aStream nextPutAll: 'v', self output asOop printString]
                ifFalse:
                        [aStream space; nextPutAll: 'UNSATISFIED'].
        aStream nextPut: $); cr.! !!CPBAbstractConstraint methodsFor: 'printing'!printOn: aStream

        self shortPrintOn: aStream! !!CPBAbstractConstraint methodsFor: 'printing'!shortPrintOn: aStream

        aStream nextPutAll: self class name, '(', self asOop printString, ')'.! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'MP 1/16/2014 16:34'!standardDeviation: results withAverage: average
	| variance |
	variance := 0.0 .
	results do: [:item|
		variance:=variance+(((item total)-average) squared) ].
	
	variance:=variance / results size .
	
	^ (variance sqrt)! !!CPBBenchmarkResultWriter methodsFor: 'output' stamp: 'hh 6/12/2014 20:50'!writeResult: result inFile: fileName
	| reportFile |
	reportFile := FileStream forceNewFileNamed: fileName .	"""reportFile := FileStream stdout."""
	reportFile
		nextPutAll: 'BenchmarkName;Avg;Min;Max;Stdev';
		nextPutAll: (String crlf).	
	result keysAndValuesDo: [:benchmark :smarkResults | | avg min max stdev |
		min := (smarkResults at: 1) total .
		max := (smarkResults at: 1) total .
		avg := 0.
		smarkResults do: [:smarkResult |
			min := (smarkResult total) min: min .
			max := (smarkResult total) max: max .
			avg := avg + (smarkResult total) .			 ] .		avg := avg asFloat.
		avg:= avg / (smarkResults size) .
		stdev:= self standardDeviation: smarkResults withAverage: avg .
		reportFile
			nextPutAll: benchmark;
			nextPutAll: ';';
			nextPutAll: (avg asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (min asFloat asString);
			nextPutAll: ';';			
			nextPutAll: (max asFloat asString);
			nextPutAll: ';';
			nextPutAll: (stdev asFloat asString);
			nextPutAll: (String crlf) .
	].! !!CPBBinaryConstraint methodsFor: 'initialize-release' stamp: 'HW 1/25/2014 17:23'!var: variable1 var: variable2 strength: strengthSymbol
        "Initialize myself with the given variables and strength."

        strength := CPBStrength of: strengthSymbol.
        v1 := variable1.
        v2 := variable2.
        direction := nil.
        self addConstraint.! !!CPBBinaryConstraint methodsFor: 'queries'!isSatisfied
        "Answer true if this constraint is satisfied in the current solution."

        ^direction notNil! !!CPBBinaryConstraint methodsFor: 'add/remove'!addToGraph
        "Add myself to the constraint graph."

        v1 addConstraint: self.
        v2 addConstraint: self.
        direction := nil.! !!CPBBinaryConstraint methodsFor: 'add/remove'!removeFromGraph
        "Remove myself from the constraint graph."

        (v1 == nil) ifFalse: [v1 removeConstraint: self].
        (v2 == nil) ifFalse: [v2 removeConstraint: self].
        direction := nil.! !!CPBBinaryConstraint methodsFor: 'planning'!chooseMethod: mark
        "Decide if I can be satisfied and which way I should flow based on
         the relative strength of the variables I relate, and record that
         decision."

        (v1 mark == mark) ifTrue:                "forward or nothing"
                [((v2 mark ~= mark) and: [strength stronger: v2 walkStrength])
                        ifTrue: [^direction := #forward]
                        ifFalse: [^direction := nil]].

        (v2 mark == mark) ifTrue:                "backward or nothing"
                [((v1 mark ~= mark) and: [strength stronger: v1 walkStrength])
                        ifTrue: [^direction := #backward]
                        ifFalse: [^direction := nil]].

        "if we get here, neither variable is marked, so we have choice"
        (v1 walkStrength weaker: v2 walkStrength)
                ifTrue:
                        [(strength stronger: v1 walkStrength)
                                ifTrue: [^direction := #backward]
                                ifFalse: [^direction := nil]]
                ifFalse:
                        [(strength stronger: v2 walkStrength)
                                ifTrue: [^direction := #forward]
                                ifFalse: [^direction := nil]].! !!CPBBinaryConstraint methodsFor: 'planning'!execute
        "Enforce this constraint. Assume that it is satisfied."

        self subclassResponsibility! !!CPBBinaryConstraint methodsFor: 'planning'!inputsDo: aBlock
        "Evaluate the given block on my current input variable."

        (direction == #forward)
                ifTrue: [aBlock value: v1]
                ifFalse: [aBlock value: v2].! !!CPBBinaryConstraint methodsFor: 'planning'!markUnsatisfied
        "Record the fact that I am unsatisfied."

        direction := nil.! !!CPBBinaryConstraint methodsFor: 'planning'!output
        "Answer my current output variable."

        (direction == #forward)
                ifTrue: [^v2]
                ifFalse: [^v1]! !!CPBBinaryConstraint methodsFor: 'planning'!recalculate
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
the value for the current output of this constraint. Assume this
         constraint is satisfied."

        | in out |
        (direction == #forward)
                ifTrue: [in := v1. out := v2]
                ifFalse: [in := v2. out := v1].
        out walkStrength: (strength weakest: in walkStrength).
        out stay: (in stay).
        (out stay) ifTrue: [self execute].                "stay optimization"! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:53'!blfDec: dataArray for: blocks
	| j newDataArray |
	newDataArray := Array new: dataArray size.
	j := 1.
	(1 to: blocks)
		do: [ :each | 
			xl := dataArray at: j.
			xr := dataArray at: j + 1.
			self decipher.
			newDataArray at: j put: xl.
			newDataArray at: j + 1 put: xr.
			j := j + 2 ].
	^ newDataArray! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 18:48'!blfEcbDecrypt: dataArray for: times

 |  newDataArray |
newDataArray:=dataArray copy.

	(1 to: times by: 8) do:[ :each | 
		
		xl:=((((newDataArray at: 1) bitShift: 24) bitOr: ((newDataArray at: 2) bitShift: 16) )bitOr: ((newDataArray at: 3) bitShift: 8)) bitOr: (newDataArray at: 4).  
		xr:=((((newDataArray at: 5) bitShift: 24) bitOr: ((newDataArray at: 6) bitShift: 16) )bitOr: ((newDataArray at: 7) bitShift: 8)) bitOr: (newDataArray at: 8).
		
		self decipher .
		
		newDataArray at: 1 put: ((xl  bitShift: -24) bitAnd: 16rFF).		
		newDataArray at: 2 put: ((xl  bitShift: -16) bitAnd: 16rFF).	
		newDataArray at: 3 put: ((xl  bitShift: -8) bitAnd: 16rFF).	
		newDataArray at: 4 put: (xl bitAnd: 16rFF).
		newDataArray at: 5 put: ((xr  bitShift: -24) bitAnd: 16rFF).	
		newDataArray at: 6 put: ((xr  bitShift: -16) bitAnd: 16rFF).
		newDataArray at: 7 put: ((xr  bitShift: -8) bitAnd: 16rFF).	
		newDataArray at: 8 put: (xr bitAnd: 16rFF).	
		]	.
		
	^newDataArray ! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 18:50'!blfEcbEncrypt: dataArray for: times

 |  newDataArray |
newDataArray:=dataArray copy.

	(1 to: times by: 8) do:[ :each | 
		
		xl:=((((newDataArray at: 1) bitShift: 24) bitOr: ((newDataArray at: 2) bitShift: 16) )bitOr: ((newDataArray at: 3) bitShift: 8)) bitOr: (newDataArray at: 4).  
		xr:=((((newDataArray at: 5) bitShift: 24) bitOr: ((newDataArray at: 6) bitShift: 16) )bitOr: ((newDataArray at: 7) bitShift: 8)) bitOr: (newDataArray at: 8).
		
		self encipher .
		
		newDataArray at: 1 put: ((xl  bitShift: -24) bitAnd: 16rFF).		
		newDataArray at: 2 put: ((xl  bitShift: -16) bitAnd: 16rFF).	
		newDataArray at: 3 put: ((xl  bitShift: -8) bitAnd: 16rFF).	
		newDataArray at: 4 put: (xl bitAnd: 16rFF).
		newDataArray at: 5 put: ((xr  bitShift: -24) bitAnd: 16rFF).	
		newDataArray at: 6 put: ((xr  bitShift: -16) bitAnd: 16rFF).
		newDataArray at: 7 put: ((xr  bitShift: -8) bitAnd: 16rFF).	
		newDataArray at: 8 put: (xr bitAnd: 16rFF).	
		]	.
		
	^newDataArray ! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:53'!blfEnc: dataArray for: blocks
	| j newDataArray |
	newDataArray := dataArray copy.
	j := 1.
	(1 to: blocks)
		do: [ :each | 
			xl := newDataArray at: j.
			xr := newDataArray at: j + 1.
			self encipher.
			newDataArray at: j put: xl.
			newDataArray at: j + 1 put: xr.
			j := j + 2 ].
	^ newDataArray! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:53'!blfKey: aKey
	index:=0.
	key:= aKey.
	"self initializeLittleEndianBoxes."
	self initializeBoxes.
	self expandZeroState.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!calculateBlfRndFor:oneHalf with: otherHalf andPiAt: n
"#define BLFRND(s,p,i,j,n) (i ^= F(s,j) ^ (p)[n])"

	
^ oneHalf bitXor: ((self feistelWith: otherHalf  ) bitXor: (piArray at: n)) .
! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!decipher
	| xL xR temp |
	xL := xl copy.
	xR := xr copy.
	xL := xL bitXor: (piArray at: 18).
	(17 to: 2 by: -2)
		do: [ :each | 
			xR := self calculateBlfRndFor: xR with: xL andPiAt: each.
			xL := self calculateBlfRndFor: xL with: xR andPiAt: each - 1 ].
	xl := xR bitXor: (piArray at: 1).
	xr := xL! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!decrypt: someData with:   aKeyString

	
	self setRounds: self class defaultRounds .

	self blfKey: aKeyString.
	^self blfDec: someData for: someData size // 2.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!ecbDecrypt: someData with:   aKeyString


	self setRounds: self class defaultRounds .

	self blfKey: aKeyString.
	^self blfEcbDecrypt: someData for: someData size // 2.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:54'!ecbEncrypt: someData with:   aKeyString


	self setRounds: self class defaultRounds .

	self blfKey: aKeyString.
	^self blfEcbEncrypt: someData for: someData size // 2.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:55'!encipher
	| xL xR temp |
	xL := xl copy.
	xR := xr copy.
	xL := xL bitXor: (piArray at: 1).
"	index <= 2
		ifTrue: [ 
			Transcript
				cr;
				show: 'New encipher';
				cr;
				show: 'Left: ';
				show: xL hex greaseString ]."
	(2 to: 17 by: 2)
		do: [ :each | 
			xR := self calculateBlfRndFor: xR with: xL andPiAt: each.
			xL := self calculateBlfRndFor: xL with: xR andPiAt: each + 1.
"			index = 2
				ifTrue: [ 
					Transcript
						cr;
						show: 'Right: ';
						show: xR hex greaseString;
						cr;
						show: 'Left: ';
						show: xL hex greaseString.
					index = 0 ] ]."].
	xR := xR bitXor: (piArray at: 18).
	xl := xR.
	xr := xL! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:55'!encrypt: someData with:   aKeyString


	self setRounds: self class defaultRounds .

	self blfKey: aKeyString.
	
	^self blfEnc: someData  for: someData size // 2.! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:55'!expandZeroState
	| dataL dataR s0Test s1Test s2Test s3Test  pTest|
	current := 1.
pTest:=piArray copy.
	(1 to: rounds + 2)
		do: [ :each | piArray at: each put: ((piArray at: each) bitXor: (self stream2word: key)) ].

"xl := 16r0.
xr := 16r0."
xl:=#[0 0 0 0] unsignedLongAt: 1 bigEndian:   true.
xr:=#[0 0 0 0] unsignedLongAt: 1 bigEndian:   true.
pTest:=piArray copy.
		(1 to: rounds + 2 by: 2)
		do: [ :each | 		
			self encipher.
					piArray at: each put: xl copy.
					piArray at: each+1 put: xr copy.].

s0Test :=s0 copy.
s1Test :=s1 copy.
s2Test :=s2 copy.
s3Test :=s3 copy.



		(1 to:256 by:2)
		do: [ :each | self encipher.
					s0 at: each put: xl copy.
					s0 at: each+1 put: xr copy.
					].

		(1 to:256 by:2)
		do: [ :each | self encipher.
					s1 at: each put: xl copy.
					s1 at: each+1 put: xr copy.].

		(1 to:256 by:2)
		do: [ :each | self encipher.
					s2 at: each put: xl copy.
					s2 at: each+1 put: xr copy.].

		(1 to:256 by:2)
		do: [ :each | self encipher.
					s3 at: each put: xl copy.
					s3 at: each+1 put: xr copy.].
			
"	s0Test:= s0 select:[:each | each asByteArray size >4].
	s1Test:= s1 select:[:each | each asByteArray size >4].
	s2Test:= s2 select:[:each | each asByteArray size >4].
	s3Test:= s3 select:[:each | each asByteArray size >4].
	(s0Test size + s1Test size + s2Test size + s3Test size) >0 ifTrue:[self halt]."! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 18:47'!feistelWith: otherHalf
	| a b c d y byteArray |
	a := ((otherHalf bitShift: -24) bitAnd: 16rFF) + 1.
	b := ((otherHalf bitShift: -16) bitAnd: 16rFF) + 1.
	c := ((otherHalf bitShift: -8) bitAnd: 16rFF) + 1.
	d := (otherHalf bitAnd: 16rFF) + 1.
	y := ((s0 at: a) + (s1 at: b)) \\ 4294967296.	" (2 raisedTo: 32)"
	y := y bitXor: (s2 at: c).
	y := (y + (s3 at: d)) \\ 4294967296.	"(2 raisedTo: 32)"
	^ y! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:56'!initializeBoxes
	piArray :=self class pBox copy.
	s0:=self class s0Box copy.
	s1:=self class s1Box copy.
	s2:=self class s2Box copy.
	s3:=self class s3Box copy.

	
	! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:56'!setRounds: anInteger

	rounds:=(anInteger >= self class minRounds and:[anInteger <= self class maxRounds]) ifTrue: [anInteger] ifFalse:[self class defaultRounds ]   ! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:56'!stream2word: someData 


|temp j dataBytes |
temp:=0.

dataBytes := someData size.

1 to: 4 do:  [ :each | 
		temp:=(temp bitShift: 8 ) bitOr: ((someData at: current) bitAnd: 16rFF).

	current := (current \\ dataBytes) +1.

	   ].


^temp.
! !!CPBBlowfish methodsFor: 'as yet unclassified' stamp: 'gsa 4/30/2012 19:56'!stream2word: someData length: someBytes


|temp j  |
temp:=0.



1 to: 4 do:  [ :each | 
		temp:=(temp bitShift: 8 ) bitOr: ((someData atWrap: current) bitAnd: 16rFF).

	current := (current \\ someBytes) +1.

	   ].


^temp.
! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!blockSize
	^8! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!defaultRounds
^self minRounds! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!maxRounds
^20
! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!maxUserKeyLength
	^448/8! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!minRounds
^16! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:51'!pBox
	^#(		16r243F6A88 16r85A308D3 16r13198A2E 16r03707344 16rA4093822 16r299F31D0
			16r082EFA98 16rEC4E6C89 16r452821E6 16r38D01377 16rBE5466CF 16r34E90C6C
			16rC0AC29B7 16rC97C50DD 16r3F84D5B5 16rB5470917 16r9216D5D9 16r8979FB1B)! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:52'!s0Box
	^#(16rD1310BA6 16r98DFB5AC 16r2FFD72DB 16rD01ADFB7
			16rB8E1AFED 16r6A267E96 16rBA7C9045 16rF12C7F99
			16r24A19947 16rB3916CF7 16r0801F2E2 16r858EFC16
			16r636920D8 16r71574E69 16rA458FEA3 16rF4933D7E
			16r0D95748F 16r728EB658 16r718BCD58 16r82154AEE
			16r7B54A41D 16rC25A59B5 16r9C30D539 16r2AF26013
			16rC5D1B023 16r286085F0 16rCA417918 16rB8DB38EF
			16r8E79DCB0 16r603A180E 16r6C9E0E8B 16rB01E8A3E
			16rD71577C1 16rBD314B27 16r78AF2FDA 16r55605C60
			16rE65525F3 16rAA55AB94 16r57489862 16r63E81440
			16r55CA396A 16r2AAB10B6 16rB4CC5C34 16r1141E8CE
			16rA15486AF 16r7C72E993 16rB3EE1411 16r636FBC2A
			16r2BA9C55D 16r741831F6 16rCE5C3E16 16r9B87931E
			16rAFD6BA33 16r6C24CF5C 16r7A325381 16r28958677
			16r3B8F4898 16r6B4BB9AF 16rC4BFE81B 16r66282193
			16r61D809CC 16rFB21A991 16r487CAC60 16r5DEC8032
			16rEF845D5D 16rE98575B1 16rDC262302 16rEB651B88
			16r23893E81 16rD396ACC5 16r0F6D6FF3 16r83F44239
			16r2E0B4482 16rA4842004 16r69C8F04A 16r9E1F9B5E
			16r21C66842 16rF6E96C9A 16r670C9C61 16rABD388F0
			16r6A51A0D2 16rD8542F68 16r960FA728 16rAB5133A3
			16r6EEF0B6C 16r137A3BE4 16rBA3BF050 16r7EFB2A98
			16rA1F1651D 16r39AF0176 16r66CA593E 16r82430E88
			16r8CEE8619 16r456F9FB4 16r7D84A5C3 16r3B8B5EBE
			16rE06F75D8 16r85C12073 16r401A449F 16r56C16AA6
			16r4ED3AA62 16r363F7706 16r1BFEDF72 16r429B023D
			16r37D0D724 16rD00A1248 16rDB0FEAD3 16r49F1C09B
			16r075372C9 16r80991B7B 16r25D479D8 16rF6E8DEF7
			16rE3FE501A 16rB6794C3B 16r976CE0BD 16r04C006BA
			16rC1A94FB6 16r409F60C4 16r5E5C9EC2 16r196A2463
			16r68FB6FAF 16r3E6C53B5 16r1339B2EB 16r3B52EC6F
			16r6DFC511F 16r9B30952C 16rCC814544 16rAF5EBD09
			16rBEE3D004 16rDE334AFD 16r660F2807 16r192E4BB3
			16rC0CBA857 16r45C8740F 16rD20B5F39 16rB9D3FBDB
			16r5579C0BD 16r1A60320A 16rD6A100C6 16r402C7279
			16r679F25FE 16rFB1FA3CC 16r8EA5E9F8 16rDB3222F8
			16r3C7516DF 16rFD616B15 16r2F501EC8 16rAD0552AB
			16r323DB5FA 16rFD238760 16r53317B48 16r3E00DF82
			16r9E5C57BB 16rCA6F8CA0 16r1A87562E 16rDF1769DB
			16rD542A8F6 16r287EFFC3 16rAC6732C6 16r8C4F5573
			16r695B27B0 16rBBCA58C8 16rE1FFA35D 16rB8F011A0
			16r10FA3D98 16rFD2183B8 16r4AFCB56C 16r2DD1D35B
			16r9A53E479 16rB6F84565 16rD28E49BC 16r4BFB9790
			16rE1DDF2DA 16rA4CB7E33 16r62FB1341 16rCEE4C6E8
			16rEF20CADA 16r36774C01 16rD07E9EFE 16r2BF11FB4
			16r95DBDA4D 16rAE909198 16rEAAD8E71 16r6B93D5A0
			16rD08ED1D0 16rAFC725E0 16r8E3C5B2F 16r8E7594B7
			16r8FF6E2FB 16rF2122B64 16r8888B812 16r900DF01C
			16r4FAD5EA0 16r688FC31C 16rD1CFF191 16rB3A8C1AD
			16r2F2F2218 16rBE0E1777 16rEA752DFE 16r8B021FA1
			16rE5A0CC0F 16rB56F74E8 16r18ACF3D6 16rCE89E299
			16rB4A84FE0 16rFD13E0B7 16r7CC43B81 16rD2ADA8D9
			16r165FA266 16r80957705 16r93CC7314 16r211A1477
			16rE6AD2065 16r77B5FA86 16rC75442F5 16rFB9D35CF
			16rEBCDAF0C 16r7B3E89A0 16rD6411BD3 16rAE1E7E49
			16r00250E2D 16r2071B35E 16r226800BB 16r57B8E0AF
			16r2464369B 16rF009B91E 16r5563911D 16r59DFA6AA
			16r78C14389 16rD95A537F 16r207D5BA2 16r02E5B9C5
			16r83260376 16r6295CFA9 16r11C81968 16r4E734A41
			16rB3472DCA 16r7B14A94A 16r1B510052 16r9A532915
			16rD60F573F 16rBC9BC6E4 16r2B60A476 16r81E67400
			16r08BA6FB5 16r571BE91F 16rF296EC6B 16r2A0DD915
			16rB6636521 16rE7B9F9B6 16rFF34052E 16rC5855664
			16r53B02D5D 16rA99F8FA1 16r08BA4799 16r6E85076A	)! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:52'!s1Box
	^#(16r4B7A70E9 16rB5B32944 16rDB75092E 16rC4192623
			16rAD6EA6B0 16r49A7DF7D 16r9CEE60B8 16r8FEDB266
			16rECAA8C71 16r699A17FF 16r5664526C 16rC2B19EE1
			16r193602A5 16r75094C29 16rA0591340 16rE4183A3E
			16r3F54989A 16r5B429D65 16r6B8FE4D6 16r99F73FD6
			16rA1D29C07 16rEFE830F5 16r4D2D38E6 16rF0255DC1
			16r4CDD2086 16r8470EB26 16r6382E9C6 16r021ECC5E
			16r09686B3F 16r3EBAEFC9 16r3C971814 16r6B6A70A1
			16r687F3584 16r52A0E286 16rB79C5305 16rAA500737
			16r3E07841C 16r7FDEAE5C 16r8E7D44EC 16r5716F2B8
			16rB03ADA37 16rF0500C0D 16rF01C1F04 16r0200B3FF
			16rAE0CF51A 16r3CB574B2 16r25837A58 16rDC0921BD
			16rD19113F9 16r7CA92FF6 16r94324773 16r22F54701
			16r3AE5E581 16r37C2DADC 16rC8B57634 16r9AF3DDA7
			16rA9446146 16r0FD0030E 16rECC8C73E 16rA4751E41
			16rE238CD99 16r3BEA0E2F 16r3280BBA1 16r183EB331
			16r4E548B38 16r4F6DB908 16r6F420D03 16rF60A04BF
			16r2CB81290 16r24977C79 16r5679B072 16rBCAF89AF
			16rDE9A771F 16rD9930810 16rB38BAE12 16rDCCF3F2E
			16r5512721F 16r2E6B7124 16r501ADDE6 16r9F84CD87
			16r7A584718 16r7408DA17 16rBC9F9ABC 16rE94B7D8C
			16rEC7AEC3A 16rDB851DFA 16r63094366 16rC464C3D2
			16rEF1C1847 16r3215D908 16rDD433B37 16r24C2BA16
			16r12A14D43 16r2A65C451 16r50940002 16r133AE4DD
			16r71DFF89E 16r10314E55 16r81AC77D6 16r5F11199B
			16r043556F1 16rD7A3C76B 16r3C11183B 16r5924A509
			16rF28FE6ED 16r97F1FBFA 16r9EBABF2C 16r1E153C6E
			16r86E34570 16rEAE96FB1 16r860E5E0A 16r5A3E2AB3
			16r771FE71C 16r4E3D06FA 16r2965DCB9 16r99E71D0F
			16r803E89D6 16r5266C825 16r2E4CC978 16r9C10B36A
			16rC6150EBA 16r94E2EA78 16rA5FC3C53 16r1E0A2DF4
			16rF2F74EA7 16r361D2B3D 16r1939260F 16r19C27960
			16r5223A708 16rF71312B6 16rEBADFE6E 16rEAC31F66
			16rE3BC4595 16rA67BC883 16rB17F37D1 16r018CFF28
			16rC332DDEF 16rBE6C5AA5 16r65582185 16r68AB9802
			16rEECEA50F 16rDB2F953B 16r2AEF7DAD 16r5B6E2F84
			16r1521B628 16r29076170 16rECDD4775 16r619F1510
			16r13CCA830 16rEB61BD96 16r0334FE1E 16rAA0363CF
			16rB5735C90 16r4C70A239 16rD59E9E0B 16rCBAADE14
			16rEECC86BC 16r60622CA7 16r9CAB5CAB 16rB2F3846E
			16r648B1EAF 16r19BDF0CA 16rA02369B9 16r655ABB50
			16r40685A32 16r3C2AB4B3 16r319EE9D5 16rC021B8F7
			16r9B540B19 16r875FA099 16r95F7997E 16r623D7DA8
			16rF837889A 16r97E32D77 16r11ED935F 16r16681281
			16r0E358829 16rC7E61FD6 16r96DEDFA1 16r7858BA99
			16r57F584A5 16r1B227263 16r9B83C3FF 16r1AC24696
			16rCDB30AEB 16r532E3054 16r8FD948E4 16r6DBC3128
			16r58EBF2EF 16r34C6FFEA 16rFE28ED61 16rEE7C3C73
			16r5D4A14D9 16rE864B7E3 16r42105D14 16r203E13E0
			16r45EEE2B6 16rA3AAABEA 16rDB6C4F15 16rFACB4FD0
			16rC742F442 16rEF6ABBB5 16r654F3B1D 16r41CD2105
			16rD81E799E 16r86854DC7 16rE44B476A 16r3D816250
			16rCF62A1F2 16r5B8D2646 16rFC8883A0 16rC1C7B6A3
			16r7F1524C3 16r69CB7492 16r47848A0B 16r5692B285
			16r095BBF00 16rAD19489D 16r1462B174 16r23820E00
			16r58428D2A 16r0C55F5EA 16r1DADF43E 16r233F7061
			16r3372F092 16r8D937E41 16rD65FECF1 16r6C223BDB
			16r7CDE3759 16rCBEE7460 16r4085F2A7 16rCE77326E
			16rA6078084 16r19F8509E 16rE8EFD855 16r61D99735
			16rA969A7AA 16rC50C06C2 16r5A04ABFC 16r800BCADC
			16r9E447A2E 16rC3453484 16rFDD56705 16r0E1E9EC9
			16rDB73DBD3 16r105588CD 16r675FDA79 16rE3674340
			16rC5C43465 16r713E38D8 16r3D28F89E 16rF16DFF20
			16r153E21E7 16r8FB03D4A 16rE6E39F2B 16rDB83ADF7)! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:52'!s2Box
	^#(16rE93D5A68 16r948140F7 16rF64C261C 16r94692934
			16r411520F7 16r7602D4F7 16rBCF46B2E 16rD4A20068
			16rD4082471 16r3320F46A 16r43B7D4B7 16r500061AF
			16r1E39F62E 16r97244546 16r14214F74 16rBF8B8840
			16r4D95FC1D 16r96B591AF 16r70F4DDD3 16r66A02F45
			16rBFBC09EC 16r03BD9785 16r7FAC6DD0 16r31CB8504
			16r96EB27B3 16r55FD3941 16rDA2547E6 16rABCA0A9A
			16r28507825 16r530429F4 16r0A2C86DA 16rE9B66DFB
			16r68DC1462 16rD7486900 16r680EC0A4 16r27A18DEE
			16r4F3FFEA2 16rE887AD8C 16rB58CE006 16r7AF4D6B6
			16rAACE1E7C 16rD3375FEC 16rCE78A399 16r406B2A42
			16r20FE9E35 16rD9F385B9 16rEE39D7AB 16r3B124E8B
			16r1DC9FAF7 16r4B6D1856 16r26A36631 16rEAE397B2
			16r3A6EFA74 16rDD5B4332 16r6841E7F7 16rCA7820FB
			16rFB0AF54E 16rD8FEB397 16r454056AC 16rBA489527
			16r55533A3A 16r20838D87 16rFE6BA9B7 16rD096954B
			16r55A867BC 16rA1159A58 16rCCA92963 16r99E1DB33
			16rA62A4A56 16r3F3125F9 16r5EF47E1C 16r9029317C
			16rFDF8E802 16r04272F70 16r80BB155C 16r05282CE3
			16r95C11548 16rE4C66D22 16r48C1133F 16rC70F86DC
			16r07F9C9EE 16r41041F0F 16r404779A4 16r5D886E17
			16r325F51EB 16rD59BC0D1 16rF2BCC18F 16r41113564
			16r257B7834 16r602A9C60 16rDFF8E8A3 16r1F636C1B
			16r0E12B4C2 16r02E1329E 16rAF664FD1 16rCAD18115
			16r6B2395E0 16r333E92E1 16r3B240B62 16rEEBEB922
			16r85B2A20E 16rE6BA0D99 16rDE720C8C 16r2DA2F728
			16rD0127845 16r95B794FD 16r647D0862 16rE7CCF5F0
			16r5449A36F 16r877D48FA 16rC39DFD27 16rF33E8D1E
			16r0A476341 16r992EFF74 16r3A6F6EAB 16rF4F8FD37
			16rA812DC60 16rA1EBDDF8 16r991BE14C 16rDB6E6B0D
			16rC67B5510 16r6D672C37 16r2765D43B 16rDCD0E804
			16rF1290DC7 16rCC00FFA3 16rB5390F92 16r690FED0B
			16r667B9FFB 16rCEDB7D9C 16rA091CF0B 16rD9155EA3
			16rBB132F88 16r515BAD24 16r7B9479BF 16r763BD6EB
			16r37392EB3 16rCC115979 16r8026E297 16rF42E312D
			16r6842ADA7 16rC66A2B3B 16r12754CCC 16r782EF11C
			16r6A124237 16rB79251E7 16r06A1BBE6 16r4BFB6350
			16r1A6B1018 16r11CAEDFA 16r3D25BDD8 16rE2E1C3C9
			16r44421659 16r0A121386 16rD90CEC6E 16rD5ABEA2A
			16r64AF674E 16rDA86A85F 16rBEBFE988 16r64E4C3FE
			16r9DBC8057 16rF0F7C086 16r60787BF8 16r6003604D
			16rD1FD8346 16rF6381FB0 16r7745AE04 16rD736FCCC
			16r83426B33 16rF01EAB71 16rB0804187 16r3C005E5F
			16r77A057BE 16rBDE8AE24 16r55464299 16rBF582E61
			16r4E58F48F 16rF2DDFDA2 16rF474EF38 16r8789BDC2
			16r5366F9C3 16rC8B38E74 16rB475F255 16r46FCD9B9
			16r7AEB2661 16r8B1DDF84 16r846A0E79 16r915F95E2
			16r466E598E 16r20B45770 16r8CD55591 16rC902DE4C
			16rB90BACE1 16rBB8205D0 16r11A86248 16r7574A99E
			16rB77F19B6 16rE0A9DC09 16r662D09A1 16rC4324633
			16rE85A1F02 16r09F0BE8C 16r4A99A025 16r1D6EFE10
			16r1AB93D1D 16r0BA5A4DF 16rA186F20F 16r2868F169
			16rDCB7DA83 16r573906FE 16rA1E2CE9B 16r4FCD7F52
			16r50115E01 16rA70683FA 16rA002B5C4 16r0DE6D027
			16r9AF88C27 16r773F8641 16rC3604C06 16r61A806B5
			16rF0177A28 16rC0F586E0 16r006058AA 16r30DC7D62
			16r11E69ED7 16r2338EA63 16r53C2DD94 16rC2C21634
			16rBBCBEE56 16r90BCB6DE 16rEBFC7DA1 16rCE591D76
			16r6F05E409 16r4B7C0188 16r39720A3D 16r7C927C24
			16r86E3725F 16r724D9DB9 16r1AC15BB4 16rD39EB8FC
			16rED545578 16r08FCA5B5 16rD83D7CD3 16r4DAD0FC4
			16r1E50EF5E 16rB161E6F8 16rA28514D9 16r6C51133C
			16r6FD5C7E7 16r56E14EC4 16r362ABFCE 16rDDC6C837
			16rD79A3234 16r92638212 16r670EFA8E 16r406000E0)! !!CPBBlowfish class methodsFor: 'defaults' stamp: 'gsa 4/30/2012 19:52'!s3Box
	^#(16r3A39CE37 16rD3FAF5CF 16rABC27737 16r5AC52D1B
			16r5CB0679E 16r4FA33742 16rD3822740 16r99BC9BBE
			16rD5118E9D 16rBF0F7315 16rD62D1C7E 16rC700C47B
			16rB78C1B6B 16r21A19045 16rB26EB1BE 16r6A366EB4
			16r5748AB2F 16rBC946E79 16rC6A376D2 16r6549C2C8
			16r530FF8EE 16r468DDE7D 16rD5730A1D 16r4CD04DC6
			16r2939BBDB 16rA9BA4650 16rAC9526E8 16rBE5EE304
			16rA1FAD5F0 16r6A2D519A 16r63EF8CE2 16r9A86EE22
			16rC089C2B8 16r43242EF6 16rA51E03AA 16r9CF2D0A4
			16r83C061BA 16r9BE96A4D 16r8FE51550 16rBA645BD6
			16r2826A2F9 16rA73A3AE1 16r4BA99586 16rEF5562E9
			16rC72FEFD3 16rF752F7DA 16r3F046F69 16r77FA0A59
			16r80E4A915 16r87B08601 16r9B09E6AD 16r3B3EE593
			16rE990FD5A 16r9E34D797 16r2CF0B7D9 16r022B8B51
			16r96D5AC3A 16r017DA67D 16rD1CF3ED6 16r7C7D2D28
			16r1F9F25CF 16rADF2B89B 16r5AD6B472 16r5A88F54C
			16rE029AC71 16rE019A5E6 16r47B0ACFD 16rED93FA9B
			16rE8D3C48D 16r283B57CC 16rF8D56629 16r79132E28
			16r785F0191 16rED756055 16rF7960E44 16rE3D35E8C
			16r15056DD4 16r88F46DBA 16r03A16125 16r0564F0BD
			16rC3EB9E15 16r3C9057A2 16r97271AEC 16rA93A072A
			16r1B3F6D9B 16r1E6321F5 16rF59C66FB 16r26DCF319
			16r7533D928 16rB155FDF5 16r03563482 16r8ABA3CBB
			16r28517711 16rC20AD9F8 16rABCC5167 16rCCAD925F
			16r4DE81751 16r3830DC8E 16r379D5862 16r9320F991
			16rEA7A90C2 16rFB3E7BCE 16r5121CE64 16r774FBE32
			16rA8B6E37E 16rC3293D46 16r48DE5369 16r6413E680
			16rA2AE0810 16rDD6DB224 16r69852DFD 16r09072166
			16rB39A460A 16r6445C0DD 16r586CDECF 16r1C20C8AE
			16r5BBEF7DD 16r1B588D40 16rCCD2017F 16r6BB4E3BB
			16rDDA26A7E 16r3A59FF45 16r3E350A44 16rBCB4CDD5
			16r72EACEA8 16rFA6484BB 16r8D6612AE 16rBF3C6F47
			16rD29BE463 16r542F5D9E 16rAEC2771B 16rF64E6370
			16r740E0D8D 16rE75B1357 16rF8721671 16rAF537D5D
			16r4040CB08 16r4EB4E2CC 16r34D2466A 16r0115AF84
			16rE1B00428 16r95983A1D 16r06B89FB4 16rCE6EA048
			16r6F3F3B82 16r3520AB82 16r011A1D4B 16r277227F8
			16r611560B1 16rE7933FDC 16rBB3A792B 16r344525BD
			16rA08839E1 16r51CE794B 16r2F32C9B7 16rA01FBAC9
			16rE01CC87E 16rBCC7D1F6 16rCF0111C3 16rA1E8AAC7
			16r1A908749 16rD44FBD9A 16rD0DADECB 16rD50ADA38
			16r0339C32A 16rC6913667 16r8DF9317C 16rE0B12B4F
			16rF79E59B7 16r43F5BB3A 16rF2D519FF 16r27D9459C
			16rBF97222C 16r15E6FC2A 16r0F91FC71 16r9B941525
			16rFAE59361 16rCEB69CEB 16rC2A86459 16r12BAA8D1
			16rB6C1075E 16rE3056A0C 16r10D25065 16rCB03A442
			16rE0EC6E0E 16r1698DB3B 16r4C98A0BE 16r3278E964
			16r9F1F9532 16rE0D392DF 16rD3A0342B 16r8971F21E
			16r1B0A7441 16r4BA3348C 16rC5BE7120 16rC37632D8
			16rDF359F8D 16r9B992F2E 16rE60B6F47 16r0FE3F11D
			16rE54CDA54 16r1EDAD891 16rCE6279CF 16rCD3E7E6F
			16r1618B166 16rFD2C1D05 16r848FD2C5 16rF6FB2299
			16rF523F357 16rA6327623 16r93A83531 16r56CCCD02
			16rACF08162 16r5A75EBB5 16r6E163697 16r88D273CC
			16rDE966292 16r81B949D0 16r4C50901B 16r71C65614
			16rE6C6C7BD 16r327A140A 16r45E1D006 16rC3F27B9A
			16rC9AA53FD 16r62A80F00 16rBB25BFE2 16r35BDD2F6
			16r71126905 16rB2040222 16rB6CBCF7C 16rCD769C2B
			16r53113EC0 16r1640E3D3 16r38ABBD60 16r2547ADF0
			16rBA38209C 16rF746CE76 16r77AFA1C5 16r20756060
			16r85CBFE4E 16r8AE88DD8 16r7AAAF9B0 16r4CF9AA7E
			16r1948C25C 16r02FB8A8C 16r01C36AE4 16rD6EBE1F9
			16r90D4F869 16rA65CDEA0 16r3F09252D 16rC208E69F
			16rB74E6132 16rCE77E25B 16r578FDFE3 16r3AC372E6)! !!CPBBlowfish class methodsFor: 'decrypt' stamp: 'gsa 4/30/2012 19:50'!decrypt: someData with: aKeyByteArray
"use this when you have a wordArray"
	^self new decrypt: someData with: aKeyByteArray.! !!CPBBlowfish class methodsFor: 'decrypt' stamp: 'gsa 4/30/2012 19:50'!decryptString: someData with: aKeyString
|dataToEncrypt |
dataToEncrypt :=OrderedCollection new.
someData do:[:each | dataToEncrypt add: each asciiValue ].
	^self new decrypt: dataToEncrypt asArray with: aKeyString asByteArray .! !!CPBBlowfish class methodsFor: 'decrypt' stamp: 'gsa 4/30/2012 19:45'!decryptToString: someData with: aKey
|decryptedData | 
decryptedData := (self new ecbDecrypt: someData with: aKey asByteArray  ).
	^String fromByteArray:  decryptedData asByteArray .! !!CPBBlowfish class methodsFor: 'encrypt' stamp: 'gsa 4/30/2012 19:50'!ecbDecrypt: someData with: aKey
"use this when you have a byteArray"
	^self new ecbDecrypt: someData with: aKey.! !!CPBBlowfish class methodsFor: 'encrypt' stamp: 'gsa 4/30/2012 19:50'!ecbEncrypt: someData with: aKey
"use this when you have a byteArray"
	^self new ecbEncrypt: someData with: aKey.! !!CPBBlowfish class methodsFor: 'encrypt' stamp: 'gsa 4/30/2012 19:50'!encrypt: someData with: aKey
"use this when you have a wordArray"
	^self new encrypt: someData  with: aKey.! !!CPBBlowfish class methodsFor: 'encrypt' stamp: 'gsa 4/30/2012 19:50'!encryptString: someData with: aKeyString
"use this with a string"
|dataToEncrypt |
dataToEncrypt :=OrderedCollection new.
someData do:[:each | dataToEncrypt add: each asciiValue ].
	^self new ecbEncrypt: dataToEncrypt asArray with: aKeyString asByteArray .! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:49'!initialize
	super initialize.
	self
		initializeClear;
		initializeEncrypted;
		initializeKeys! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:49'!initializeClear
	| tmpClear |
	clear := OrderedCollection new.
	tmpClear := #('0000000000000000' 'FFFFFFFFFFFFFFFF' '1000000000000001' '1111111111111111' '1111111111111111' '0123456789ABCDEF' '0000000000000000' '0123456789ABCDEF' '01A1D6D039776742' '5CD54CA83DEF57DA' '0248D43806F67172' '51454B582DDF440A' '42FD443059577FA2' '059B5E0851CF143A' '0756D8E0774761D2' '762514B829BF486A' '3BDD119049372802' '26955F6835AF609A' '164D5E404F275232' '6B056E18759F5CCA' '004BD6EF09176062' '480D39006EE762F2' '437540C8698F3CFA' '072D43A077075292' '02FE55778117F12A' '1D9D5C5018F728C2' '305532286D6F295A' '0123456789ABCDEF' '0123456789ABCDEF' '0123456789ABCDEF' 'FFFFFFFFFFFFFFFF' '0000000000000000' '0000000000000000' 'FFFFFFFFFFFFFFFF').
	tmpClear
		do: [ :each | 
			| array tmpByteArray |
			array := WordArray new: 2.
			array at: 1 put: ((ByteArray fromHexString: (each copyFrom: 1 to: 8)) unsignedLongAt: 1 bigEndian: true).
			array at: 2 put: ((ByteArray fromHexString: (each copyFrom: 9 to: 16)) unsignedLongAt: 1 bigEndian: true).
			clear add: array ]! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:49'!initializeEncrypted
	| tmpEncrypted |
	encrypted := OrderedCollection new.
	tmpEncrypted := #('4EF997456198DD78' '51866FD5B85ECB8A' '7D856F9A613063F2' '2466DD878B963C9D' '61F9C3802281B096' '7D0CC630AFDA1EC7' '4EF997456198DD78' '0ACEAB0FC6A0A28D' '59C68245EB05282B' 'B1B8CC0B250F09A0' '1730E5778BEA1DA4' 'A25E7856CF2651EB' '353882B109CE8F1A' '48F4D0884C379918' '432193B78951FC98' '13F04154D69D1AE5' '2EEDDA93FFD39C79' 'D887E0393C2DA6E3' '5F99D04F5B163969' '4A057A3B24D3977B' '452031C1E4FADA8E' '7555AE39F59B87BD' '53C55F9CB49FC019' '7A8E7BFA937E89A3' 'CF9C5D7A4986ADB5' 'D1ABB290658BC778' '55CB3774D13EF201' 'FA34EC4847B268B2' 'A790795108EA3CAE' 'C39E072D9FAC631D' '014933E0CDAFF6E4' 'F21E9A77B71C49BC' '245946885754369A' '6B5C5A9C5D9E0A5A').
	tmpEncrypted
		do: [ :each | 
			| array tmpByteArray |
			array := WordArray new: 2.
			array at: 1 put: ((ByteArray fromHexString: (each copyFrom: 1 to: 8)) unsignedLongAt: 1 bigEndian: true).
			array at: 2 put: ((ByteArray fromHexString: (each copyFrom: 9 to: 16)) unsignedLongAt: 1 bigEndian: true).
			encrypted add: array ]! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:49'!initializeKeys
	| tempKeys |
	keys := OrderedCollection new.
	tempKeys := #('0000000000000000' 'FFFFFFFFFFFFFFFF' '3000000000000000' '1111111111111111' '0123456789ABCDEF' '1111111111111111' '0000000000000000' 'FEDCBA9876543210' '7CA110454A1A6E57' '0131D9619DC1376E' '07A1133E4A0B2686' '3849674C2602319E' '04B915BA43FEB5B6' '0113B970FD34F2CE' '0170F175468FB5E6' '43297FAD38E373FE' '07A7137045DA2A16' '04689104C2FD3B2F' '37D06BB516CB7546' '1F08260D1AC2465E' '584023641ABA6176' '025816164629B007' '49793EBC79B3258F' '4FB05E1515AB73A7' '49E95D6D4CA229BF' '018310DC409B26D6' '1C587F1C13924FEF' '0101010101010101' '1F1F1F1F0E0E0E0E' 'E0FEE0FEF1FEF1FE' '0000000000000000' 'FFFFFFFFFFFFFFFF' '0123456789ABCDEF' 'FEDCBA9876543210').
	tempKeys do: [ :each | keys add: (ByteArray fromHexString: each) ]! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:27'!longDecryptionTest
	"(1 to: keys size)"
	(20 to: keys size)
		do: [ :each | 
			| key clearText cipherText enc |
			key := keys at: each.
			clearText := clear at: each.
			cipherText := encrypted at: each.
			enc := CPBBlowfish decrypt: cipherText with: key ]! !!CPBBlowfishProfiling methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:27'!longEncryptionTest
	"(1 to: keys size)"
	(20 to: keys size)
		do: [ :each | 
			| key clearText cipherText enc |
			key := keys at: each.
			clearText := clear at: each.
			cipherText := encrypted at: each.
			enc := CPBBlowfish encrypt: clearText with: key ]! !!CPBBlowfishProfiling class methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/10/2012 13:43'!longTest
	! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'PaulDeBruicker 4/25/2011 13:39'!setUp
	"this data is from here: http://www.schneier.com/code/vectors.txt"

	| tmpKeys tmpClear tmpEncrypted |
	keys := OrderedCollection new.
	clear := OrderedCollection new.
	encrypted := OrderedCollection new.
	tmpKeys := #('0000000000000000' 'FFFFFFFFFFFFFFFF' '3000000000000000' '1111111111111111' '0123456789ABCDEF' '1111111111111111' '0000000000000000' 'FEDCBA9876543210' '7CA110454A1A6E57' '0131D9619DC1376E' '07A1133E4A0B2686' '3849674C2602319E' '04B915BA43FEB5B6' '0113B970FD34F2CE' '0170F175468FB5E6' '43297FAD38E373FE' '07A7137045DA2A16' '04689104C2FD3B2F' '37D06BB516CB7546' '1F08260D1AC2465E' '584023641ABA6176' '025816164629B007' '49793EBC79B3258F' '4FB05E1515AB73A7' '49E95D6D4CA229BF' '018310DC409B26D6' '1C587F1C13924FEF' '0101010101010101' '1F1F1F1F0E0E0E0E' 'E0FEE0FEF1FEF1FE' '0000000000000000' 'FFFFFFFFFFFFFFFF' '0123456789ABCDEF' 'FEDCBA9876543210').
	tmpClear := #('0000000000000000' 'FFFFFFFFFFFFFFFF' '1000000000000001' '1111111111111111' '1111111111111111' '0123456789ABCDEF' '0000000000000000' '0123456789ABCDEF' '01A1D6D039776742' '5CD54CA83DEF57DA' '0248D43806F67172' '51454B582DDF440A' '42FD443059577FA2' '059B5E0851CF143A' '0756D8E0774761D2' '762514B829BF486A' '3BDD119049372802' '26955F6835AF609A' '164D5E404F275232' '6B056E18759F5CCA' '004BD6EF09176062' '480D39006EE762F2' '437540C8698F3CFA' '072D43A077075292' '02FE55778117F12A' '1D9D5C5018F728C2' '305532286D6F295A' '0123456789ABCDEF' '0123456789ABCDEF' '0123456789ABCDEF' 'FFFFFFFFFFFFFFFF' '0000000000000000' '0000000000000000' 'FFFFFFFFFFFFFFFF').
	tmpEncrypted := #('4EF997456198DD78' '51866FD5B85ECB8A' '7D856F9A613063F2' '2466DD878B963C9D' '61F9C3802281B096' '7D0CC630AFDA1EC7' '4EF997456198DD78' '0ACEAB0FC6A0A28D' '59C68245EB05282B' 'B1B8CC0B250F09A0' '1730E5778BEA1DA4' 'A25E7856CF2651EB' '353882B109CE8F1A' '48F4D0884C379918' '432193B78951FC98' '13F04154D69D1AE5' '2EEDDA93FFD39C79' 'D887E0393C2DA6E3' '5F99D04F5B163969' '4A057A3B24D3977B' '452031C1E4FADA8E' '7555AE39F59B87BD' '53C55F9CB49FC019' '7A8E7BFA937E89A3' 'CF9C5D7A4986ADB5' 'D1ABB290658BC778' '55CB3774D13EF201' 'FA34EC4847B268B2' 'A790795108EA3CAE' 'C39E072D9FAC631D' '014933E0CDAFF6E4' 'F21E9A77B71C49BC' '245946885754369A' '6B5C5A9C5D9E0A5A').	
		
 "keys:=tmpKeys.	"
	tmpKeys do: [ :each | keys add: (ByteArray fromHexString: each)  ].
	tmpClear
		do: [ :each | 
			| array tmpByteArray |
			array := WordArray new: 2.
			array at: 1 put: ((ByteArray fromHexString: (each copyFrom: 1 to: 8)) unsignedLongAt: 1 bigEndian: true).
			array at: 2 put: ((ByteArray fromHexString: (each copyFrom: 9 to: 16)) unsignedLongAt: 1 bigEndian: true).
			clear add: array ].
	tmpEncrypted
		do: [ :each | 
			| array tmpByteArray |
			array := WordArray new: 2.
			array at: 1 put: ((ByteArray fromHexString: (each copyFrom: 1 to: 8)) unsignedLongAt: 1 bigEndian: true).
			array at: 2 put: ((ByteArray fromHexString: (each copyFrom: 9 to: 16)) unsignedLongAt: 1 bigEndian: true).
			encrypted add: array ]! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testDecryption
|key data res|
key:='abcdefghijklmnopqrstuvwxyz'.
data:=WordArray  new: 2.
#(16r324ED0FE  16rF413A203) doWithIndex: [:each :i | data at: i put: ((each asByteArray) unsignedLongAt: 1 bigEndian:true)    ].

res:=(CPBBlowfish decrypt: data with:  key asByteArray ).


self assert:((res at: 1) =  1112297303). "16r424c4f571"
self assert:((res at: 2) =   1179210568)."16r46495348"! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testEcbDecrypt
	|key cl enc res |
key:=ByteArray fromHexString:   'FFFFFFFFFFFFFFFF'.
cl := ByteArray fromHexString:  'FFFFFFFFFFFFFFFF'.
enc :=ByteArray fromHexString:  '51866FD5B85ECB8A' . 
res:=(CPBBlowfish ecbDecrypt: enc with: key ).
self assert: (res = cl).! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testEcbEncrypt
	|key cl enc res |
key:=ByteArray fromHexString:   'FFFFFFFFFFFFFFFF'.
cl := ByteArray fromHexString:  'FFFFFFFFFFFFFFFF'.
enc :=ByteArray fromHexString:  '51866FD5B85ECB8A' . 
res:=(CPBBlowfish ecbEncrypt: cl with: key ) .

self assert: (res= enc).! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testEncryptDecrypt

self assert:((CPBBlowfish decryptToString:    (CPBBlowfish encryptString: '0123456789' with: 'AAAAA'  )  with:'AAAAA'  )='0123456789')! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testEncryption
|key data res|
key:='abcdefghijklmnopqrstuvwxyz'.
data:=WordArray  new: 2.
#(16r424C4F57 16r46495348) doWithIndex: [:each :i | data at: i put: ((each asByteArray) unsignedLongAt: 1 bigEndian:true)    ].
res:=(CPBBlowfish encrypt: data with:   key asByteArray).


self assert:((res at: 1) = 844026110). "16r324ed0fe"
self assert:((res at: 2) =  4094927363)."16rf413a203"! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testLongDecryptionTest

(1 to: keys size) do:[:each | |key clearText cipherText enc| 
	key:= keys at: each.
	clearText:=clear at: each.
	cipherText:=encrypted at: each.
	enc:=CPBBlowfish decrypt: cipherText  with: key.   
	self assert:   (enc = clearText asArray )
	]! !!CPBBlowfishTests methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:28'!testLongEncryptionTest

(1 to: keys size) do:[:each | |key clearText cipherText enc| 
	key:= keys at: each.
	clearText:=clear at: each.
	cipherText:=encrypted at: each.
	enc:=CPBBlowfish encrypt: clearText  with: key.   
	self assert:   (enc = cipherText )
	]! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:12'!addMomentumTo: anArray
   anArray at: 1 put: (anArray at: 1) + (vx * mass).
   anArray at: 2 put: (anArray at: 2) + (vy * mass).
   anArray at: 3 put: (anArray at: 3) + (vz * mass).
   ^anArray! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:13'!and: aBody velocityAfter: dt        
   | dx dy dz distance mag |
   dx := x - aBody x.
   dy := y - aBody y.
   dz := z - aBody z.
   
   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.
   mag := dt / (distance * distance * distance).

   self decreaseVelocity: dx y: dy z: dz m: aBody mass * mag.   
   aBody increaseVelocity: dx y: dy z: dz m: mass * mag! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:13'!decreaseVelocity: dx y: dy z: dz m: m
   vx := vx - (dx * m).
   vy := vy - (dy * m).
   vz := vz - (dz * m)! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!increaseVelocity: dx y: dy z: dz m: m
   vx := vx + (dx * m).
   vy := vy + (dy * m).
   vz := vz + (dz * m)! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!kineticEnergy
   ^0.5d0 * mass * ((vx * vx) + (vy * vy) + (vz * vz))! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!offsetMomentum: anArray 
   | m |
   m := self class solarMass.
   vx := (anArray at: 1) negated / m.
   vy := (anArray at: 2) negated / m.
   vz := (anArray at: 3) negated / m! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!positionAfter: dt
   x := x + (dt * vx).
   y := y + (dt * vy).
   z := z + (dt * vz)! !!CPBBody methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:14'!potentialEnergy: aBody
   | dx dy dz distance |
   dx := x - aBody x.
   dy := y - aBody y.
   dz := z - aBody z.

   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.
   ^mass * aBody mass / distance! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:09'!mass
	^ mass! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:10'!x
	^ x! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:11'!x: d1 y: d2 z: d3 vx: d4 vy: d5 vz: d6 mass: d7
   x := d1.
   y := d2. 
   z := d3. 
   vx := d4.
   vy := d5.
   vz := d6.
   mass := d7! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:10'!y
	^ y! !!CPBBody methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:10'!z
	^ z! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:15'!daysPerYear
   ^365.24d0! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:15'!jupiter
   ^self new
      x: 4.84143144246472090d0
      y: -1.16032004402742839d0
      z: -1.03622044471123109d-1
      vx: 1.66007664274403694d-3 * self daysPerYear
      vy: 7.69901118419740425d-3 * self daysPerYear
      vz: -6.90460016972063023d-5 * self daysPerYear
      mass: 9.54791938424326609d-4 * self solarMass! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:15'!neptune
   ^self new
      x: 1.53796971148509165d1
      y: -2.59193146099879641d1
      z: 1.79258772950371181d-1
      vx: 2.68067772490389322d-3 * self daysPerYear
      vy: 1.62824170038242295d-3 * self daysPerYear
      vz: -9.51592254519715870d-5 * self daysPerYear
      mass: 5.15138902046611451d-5 * self solarMass! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:15'!pi
   ^3.141592653589793d0! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:16'!saturn
   ^self new
      x: 8.34336671824457987d0
      y: 4.12479856412430479d0
      z: -4.03523417114321381d-1
      vx: -2.76742510726862411d-3 * self daysPerYear
      vy: 4.99852801234917238d-3 * self daysPerYear
      vz: 2.30417297573763929d-5 * self daysPerYear
      mass: 2.85885980666130812d-4 * self solarMass! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:16'!solarMass
   ^4.0d0 * self pi * self pi! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:16'!sun
   ^self new
      x: 0.0d0
      y: 0.0d0
      z: 0.0d0
      vx: 0.0d0
      vy: 0.0d0
      vz: 0.0d0
      mass: self solarMass! !!CPBBody class methodsFor: 'constants' stamp: 'MP 12/11/2013 21:16'!uranus
   ^self new
      x: 1.28943695621391310d1
      y: -1.51111514016986312d1
      z: -2.23307578892655734d-1
      vx: 2.96460137564761618d-3 * self daysPerYear
      vy: 2.37847173959480950d-3 * self daysPerYear
      vz: -2.96589568540237556d-5 * self daysPerYear
      mass: 4.36624404335156298d-5 * self solarMass! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:52'!color
	^ color! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:52'!color: aColor
	color := aColor.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:53'!fade
	color := #faded.
	waitingForPair release.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:47'!fork: aMeetingPlace	SPyVM print: 'Chameneos started' , self color.
	semaphore := [ self run: aMeetingPlace ] parallelFork! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'hh 7/10/2014 15:08'!initialize
	meetings := 0.
      waitingForPair := (OSLock new) lock; yourself.! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:54'!meetings
	^meetings! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'pre 7/3/2014 10:43'!met: other
	| newColor |
	meetings := meetings + 1.
	color == #red ifTrue: [
		newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].
      color == #yellow ifTrue: [
      	newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].
      color == #blue ifTrue: [
      	newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].
      color := newColor.
      waitingForPair release! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'hh 7/10/2014 15:12'!run: meetingPlace
    [ color == #faded ] whileFalse: [	  "SPyVM print: 'Chameneos goes to meeting place' , self color."
        meetingPlace reachedBy: self.
        waitingForPair lock.        "SPyVM print: 'Chameneos met another one and releases lock' , self color." ]! !!CPBChameneos methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:55'!wait
	semaphore wait! !!CPBChameneos class methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:56'!color: c
	^ self new
		initialize;
		color: c! !!CPBDeviceTask methodsFor: 'execution' stamp: 'MP 1/15/2014 17:12'!run: packet
	| return |
	(packet == nil) ifTrue: [
		(self packet1 == nil) ifTrue: [
			return := (self scheduler) suspendCurrent .
		] ifFalse: [
			| v |
			v := self packet1 .
			self packet1: nil .
			return := (self scheduler) queue: v .
		] .
	] ifFalse: [
		self packet1: packet .
		return := (self scheduler) holdCurrent .
	] .
	^ return .! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:06'!packet1
	"Answer the value of packet1"

	^ packet1! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:06'!packet1: anObject
	"Set the value of packet1"

	packet1 := anObject! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:59'!scheduler
	"Answer the value of scheduler"

	^ scheduler! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:59'!scheduler: anObject
	"Set the value of scheduler"

	scheduler := anObject! !!CPBDeviceTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:12'!toString
	^ 'DeviceTask' .! !!CPBDeviceTask methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 17:06'!initialize
	self
		scheduler: nil;
		packet1: nil .! !!CPBDeviceTask class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 17:06'!createWithScheduler: scheduler
	| instance |
	instance := self new .
	instance scheduler: scheduler .
	^ instance .! !!CPBEqualityConstraint methodsFor: 'execution'!execute
        "Enforce this constraint. Assume that it is satisfied."

        (direction == #forward)
                ifTrue: [v2 value: v1 value]
                ifFalse: [v1 value: v2 value].! !!CPBEqualityConstraint class methodsFor: 'instance creation'!var: variable1 var: variable2 strength: strengthSymbol
        "Install a constraint with the given strength equating the given
         variables."

        ^(self new) var: variable1 var: variable2 strength: strengthSymbol! !!CPBHandlerTask methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 17:28'!initialize
	self 
		scheduler: nil;
		v1: nil;
		v2: nil .! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!scheduler
	"Answer the value of scheduler"

	^ scheduler! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!scheduler: anObject
	"Set the value of scheduler"

	scheduler := anObject! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:30'!toString
	^ 'HandlerTask'! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!v1
	"Answer the value of v1"

	^ v1! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!v1: anObject
	"Set the value of v1"

	v1 := anObject! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!v2
	"Answer the value of v2"

	^ v2! !!CPBHandlerTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 17:27'!v2: anObject
	"Set the value of v2"

	v2 := anObject! !!CPBHandlerTask methodsFor: 'execution' stamp: 'MP 1/15/2014 18:54'!run: packet
	| return |
	(packet ~~ nil) ifTrue: [
		(packet kind == (CPBPacket kindWork)) ifTrue: [
			self v1: (packet addTo: (self v1)) .
		] ifFalse: [
			self v2: (packet addTo: (self v2)).
		] .
	] .
	
	(self v1 ~~ nil) ifTrue: [
		| count v |
		count := (self v1) a1 .
		(count < (CPBPacket dataSize)) ifTrue: [
			(self v2 ~~ nil) ifTrue: [
				v := self v2 .
				self v2: ((self v2) link) .
				v a1: (((self v1) a2) at: (count + 1)) .
				(self v1) a1: (count + 1) .
				return := (self scheduler) queue: v .
			] ifFalse: [
				return := (self scheduler) suspendCurrent .
			] .
		] ifFalse: [
			v := self v1 .
      		self v1: ((self v1) link) .
		      return := (self scheduler) queue: v .
		] .
	] ifFalse: [
		return := (self scheduler) suspendCurrent .
	] .
	^ return .! !!CPBHandlerTask class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 17:27'!createWithScheduler: scheduler
	| instance |
	instance := self new .
	instance scheduler: scheduler .
	^ instance! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!count
	"Answer the value of count"

	^ count! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!count: anObject
	"Set the value of count"

	count := anObject! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!scheduler
	"Answer the value of scheduler"

	^ scheduler! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!scheduler: anObject
	"Set the value of scheduler"

	scheduler := anObject! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!seed1
	"Answer the value of seed1"

	^ seed1! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:43'!seed1: anObject
	"Set the value of seed1"

	seed1 := anObject! !!CPBIdleTask methodsFor: 'accessing' stamp: 'MP 1/15/2014 16:47'!toString
	^ 'IdleTask' .! !!CPBIdleTask methodsFor: 'initialize-release' stamp: 'MP 1/15/2014 16:46'!initialize
	self
		scheduler: nil;
		seed1: 0;
		count: 0 .! !!CPBIdleTask methodsFor: 'execution' stamp: 'MP 1/15/2014 16:58'!run: packet
	| return |
	self count: (self count) - 1 .
	
	(self count == 0) ifTrue: [
		return := (self scheduler) holdCurrent .
	] ifFalse: [
		((self seed1 bitAnd: 1) == 0) ifTrue: [
			self seed1: (self seed1 bitShift: -1) .
			return := (self scheduler) release: (CPBScheduler idDeviceA) .
		] ifFalse: [
			self seed1: ((self seed1 bitShift: -1) bitXor: 16rD008) .
			return := (self scheduler) release: (CPBScheduler idDeviceB) .
		]
	] .
	^ return .
	! !!CPBIdleTask class methodsFor: 'instance creation' stamp: 'MP 1/15/2014 16:46'!createWithScheduler: scheduler withSeed: seed times: times
	| instance |
	instance := self new .
	instance
		scheduler: scheduler;
		seed1: seed;
		count: times .
	^ instance .! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:41'!absSq
	^(a*a) + (b*b)! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:36'!add: aComplex
	a := a + aComplex real.
	b := b + aComplex imaginary.! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:36'!imaginary
	^b.! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:36'!real
	^a.! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:33'!real: aNumber imaginary: bNumber
	a := aNumber.
	b := bNumber.
	! !!CPBInplaceComplex methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:35'!square
	| tempA |
	tempA := (a * a) - (b * b).
	b := 2 * a * b.
	a := tempA.! !!CPBInplaceComplex class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:33'!real: a imaginary: b
	^(self new) real: a imaginary: b.
	! !!CPBInplaceComplex class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 13:39'!zero
	^(self new) real: 0 imaginary: 0.
	! !!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 14:49'!calculateAt: aComplex value: anotherComplex iteration: aNumber maxIterations: anotherNumber
	(aNumber >= anotherNumber) ifTrue: [^anotherNumber].
	anotherComplex square.
	anotherComplex add: aComplex.
	(anotherComplex absSq >= 4)
		ifTrue: [^ aNumber]
		ifFalse: [^ self
				calculateAt: aComplex
				value: anotherComplex
				iteration: aNumber + 1
				maxIterations: anotherNumber]! !!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 14:49'!calculateAtIterative: aComplex maxIterations: maxIterations
	| current |
	current := CPBInplaceComplex zero.
	0 to: maxIterations do: [:iteration|
		current square.
		current add: aComplex.
		(current absSq >= 4) ifTrue:[
			^iteration.	
		].
	].
	^maxIterations.! !!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 14:49'!calculateAtRecursive: aComplex maxIterations: aNumber
	^self calculateAt: aComplex value: CPBInplaceComplex zero iteration: 0 maxIterations: aNumber.! !!CPBMandelbrotField methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 17:11'!calculateWithThreadsSTM: anInteger	| semaphores |	semaphores := OrderedCollection new.	1 to: anInteger do:[ :i |			semaphores add: (self createThreadSTM: i of: anInteger).		].	semaphores do: [:s| s wait].! !!CPBMandelbrotField methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 17:11'!createThreadSTM: threadNumber of: threadCount	^ [ | index maxIndex |	maxIndex := self form width * self form height.	index := threadNumber.	[index < maxIndex] whileTrue: [		self calculateValAt: (self pointForIndex: index).		index := index + threadCount.	] ] parallelFork! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 14:11'!calculate
	1
		to: self form width
		do: [:x | 1
				to: self form height
				do: [:y | self
						calculateValAt: x@y]]! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 15:29'!calculateValAt: aPoint
	| val aComplex |
	aComplex := (Complex
		real: (aPoint x * (self imageBounds width / self form width) + self imageBounds left) asFloat
		imaginary: (aPoint y * (self imageBounds height / self form height) + self imageBounds top) asFloat).
 	(self mode = #iterative) ifTrue: [
		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.
	] ifFalse: [
		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.
	].
	self form colorAt: aPoint put: (self colorForValue: val).! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/7/2014 12:18'!calculateWithThreads: anInteger
| semaphores |
	semaphores := OrderedCollection new.
	1 to: anInteger do:[ :i |
			semaphores add: (self createThread: i of: anInteger).
		].
	semaphores do: [:s| s wait].! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'hh 6/12/2014 21:02'!calculateWithThreadsSTM: anInteger
| semaphores |
	semaphores := OrderedCollection new.
	1 to: anInteger do:[ :i |
			semaphores add: (self createThreadSTM: i of: anInteger).
		].
	semaphores do: [:s| s wait].! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/16/2014 15:01'!colorForValue: val
	| r g b |
	(val = self depth) ifTrue:[^Color black].
	r := (((val+1) * 2) rem: 256)/256.
	g := (((val+1) * 3) rem: 256)/256.
	b := (((val+1) * 5) rem: 256)/256.
	^ Color r: r g: g b: b.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/7/2014 12:33'!createThread: threadNumber of: threadCount
| semaphore |
semaphore := Semaphore new.
[ | index maxIndex |
	maxIndex := self form width * self form height.
	index := threadNumber.
	[index < maxIndex] whileTrue: [
		self calculateValAt: (self pointForIndex: index).
		index := index + threadCount.
	].
	semaphore signal.
] fork.
^ semaphore.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:51'!createThreadSTM: threadNumber of: threadCount
^ [ | index maxIndex |
	maxIndex := self form width * self form height.
	index := threadNumber.
	[index < maxIndex] whileTrue: [
		self calculateValAt: (self pointForIndex: index).
		index := index + threadCount.
	].
] parallelFork! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 17:12'!drawOn: aCanvas 
	"super drawOn: aCanvas.
	aCanvas drawImage: self form at: self topLeft"! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/10/2013 14:02'!form
	form ifNil: [form := Form extent: self extent depth: 32].
	^form.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 12/11/2013 15:38'!handlesMouseDown: anEvent
	^true.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:38'!mouseDown: anEvent
	| p |
	p := anEvent position - self topLeft.
	"Transcript showln: (Complex 
		real: ((p x * (self imageBounds width / self form width)) + self imageBounds left) asFloat
		imaginary: ((p y * (self imageBounds height / self form height)) + self imageBounds top) asFloat)"! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/7/2014 11:58'!pointForIndex: anInteger
	| x y |
	y := (anInteger / self width) floor.
	x := anInteger - (self width * y).
	
	^ x@y.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'BS 1/7/2014 12:06'!reCalculate
	form := nil.
	(self threadCount <= 1) ifTrue: [
		self calculate.
	] ifFalse: [
		self calculateWithThreads: self threadCount.
	].
	self changed.! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'hh 6/12/2014 21:03'!reCalculateSTM
	form := nil.
	(self threadCount <= 1) ifTrue: [
		self calculate.
	] ifFalse: [
		self calculateWithThreadsSTM: self threadCount.
	].
	self changed.! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/11/2013 14:55'!depth
	depth ifNil: [depth := 100].
	^depth! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/11/2013 14:54'!depth: aNumber
	depth := aNumber! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/10/2013 16:04'!form: anObject

	form := anObject! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/11/2013 15:27'!imageBounds
	imageBounds ifNil: [imageBounds := -2@ -1.5 corner: 1@1.5].
	^imageBounds! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/11/2013 15:27'!imageBounds: aRectangle
	imageBounds := aRectangle! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/10/2013 16:04'!mode
	mode ifNil: [mode := #iterative].
	^ mode! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 12/10/2013 16:04'!mode: anObject

	mode := anObject! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 1/7/2014 12:03'!threadCount
	threadCount ifNil: [threadCount := 1].
	^ threadCount! !!CPBMandelbrotMorph methodsFor: 'accessing' stamp: 'BS 1/7/2014 12:04'!threadCount: anInteger
	threadCount := anInteger.! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:52'!initialize

	total := 0! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:59'!max: maxMeetings
	max := maxMeetings! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:59'!organizeMeetingWith: second
	total >= max
		ifTrue: [
			first fade.
			second fade]
		ifFalse: [
			first met: second color.
			second met: first color ].
	total := total + 1! !!CPBMeetingPlace methodsFor: 'as yet unclassified' stamp: 'hh 7/10/2014 15:12'!reachedBy: chameleon	"	tmpString :=  'A Chameneos reached the meeting place: ' , chameleon color , ' when first is occupied: '.	SPyVM print: tmpString".		[ first isNil
            ifTrue: [ first := chameleon. ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil. ] ] atomic value."      tmpString :=  'A Chameneos was in the meeting place and first is now: ' .  	SPyVM print: tmpString. "! !!CPBMeetingPlace class methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 16:59'!forMeetings: maxMeetings
	^super new
		initialize;
		max: maxMeetings;
		yourself! !!CPBPlan methodsFor: 'execution'!execute
        "Execute my constraints in order."

        self do: [: c | c execute].! !!CPBPlanner methodsFor: 'initialize'!initialize
        "Planner initialize"

        currentMark := 1.! !!CPBPlanner methodsFor: 'add/remove'!incrementalAdd: c
        "Attempt to satisfy the given constraint and, if successful,
         incrementally update the dataflow graph.

         Details: If satifying the constraint is successful, it may override a
         weaker constraint on its output. The algorithm attempts to resatisfy
         that constraint using some other method. This process is repeated
         until either a) it reaches a variable that was not previously
         determined by any constraint or b) it reaches a constraint that
         is too weak to be satisfied using any of its methods. The variables
         of constraints that have been processed are marked with a unique mark
         value so that we know where we've been. This allows the algorithm to
         avoid getting into an infinite loop even if the constraint graph has
         an inadvertent cycle."

        | mark overridden |
        mark := self newMark.
        overridden := c satisfy: mark.
        [overridden == nil] whileFalse:
                [overridden := overridden satisfy: mark].! !!CPBPlanner methodsFor: 'add/remove'!incrementalRemove: c
        "Entry point for retracting a constraint. Remove the given constraint,
         which should be satisfied, and incrementally update the dataflow
         graph.

         Details: Retracting the given constraint may allow some currently
         unsatisfiable downstream constraint be satisfied. We thus collect a
         list of unsatisfied downstream constraints and attempt to satisfy
         each one in turn. This list is sorted by constraint strength,
         strongest first, as a heuristic for avoiding unnecessarily adding
         and then overriding weak constraints."

        | out unsatisfied |
        out := c output.
        c markUnsatisfied.
        c removeFromGraph.
        unsatisfied := self removePropagateFrom: out.
        unsatisfied do: [: u | self incrementalAdd: u].! !!CPBPlanner methodsFor: 'planning/value propagation'!extractPlanFromConstraints: constraints
        "Extract a plan for resatisfaction starting from the outputs of the
         given constraints, usually a set of input constraints."

        | sources |
        sources := OrderedCollection new.
        constraints do:
                [: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]].
        ^self makePlan: sources! !!CPBPlanner methodsFor: 'planning/value propagation'!extractPlanFromVariables: variables
        "Extract a plan from the dataflow graph having the given variables. It
         is assumed that the given set of variables is complete, or at least
         that it contains all the input variables."

        | sources |
        sources := OrderedCollection new.
        variables do:
                [: v |
                 (v constraints) do:
                        [: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]]].
        ^self makePlan: sources! !!CPBPlanner methodsFor: 'planning/value propagation'!makePlan: sources
        "Extract a plan for resatisfaction starting from the given satisfied
         source constraints, usually a set of input constraints. This method
         assumes that stay optimization is desired; the plan will contain only
         constraints whose output variables are not stay. Constraints that do
         no computation, such as stay and edit constraints, are not included
         in the plan.

         Details: The outputs of a constraint are marked when it is added to
         the plan under construction. A constraint may be appended to the plan
         when all its input variables are known. A variable is known if either
         a) the variable is marked (indicating that has been computed by a
         constraint appearing earlier in the plan), b) the variable is 'stay'
         (i.e. it is a constant at plan execution time), or c) the variable
         is not determined by any constraint. The last provision is for past
         states of history variables, which are not stay but which are also
         not computed by any constraint."

        | mark plan todo c |
        mark := self newMark.
        plan := CPBPlan new.
        todo := sources.
        [todo isEmpty] whileFalse:
                [c := todo removeFirst.
                 ((c output mark ~= mark) and:                "not in plan already and..."
                 [c inputsKnown: mark]) ifTrue:        "eligible for inclusion"
                        [plan addLast: c.
                         c output mark: mark.
                         self addConstraintsConsuming: c output to: todo]].
        ^plan! !!CPBPlanner methodsFor: 'planning/value propagation'!propagateFrom: v
        "The given variable has changed. Propagate new values downstream."

        | todo c |
        todo := OrderedCollection new.
        self addConstraintsConsuming: v to: todo.
        [todo isEmpty] whileFalse:
                [c := todo removeFirst.
                 c execute.
                 self addConstraintsConsuming: c output to: todo].! !!CPBPlanner methodsFor: 'private'!addConstraintsConsuming: v to: aCollection

        | determiningC |
        determiningC := v determinedBy.
        v constraints do:
                [: c |
                 ((c == determiningC) or: [c isSatisfied not]) ifFalse:
                        [aCollection add: c]].! !!CPBPlanner methodsFor: 'private'!addPropagate: c mark: mark
        "Recompute the walkabout strengths and stay flags of all variables
         downstream of the given constraint and recompute the actual values
         of all variables whose stay flag is true. If a cycle is detected,
         remove the given constraint and answer false. Otherwise, answer true.

         Details: Cycles are detected when a marked variable is encountered
         downstream of the given constraint. The sender is assumed to have
         marked the inputs of the given constraint with the given mark. Thus,
         encountering a marked node downstream of the output constraint means
         that there is a path from the constraint's output to one of its
         inputs."

        | todo d |
        todo := OrderedCollection with: c.
        [todo isEmpty] whileFalse:
                [d := todo removeFirst.
                 (d output mark = mark) ifTrue:
                        [self incrementalRemove: c.
                         ^false].
                 d recalculate.
                 self addConstraintsConsuming: d output to: todo].
        ^true! !!CPBPlanner methodsFor: 'private' stamp: 'HW 1/25/2014 17:21'!changeVar: aVariable newValue: newValue

        | editConstraint plan |
        editConstraint := CPBEditConstraint var: aVariable strength: #preferred.
        plan := self extractPlanFromConstraints: (Array with: editConstraint).
        10 timesRepeat: [
                aVariable value: newValue.
                plan execute].
        editConstraint destroyConstraint.! !!CPBPlanner methodsFor: 'private'!constraintsConsuming: v do: aBlock

        | determiningC |
        determiningC := v determinedBy.
        v constraints do:
                [: c |
                 ((c == determiningC) or: [c isSatisfied not]) ifFalse:
                        [aBlock value: c]].! !!CPBPlanner methodsFor: 'private'!newMark
        "Select a previously unused mark value.

         Details: We just keep incrementing. If necessary, the counter will
         turn into a LargePositiveInteger. In that case, it will be a bit
         slower to compute the next mark but the algorithms will all behave
         correctly. We reserve the value '0' to mean 'unmarked'. Thus, this
         generator starts at '1' and will never produce '0' as a mark value."

        ^currentMark := currentMark + 1! !!CPBPlanner methodsFor: 'private' stamp: 'HW 1/25/2014 17:24'!removePropagateFrom: out
        "Update the walkabout strengths and stay flags of all variables
         downstream of the given constraint. Answer a collection of unsatisfied
         constraints sorted in order of decreasing strength."

        | unsatisfied todo v nextC |
        unsatisfied := SortedCollection sortBlock:
                [: c1 : c2 | c1 strength stronger: c2 strength].
        out determinedBy: nil.
        out walkStrength: CPBStrength absoluteWeakest.
        out stay: true.
        todo := OrderedCollection with: out.
        [todo isEmpty] whileFalse:
                [v := todo removeFirst.
                 v constraints do:
                         [: c | (c isSatisfied) ifFalse: [unsatisfied add: c]].
                 self constraintsConsuming: v do:
                        [: c |
                         c recalculate.
                         todo add: c output]].
        ^unsatisfied! !!CPBPlanner class methodsFor: 'instance creation'!new
        ^currentPlanner := super new initialize! !!CPBPlanner class methodsFor: 'benchmarks' stamp: 'HW 1/25/2014 17:24'!chainTest: n
        "Do chain-of-equality-constraints performance tests."

        | vars editConstraint plan planner |
        planner := CPBPlanner new.
        vars := (1 to: n+1) collect: [ :i | CPBVariable new].

        "thread a chain of equality constraints through the variables"
        1 to: n do:
                [ :i || v1 v2 |
                 v1 := vars at: i.
                 v2 := vars at: i + 1.
                 CPBEqualityConstraint var: v1 var: v2 strength: #required].

        CPBStayConstraint var: vars last strength: #strongDefault.
        editConstraint := CPBEditConstraint var: (vars first) strength: #preferred.
        plan := planner extractPlanFromConstraints: (Array with: editConstraint).
        1 to: 100 do: [ :v |
                vars first value: v.
                plan execute.
                vars last value ~= v ifTrue: [self error: 'Chain test failed!!']].
        editConstraint destroyConstraint! !!CPBPlanner class methodsFor: 'benchmarks' stamp: 'HW 1/25/2014 17:25'!projectionTest: n
        "This test constructs a two sets of variables related to each other by
         a simple linear transformation (scale and offset)."

        | scale offset src dst planner dests |
        planner := CPBPlanner new.
        dests := OrderedCollection new.
        scale := CPBVariable value: 10.
        offset := CPBVariable value: 1000.
        1 to: n do:
                [ :i |
                src := CPBVariable value: i.
                dst := CPBVariable value: i.
                dests add: dst.
                CPBStayConstraint var: src strength: #default.
                CPBScaleConstraint var: src var: scale var: offset var: dst strength: #required].

        planner changeVar: src newValue: 17.
        dst value ~= 1170 ifTrue: [self error: 'Projection test 1 failed!!'].

        planner changeVar: dst newValue: 1050.
        src value ~= 5 ifTrue: [self error: 'Projection test 2 failed!!'].

        planner changeVar: scale newValue: 5.
        1 to: n - 1 do: [ :i |
                (dests at: i) value ~= (i*5 + 1000)
                        ifTrue: [self error: 'Projection test 3 failed!!']].

        planner changeVar: offset newValue: 2000.
        1 to: n - 1 do: [ :i |
                (dests at: i) value ~= (i*5 + 2000)
                        ifTrue: [self error: 'Projection test 4 failed!!']].! !!CPBPlanner class methodsFor: 'benchmarks' stamp: 'pre 7/22/2014 21:38'!report: string times: count run: aBlock
        "Report the time required to execute the given block."

        | time |
        time := Time millisecondsToRun: [count timesRepeat: aBlock].
        "Transcript show: string, ' ', (time // count) printString, ' milliseconds'; cr."! !!CPBPlanner class methodsFor: 'benchmarks'!standardBenchmark
        "This the combined benchmark."
        "Planner standardBenchmark"

        self report: 'Chain and projection tests' times: 100 run: [
                self chainTest: 100.
                self projectionTest: 100
        ]! !!CPBPlanner class methodsFor: 'accessing'!current
        ^currentPlanner! !!CPBScaleConstraint methodsFor: 'initialize-release' stamp: 'HW 1/25/2014 17:24'!src: srcVar scale: scaleVar offset: offsetVar dst: dstVar strength: strengthSymbol
        "Initialize myself with the given variables and strength."

        strength := CPBStrength of: strengthSymbol.
        v1 := srcVar.
        v2 := dstVar.
        scale := scaleVar.
        offset := offsetVar.
        direction := nil.
        self addConstraint.! !!CPBScaleConstraint methodsFor: 'add/remove'!addToGraph
        "Add myself to the constraint graph."

        v1 addConstraint: self.
        v2 addConstraint: self.
        scale addConstraint: self.
        offset addConstraint: self.
        direction := nil.! !!CPBScaleConstraint methodsFor: 'add/remove'!removeFromGraph
        "Remove myself from the constraint graph."

        (v1 == nil) ifFalse: [v1 removeConstraint: self].
        (v2 == nil) ifFalse: [v2 removeConstraint: self].
        (scale == nil) ifFalse: [scale removeConstraint: self].
        (offset == nil) ifFalse: [offset removeConstraint: self].
        direction := nil.! !!CPBScaleConstraint methodsFor: 'planning'!execute
        "Enforce this constraint. Assume that it is satisfied."

        (direction == #forward)
                ifTrue: [v2 value: (v1 value * scale value) + offset value]
                ifFalse: [v1 value: (v2 value - offset value) // scale value].! !!CPBScaleConstraint methodsFor: 'planning'!inputsDo: aBlock
        "Evaluate the given block on my current input variable."

        (direction == #forward)
                ifTrue: [aBlock value: v1; value: scale; value: offset]
                ifFalse: [aBlock value: v2; value: scale; value: offset].! !!CPBScaleConstraint methodsFor: 'planning'!recalculate
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
         the value for the current output of this constraint. Assume this
         constraint is satisfied."

        | in out |
        (direction == #forward)
                ifTrue: [in := v1. out := v2]
                ifFalse: [out := v1. in := v2].
        out walkStrength: (strength weakest: in walkStrength).
        out stay: ((in stay) and: [(scale stay) and: [offset stay]]).
        (out stay) ifTrue: [self execute].                "stay optimization"! !!CPBScaleConstraint class methodsFor: 'instance creation'!var: src var: scale var: offset var: dst strength: strengthSymbol
        "Install a scale constraint with the given strength on the given
         variables."

        ^(self new) src: src scale: scale offset: offset dst: dst strength: strengthSymbol! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:41'!exportKeys
	"Returns an array containing all the keys of tree's nodes"
	
	| result |
	
	result :=  OrderedCollection new.
	
	( self isEmpty ) ifFalse: [
		
		self rootNode traverse: [ :node | result add: node key.].
	].

	^ result.! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:41'!find: aKey
	"Returns the node having the specified key or nil if the tree doesn't contain
	 a node with the specified key.
	
	aKey Key to find in the tree."

	( self isEmpty ) ifTrue: [
		^ nil.
	] ifFalse: [
		self splay: aKey.
		
		( self rootNode key == aKey ) ifTrue: [
			^ self rootNode.
		] ifFalse: [
			^ nil.
		]
	].! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!findGreatestLessThan: aKey
	"Returns the node having the maximum key value 
	 that is less than the specified key value."
	
	( self isEmpty ) ifTrue: [
		^ nil.
	] ifFalse: [
		"splay on the key to move the node with the given key or the last
		 node on the search path to the top of the tree."
		
		self splay: aKey.
		
		"now the result is either the root node or the greatest node in
		 the left subtree."
		
		( self rootNode key < aKey ) ifTrue: [
			^ self rootNode.
		] ifFalse: [
			self rootNode left ifNotNil: [
				^ self findMax: ( self rootNode left ).
			] ifNil: [
				^ nil.
			]
		]
	].! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!findMax
	^self findMax: self rootNode! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:49'!findMax: optStartNode
	"Return the node having the maximum key value."
	
	( self isEmpty ) ifTrue: [
		^ nil.
	] ifFalse: [
		| current |
		current := optStartNode.
		
		[current] whileNotNil: [
			current := current right.
		].
		^ current
	].! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:41'!initialize
	rootNode := nil.
	Transcript show: 'splay tree created'; cr.! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!insert: aKey value: aValue
	"Inserts a node into the tree with the specified key and value if the tree does not already contain
	 a node with the specified key. If the value is inserted, it becomes the root of the tree.
	
	aKey Key to insert into the tree.
	aValue Value to insert into the tree."
		
	( self isEmpty ) ifTrue: [
		 rootNode := CPBSplaytreeNode newWithKey: aKey andValue: aValue.
	] ifFalse: [
		"Splay on the key to move the last node on the search path for the key to the root of the tree."
		| node |
		
		self splay: aKey.
		( self rootNode key = aKey) ifTrue: [
			^ self
		].
		
		node := CPBSplaytreeNode new.
		node key: aKey.
		node value: aValue.
			
		( aKey > self rootNode key ) ifTrue: [
			node left: self rootNode.
			node right: self rootNode right.
			self rootNode right: nil.
		] ifFalse: [
			node right: self rootNode.
			node left: self rootNode left.
			self rootNode left: nil.
		].
	
		self rootNode: node.
	]! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!isEmpty
	"Says whether the tree is empty"
	^ (rootNode isNil).! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:36'!remove: aKey
	"Removes a node with the specified key from the tree if the tree contains a node with this key.
	 The removed node is returned. If the key is not found, an exception is thrown.
	
	 aKey Key to find and remove from the tree.
	 Returns the removed node."
	
	| removed right |
	
	( self isEmpty ) ifTrue: [
		Error signal: 'Key not found.'.
	].

	self splay: aKey.
		
	(self rootNode key ~= aKey) ifTrue: [
		Error signal: 'Key not found.'.
	].
	
	removed := self rootNode.
		
	self rootNode left ifNil: [
		self rootNode: self rootNode right.
	] ifNotNil: [
		right := self rootNode right.
		self rootNode: self rootNode left.
			
		"Splay to make sure that the new root has an empty right child."
		self splay: aKey.
			
		"insert the original right child as the right child of the new root."
		self rootNode right: right.
	].

	^ removed! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!rootNode

	^ rootNode! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:42'!rootNode: anObject

	rootNode := anObject! !!CPBSplaytree methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:46'!splay: aKey
	"Perform the splay operation for the given key. Moves the node with
	the given key to the top of the tree.  If no node has the given
	key, the last node on the search path is moved to the top of the
	tree. This is the simplified top-down splaying algorithm from:
	'Self-adjusting Binary Search Trees by Sleator and Tarjan'
	
	aKey Key to splay the tree on"
	
	| dummy left right current looping|
	
	"init"
	dummy := CPBSplaytreeNode new.	
	left := dummy.
	right := dummy.
	
	current := self rootNode.
	
	looping := true.
	[looping] whileTrue: [
			( aKey < (current key) ) ifTrue: [	
				( current left isNil ) ifTrue: [
					looping := false.
				] ifFalse: [
					( aKey < current left key) ifTrue: [
						"rotate right"
						| tmp |
						tmp := current left.
						current left: ( tmp right).
						tmp right: current.
						current := tmp.
					
						current left ifNil: [
							looping := false.
						].
					].
					looping ifTrue:[
						"link right"
						right left: current.
						right := current.
						current := current left.
					]
				].
			] ifFalse: [
				( aKey > current key ) ifTrue: [
					( current right isNil ) ifTrue: [
						looping := false.
					] ifFalse: [
				
						( aKey > current right key ) ifTrue: [
							"rotate left"
							| tmp |
							tmp := current right.
							current right: ( tmp left ).
							tmp left: current.
							current := tmp.
						
							current right ifNil: [
								looping := false.
							].
						].
					
						looping ifTrue: [
							"link left"
							left right: current.
							left := current.
							current := current right.
						]
					].
				] ifFalse: [
					looping := false.
				].
			].
	 ].

	"assemble"
	
	left right: ( current left ).
	right left: ( current right ).
	current left: ( dummy right ).
	current right: ( dummy left ).
	self rootNode: current.! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:36'!initialize
	self left: nil.
	self right: nil.! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!key

	^ key! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!key: anObject

	key := anObject! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!left

	^ left! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!left: anObject

	left := anObject! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!right

	^ right! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!right: anObject

	right := anObject! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:29'!traverse: aBlock

	"Performs an ordered traversal of the subtree starting at this SplaytreeNode
	 aBlock is a visitor function"
	
	| current |
	
	current := self.
	[current] whileNotNil: [
		| left |
		left := current left.
		
		left ifNotNil: [
			left traverse: aBlock.
		].
		aBlock value: current.
		current := current right.
	].! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!value

	^value! !!CPBSplaytreeNode methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:37'!value: anObject

	value := anObject! !!CPBSplaytreeNode class methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:38'!newWithKey: aKey andValue: aValue 
	^ self new key: aKey;
		 value: aValue;
		 yourself! !!CPBStrength methodsFor: 'comparing'!sameAs: aStrength
        "Answer true if I am the same strength as the given Strength."

        ^arithmeticValue = aStrength arithmeticValue! !!CPBStrength methodsFor: 'comparing'!stronger: aStrength
        "Answer true if I am stronger than the given Strength."

        ^arithmeticValue < aStrength arithmeticValue! !!CPBStrength methodsFor: 'comparing'!weaker: aStrength
        "Answer true if I am weaker than the given Strength."

        ^arithmeticValue > aStrength arithmeticValue! !!CPBStrength methodsFor: 'max/min'!strongest: aStrength
        "Answer the stronger of myself and aStrength."

        (aStrength stronger: self)
                ifTrue: [^aStrength]
                ifFalse: [^self].! !!CPBStrength methodsFor: 'max/min'!weakest: aStrength
        "Answer the weaker of myself and aStrength."

        (aStrength weaker: self)
                ifTrue: [^aStrength]
                ifFalse: [^self].! !!CPBStrength methodsFor: 'printing'!printOn: aStream
        "Append a string which represents my strength onto aStream."

        aStream nextPutAll: '%', symbolicValue, '%'.! !!CPBStrength methodsFor: 'private'!arithmeticValue
        "Answer my arithmetic value. Used for comparisons. Note that
         STRONGER constraints have SMALLER arithmetic values."

        ^arithmeticValue! !!CPBStrength methodsFor: 'private'!initializeWith: symVal
        "Record my symbolic value and reset my arithmetic value."

        symbolicValue := symVal.
        arithmeticValue := StrengthTable at: symbolicValue.! !!CPBStrength class methodsFor: 'class initialization'!initialize
        "Initialize the symbolic strength table. Fix the internally caches
         values of all existing instances."
        "Strength initialize"

        StrengthTable := Dictionary new.
        StrengthTable at: #absoluteStrongest put: -10000.
        StrengthTable at: #required put: -800.
        StrengthTable at: #strongPreferred put: -600.
        StrengthTable at: #preferred put: -400.
        StrengthTable at: #strongDefault put: -200.
        StrengthTable at: #default put: 0.
        StrengthTable at: #weakDefault put: 500.
        StrengthTable at: #absoluteWeakest put: 10000.

        StrengthConstants := Dictionary new.
        StrengthTable keys do:
                [: strengthSymbol |
                        StrengthConstants
                                at: strengthSymbol
                                put: ((super new) initializeWith: strengthSymbol)].

        AbsoluteStrongest := CPBStrength of: #absoluteStrongest.
        AbsoluteWeakest := CPBStrength of: #absoluteWeakest.
        Required := CPBStrength of: #required.! !!CPBStrength class methodsFor: 'instance creation'!of: aSymbol
        "Answer an instance with the specified strength."

        ^StrengthConstants at: aSymbol! !!CPBStrength class methodsFor: 'constants'!absoluteStrongest

        ^AbsoluteStrongest! !!CPBStrength class methodsFor: 'constants'!absoluteWeakest

        ^AbsoluteWeakest! !!CPBStrength class methodsFor: 'constants'!required

        ^Required! !!CPBTreeNode methodsFor: 'accessing' stamp: 'MP 12/11/2013 21:54'!itemCheck
   ^left isNil 
      ifTrue: [item] ifFalse: [item + (left itemCheck - right itemCheck)]! !!CPBTreeNode methodsFor: 'initialize-release' stamp: 'MP 12/11/2013 21:52'!left: leftChild right: rightChild item: anItem
   left := leftChild.
   right := rightChild.
   item := anItem! !!CPBTreeNode class methodsFor: 'instance creation' stamp: 'MP 12/11/2013 21:54'!bottomUpTree: anItem depth: anInteger
   ^(anInteger > 0) 
      ifTrue: [
         self 
            left: (self bottomUpTree: 2*anItem - 1 depth: anInteger - 1) 
            right: (self bottomUpTree: 2*anItem depth: anInteger - 1)  
            item: anItem
         ]
      ifFalse: [self left: nil right: nil item: anItem]! !!CPBTreeNode class methodsFor: 'instance creation' stamp: 'MP 12/11/2013 21:55'!left: leftChild right: rightChild item: anItem      
   ^(super new) left: leftChild right: rightChild item: anItem! !!CPBUnaryConstraint methodsFor: 'initialize-release' stamp: 'HW 1/25/2014 17:24'!var: aVariable strength: strengthSymbol
        "Initialize myself with the given variable and strength."

        strength := CPBStrength of: strengthSymbol.
        output := aVariable.
        satisfied := false.
        self addConstraint.! !!CPBUnaryConstraint methodsFor: 'queries'!isSatisfied
        "Answer true if this constraint is satisfied in the current solution."

        ^satisfied! !!CPBUnaryConstraint methodsFor: 'add/remove'!addToGraph
        "Add myself to the constraint graph."

        output addConstraint: self.
        satisfied := false.! !!CPBUnaryConstraint methodsFor: 'add/remove'!removeFromGraph
        "Remove myself from the constraint graph."

        (output == nil) ifFalse: [output removeConstraint: self].
        satisfied := false.! !!CPBUnaryConstraint methodsFor: 'planning'!chooseMethod: mark
        "Decide if I can be satisfied and record that decision."

        satisfied :=
                (output mark ~= mark) and:
                [strength stronger: output walkStrength].! !!CPBUnaryConstraint methodsFor: 'planning'!execute
        "Enforce this constraint. Assume that it is satisfied."

        self subclassResponsibility! !!CPBUnaryConstraint methodsFor: 'planning'!inputsDo: aBlock
        "I have no input variables."! !!CPBUnaryConstraint methodsFor: 'planning'!markUnsatisfied
        "Record the fact that I am unsatisfied."

        satisfied := false.! !!CPBUnaryConstraint methodsFor: 'planning'!output
        "Answer my current output variable."

        ^output! !!CPBUnaryConstraint methodsFor: 'planning'!recalculate
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
         the value for the current output of this constraint. Assume this
         constraint is satisfied."

        output walkStrength: strength.
        output stay: (self isInput not).
        (output stay) ifTrue: [self execute].        "stay optimization"! !!CPBEditConstraint methodsFor: 'queries'!isInput
        "I indicate that a variable is to be changed by imperative code."

        ^true! !!CPBEditConstraint methodsFor: 'execution'!execute
        "Edit constraints do nothing."! !!CPBEditConstraint class methodsFor: 'instance creation'!var: aVariable strength: strengthSymbol
        "Install an edit constraint with the given strength on the given
         variable."

        ^(self new) var: aVariable strength: strengthSymbol! !!CPBStayConstraint methodsFor: 'execution'!execute
        "Stay constraints do nothing."! !!CPBStayConstraint class methodsFor: 'instance creation'!var: aVariable strength: strengthSymbol
        "Install a stay constraint with the given strength on the given variable."

        ^(self new) var: aVariable strength: strengthSymbol! !!CPBVariable methodsFor: 'name' stamp: 'stephaneducasse 2/4/2006 20:39'!name: aName type: aType
	"Set the variable's name and type as indicated"

	variableName := aName.
	variableType := aType! !!CPBVariable methodsFor: 'name' stamp: 'sw 12/11/2000 14:07'!variableName
	"Answer the variable name of the receiver"

	^ variableName! !!CPBVariable methodsFor: 'type' stamp: 'sw 12/11/2000 14:06'!variableType
	"Anser the variable type of the receiver"

	^ variableType! !!CPBVariable methodsFor: 'type' stamp: 'stephaneducasse 2/4/2006 20:39'!variableType: aType
	"Set the receiver's variable type as requested"

	variableType := aType! !!CPBVariable methodsFor: 'value' stamp: 'sw 12/11/2000 14:06'!defaultValue
	"Answer the default value to be supplied to the receiver"

	^ defaultValue! !!CPBVariable methodsFor: 'value' stamp: 'stephaneducasse 2/4/2006 20:39'!sample
	"The closest we can come to an object for our type"

	| ty clsName |
	self defaultValue ifNotNil: [^ self defaultValue].
	ty := self variableType.
	"How translate a type like #player into a class?"
	clsName := ty asString.
	clsName at: 1 put: (clsName first asUppercase).
	clsName := clsName asSymbol.
	(Smalltalk includesKey: clsName) ifFalse: [self error: 'What type is this?'. ^ 5].
	^ (Smalltalk at: clsName) initializedInstance! !!CPBVariable methodsFor: 'initialize-release' stamp: 'HW 1/25/2014 17:24'!initialize

        value := 0.
        constraints := OrderedCollection new: 2.
        determinedBy := nil.
        walkStrength := CPBStrength absoluteWeakest.
        stay := true.
        mark := 0.! !!CPBVariable methodsFor: 'access'!addConstraint: aConstraint
        "Add the given constraint to the set of all constraints that refer
         to me."

        constraints add: aConstraint.! !!CPBVariable methodsFor: 'access'!constraints
        "Answer the set of constraints that refer to me."

        ^constraints! !!CPBVariable methodsFor: 'access'!determinedBy
        "Answer the constraint that determines my value in the current
         dataflow."

        ^determinedBy! !!CPBVariable methodsFor: 'access'!determinedBy: aConstraint
        "Record that the given constraint determines my value in the current
         data flow."

        determinedBy := aConstraint.! !!CPBVariable methodsFor: 'access'!mark
        "Answer my mark value."

        ^mark! !!CPBVariable methodsFor: 'access'!mark: markValue
        "Set my mark value."

        mark := markValue.! !!CPBVariable methodsFor: 'access'!removeConstraint: c
        "Remove all traces of c from this variable."

        constraints remove: c ifAbsent: [].
        (determinedBy == c) ifTrue: [determinedBy := nil].! !!CPBVariable methodsFor: 'access'!stay
        "Answer my stay flag."

        ^stay! !!CPBVariable methodsFor: 'access'!stay: aBoolean
        "Set my stay flag."

        stay := aBoolean! !!CPBVariable methodsFor: 'access'!value
        "Answer my value."

        ^value! !!CPBVariable methodsFor: 'access'!value: anObject
        "Set my value."

        value := anObject.! !!CPBVariable methodsFor: 'access'!walkStrength
        "Answer my walkabout strength in the current dataflow."

        ^walkStrength! !!CPBVariable methodsFor: 'access'!walkStrength: aStrength
        "Set my walkabout strength in the current dataflow."

        walkStrength := aStrength.! !!CPBVariable methodsFor: 'changes'!setValue: aValue
        "Attempt to assign the given value to me using a strength of
         #preferred."

        self setValue: aValue strength: #preferred.! !!CPBVariable methodsFor: 'changes' stamp: 'HW 1/25/2014 17:22'!setValue: aValue strength: strengthSymbol
        "Attempt to assign the given value to me using the given strength."

        | editConstraint |
        editConstraint := CPBEditConstraint var: self strength: strengthSymbol.
        (editConstraint isSatisfied) ifTrue:
                [self value: aValue.
                 CPBPlanner propagateFrom: self].
        editConstraint destroyConstraint.! !!CPBVariable methodsFor: 'printing'!longPrintOn: aStream

        self shortPrintOn: aStream.
        aStream nextPutAll: ' Constraints: '.
        (constraints isEmpty)
                ifTrue: [aStream cr; tab; nextPutAll: 'none']
                ifFalse:
                        [constraints do:
                                [: c | aStream cr; tab. c shortPrintOn: aStream]].
        (determinedBy isNil) ifFalse:
                [aStream cr; nextPutAll: ' Determined by: '.
                 aStream cr; tab. determinedBy shortPrintOn: aStream].
        aStream cr.! !!CPBVariable methodsFor: 'printing'!printOn: aStream

        self shortPrintOn: aStream! !!CPBVariable methodsFor: 'printing'!shortPrintOn: aStream

        aStream nextPutAll: 'V(', self asOop printString, ', '.
        aStream nextPutAll: walkStrength printString, ', '.
        (stay isNil) ifFalse:
                [aStream nextPutAll: (stay ifTrue: ['stay, '] ifFalse: ['changing, '])].
        aStream nextPutAll: value printString.
        aStream nextPutAll: ')'.
        aStream cr.! !!CPBVariable class methodsFor: 'instance creation'!new

        ^super new initialize! !!CPBVariable class methodsFor: 'instance creation'!value: aValue

        ^(super new) initialize; value: aValue! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 17:01'!OSLockTest	| lock |	lock := OSLock new.	lock release.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 15:37'!gameOfLife	SPyVM print: STMSimulation benchmark2.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 15:59'!osLockEasyTest	| lock1 |		lock1 := OSLock new.	lock1 lock.	SPyVM print: 'Survived locking.'.	lock1 release.	SPyVM print: 'Survived releasing.'.		^ self! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 14:43'!osLockTest	| lock process1 process2 process2lock |		lock := OSLock new.	lock lock.		process2lock := OSLock new.	process2lock lock.		process1 := [ SPyVM print: 'First process start'. 	  lock lock.	  process2lock release.	  SPyVM print: 'First process after lock'.	  lock release. ] parallelFork .	process2 := [ SPyVM print: 'Second process start'.	  process2lock lock.	  lock lock.	  SPyVM print: 'Second process after lock'.	  process2lock release.	  lock release. ] parallelFork .	SPyVM print: 'Processes initialized.'.		lock release.		process1 wait.	process2 wait.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 14:48'!parallelForkTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := [ 1 + 1. ] parallelFork.	p wait! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34'!runCPBAStarBenchmark| writer runner |		[		runner := (CPBAStarBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.] on: Errordo: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34'!runCPBBinaryTreeBenchmark| writer runner |[runner := (CPBBinaryTreeBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true .] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34'!runCPBBlowfishSuite| writer runner |runner := (CPBBlowfishSuite) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'.Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 17:04'!runCPBChameneosBenchmark| runner writer |runner := (CPBChameneosBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34'!runCPBDeltaBlueBenchmark| writer runner |runner := (CPBDeltaBlueBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/26/2014 17:00'!runCPBMandelbrotBenchmarkSuite	| writer runner |			runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100.	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'. 	Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:34'!runCPBNBodyBenchmark| writer runner |		runner := (CPBNBodyBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 7/22/2014 20:28'!runCPBParallelSum		| writer runner |		SPyVM print: 'Starting to run the benchmark now'.	runner := (CPBParallelSumBenchmarkSuite) run: self \\ 100.	SPyVM print: 'Done with the benchmark writing results'.	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'.	Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:35'!runCPBPolymorphyBenchmark| writer runner |runner := (CPBPolymorphyBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true .! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:35'!runCPBRichardsBenchmark| writer runner |		runner := (CPBRichardsBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 6/19/2014 15:35'!runCPBSplayTreeBenchmark| writer runner |		runner := (CPBSplayTreeBenchmark) run: self \\ 100.writer := CPBBenchmarkResultWriter new .writer writeResult: (runner results) inFile: 'result.txt'. Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 7/10/2014 12:21'!runPrintTest|s |		[SPyVM print: 'aso'.] on: Error do: [ :exc | 	s := FileStream newFileNamed: 'error.txt'.	s nextPutAll: (exc messageText).	s nextPutAll: (exc signalerContext longStack).].! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'lw 4/29/2013 13:20' prior: 42573057!runSPyBenchmarks	^ SPyRunner run! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'lw 6/27/2013 15:27' prior: 42627943!runTests	^ SPyRunner runKernelTests! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 5/22/2014 14:46'!stmTest	| p |	FileStream stdout nextPutAll: 'starting stm process.'.	p := STMProcess new.	p wait.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'hh 6/12/2014 15:28'!testFloat| |[SPyVM print: 'test convertion1'.	SPyVM print: (1) asString.SPyVM print: 'test convertion2'.	SPyVM print: 19 asFloat isFinite  asString.SPyVM print: 'test convertion3'.	SPyVM print: Float ln2 isFinite asString.SPyVM print: 'test convertion'.	SPyVM print: (1.0) asString.SPyVM print: 'test addition'.SPyVM print: (1+1.0) asString.SPyVM print: ((14252 / 10) asFloat isFinite asString).SPyVM print: ((0.0 + 100) asString).] on: Error do: [ :exc | 	SPyVM print: (exc messageText).	SPyVM print: (exc signalerContext longStack).].Smalltalk snapshot: false andQuit: true .! !!OSLock methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:09'!internalLock		<primitive: 792>	SPyVM print: '* OS Lock could not be locked *' , Character cr.	self primitiveFailed.	self resume! !!OSLock methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:09'!internalRelease	<primitive: 793>	SPyVM print: '* OS Lock could not be released *' , Character cr.	self primitiveFailed.	self resume! !!OSLock methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:09'!lock	self internalLock	! !!OSLock methodsFor: 'as yet unclassified' stamp: 'pre 6/26/2014 16:09'!release	self internalRelease! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59'!defaultArgumentParser
	^ SMarkHarnessArgumentParser! !!SMarkHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 20:00'!parseArguments: arguments
	| parser |
	parser := self defaultArgumentParser new.
	parser harness: self.
	^ parser parse: arguments.! !!SMarkHarness class methodsFor: 'helper'!shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !!SMarkHarness class methodsFor: 'helper'!usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !!SMarkHarness class methodsFor: 'helper'!usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !!SMarkHarness class methodsFor: 'helper'!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !!SMarkHarness class methodsFor: 'helper'!usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !!SMarkHarness class methodsFor: 'helper'!usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !!SMarkHarness class methodsFor: 'helper'!version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			^ cfg project currentVersion versionNumber asString.
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !!SMarkHarness class methodsFor: 'defaults'!defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !!SMarkHarness class methodsFor: 'defaults'!defaultReporter
	^ SMarkReporter defaultReporter! !!SMarkHarness class methodsFor: 'defaults'!defaultRunner
	^ SMarkSuite defaultRunner! !!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41'!execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !!SMarkHarness class methodsFor: 'benchmarking'!execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !!SMarkHarness class methodsFor: 'script entry' stamp: 'StefanMarr 12/30/2011 20:19'!run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 12/30/2011 19:59'!defaultArgumentParser
	^ ReBenchHarnessArgumentParser! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20'!usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20'!usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !!ReBenchHarness class methodsFor: 'helper'!usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'helper'!usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !!ReBenchHarness class methodsFor: 'defaults'!defaultReporter
	^ ReBenchReporter! !!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06'!defaultRunner
	^ SMarkWeakScalingRunner! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38'!determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26'!determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !!SMarkHarnessArgumentParser methodsFor: 'accessing'!harness: aHarness
	harness := aHarness! !!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29'!instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27'!parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17'!determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing'!determineReporter
	reporter := harness defaultReporter new.! !!ReBenchHarnessArgumentParser methodsFor: 'argument parsing'!determineRunner
	runner := harness defaultRunner new.! !!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:31'!instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	runner innerIterations: iterations.! !!SMarkReporter methodsFor: 'reporting'!benchmarkFooter: aName
	stream cr.! !!SMarkReporter methodsFor: 'reporting'!benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !!SMarkReporter methodsFor: 'reporting'!footer
	"No output at the moment"
	^ self! !!SMarkReporter methodsFor: 'reporting'!header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !!SMarkReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/5/2011 13:13'!reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.]]! !!SMarkReporter methodsFor: 'initialization'!initialize
	stream := self class defaultOutputDestination.! !!SMarkReporter methodsFor: 'accessing'!outputStream: aStream
	stream := aStream  ! !!SMarkReporter methodsFor: 'accessing'!report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !!SMarkReporter methodsFor: 'accessing'!runner: aRunner
	runner := aRunner.! !!SMarkReporter class methodsFor: 'defaults'!defaultOutputDestination
	^ ScriptConsole! !!SMarkReporter class methodsFor: 'defaults'!defaultReporter
	^ SMarkSimpleStatisticsReporter! !!SMarkReporter class methodsFor: 'reporting'!reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !!SMarkReporter class methodsFor: 'reporting'!reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !!SMarkResult methodsFor: 'accessing'!benchmarkName
	^ benchName! !!SMarkResult methodsFor: 'accessing'!benchmarkName: aString
	benchName := aString! !!SMarkResult methodsFor: 'accessing'!criteria
	^ criteria! !!SMarkResult methodsFor: 'accessing'!criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !!SMarkResult methodsFor: 'accessing'!suite
	^ suite! !!SMarkResult methodsFor: 'accessing'!suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !!SMarkResult methodsFor: 'accessing'!total
	^ time! !!SMarkResult methodsFor: 'accessing'!total: aTime
	time := aTime! !!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28'!createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !!SMarkRunner methodsFor: 'helper' stamp: 'hh 6/12/2014 14:13'!recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05'!execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10'!initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20'!iterations
	^ numIterations! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20'!iterations: anInteger
	numIterations := anInteger! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08'!problemSize
	^ problemSize! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 8/21/2012 09:44'!problemSize: aValue
	"Do some conversion to make it easier for the benchmarks"
	(aValue isString and: [aValue isAllDigits]) ifTrue: [
		problemSize := Number readFrom: aValue.
		^ self.
	].

	problemSize := aValue! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08'!processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08'!processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46'!report
	SMarkReporter defaultReporter reportFor: self.  
	! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41'!results
	^ results! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45'!suite
	^ suite! !!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14'!suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'pre 7/22/2014 20:30'!performBenchmark: aSelector
	currentBenchmark := aSelector.
		SPyVM print: 'Running benchmark: ' , aSelector .
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42'!runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !!SMarkRunner methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:30'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer result |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	result := suite perform: aSelector.
	timer stop.
	suite processResult: result withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkRunner methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 13:13'!printOn: aStream
	^ self reportOn: aStream.! !!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50'!reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47'!reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59'!initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27'!performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49'!runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18'!targetTime
	"Target time in milliseconds"
	^ targetTime! !!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18'!targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:51'!initialize
	super initialize.
	warmingUp := false.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 23:26'!performBenchmark: aSelector
	"Based on an email by Eliot from May 16th, 2011.
	 The first time a method is executed it will get into the inline cache.
	 The second time, it is found in the inline cache, which triggers the JIT compiler to produce code.
	 Thus, the third time it should be executed in the steady state."
	warmingUp := true.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
		suite runBenchmark: aSelector.
		Smalltalk garbageCollect.
	warmingUp := false.
	
	^ super performBenchmark: aSelector.! !!SMarkCogRunner methodsFor: 'initialization' stamp: 'StefanMarr 12/30/2011 22:57'!recordResults: timer for: aSelector
	"Only record the results when we are not in warmup mode."
	warmingUp ifFalse: [
		super recordResults: timer for: aSelector.
	].! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:24'!execute
	"run all benchmnarks in a benchmark suite "
	[ suite run ] timeProfile! !!SMarkProfileRunner methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:28'!execute: aSelector
	
	[ self performBenchmark: aSelector ] timeProfile! !!SMarkProfileRunner methodsFor: 'initialization' stamp: 'CamilloBruni 1/28/2013 18:28'!initialize
	super initialize.
	numIterations := 1.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34'!performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		suite runBenchmark: aSelector ].	
	
	currentBenchmark := nil.! !!SMarkProfileRunner methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 1/28/2013 18:34'!timedBenchmarkExecution: aSelector
	suite perform: aSelector! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43'!defaultNumberOfIterations
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09'!defaultNumberOfProcesses
	^ 1! !!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56'!defaultTimer
	^ SMarkTimer! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51'!execute: aSuite
	^ self execute: aSuite with: 1.! !!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51'!execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17'!defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:19'!execute: aSuite selector: aBenchmarkSelector
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkProfileRunner class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:31'!execute: aSuite selector: aBenchmarkSelector iterations: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner 
		suite: aSuite;
		iterations: nIterations;
		execute: aBenchmarkSelector.
	^ runner! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 21:59'!confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (self standardDeviation: times) / (numMeasurements asFloat sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49'!gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46'!significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'MP 1/15/2014 22:08'!standardDeviation: times
	| average variance |
	average := times average .
	variance := 0.0 .
	times do: [:item|
		variance:=variance+((item-average) squared) ].
	
	variance:=variance / times size .
	
	^ (variance sqrt)! !!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03'!studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08'!reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'CamilloBruni 9/6/2011 10:41'!reportResult: aResultsArray for: aCriterion of: benchmark
	| convidenceVariance significantDigits |

	stream << benchmark <<  ' ' <<  aCriterion <<  ': iterations='.
	aResultsArray size printOn: stream .
	stream << ' runtime: '.
	
	aResultsArray size < 2 ifTrue: [
		aResultsArray average printOn: stream.
		stream << 'ms'.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: aResultsArray.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.

	aResultsArray average printOn: stream showingDecimalPlaces: significantDigits.
	stream << 'ms +/-'.
	convidenceVariance printOn: stream showingDecimalPlaces: significantDigits.! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02'!resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40'!totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23'!benchmarkHeader: aName
	^ self! !!SMarkSuite methodsFor: 'helper'!benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !!SMarkSuite methodsFor: 'helper'!shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !!SMarkSuite methodsFor: 'running'!cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !!SMarkSuite methodsFor: 'running'!setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !!SMarkSuite methodsFor: 'running'!tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !!SMarkSuite methodsFor: 'benchmarking'!performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 1/3/2012 14:17'!problemSize
	runner             ifNil: [^ self class defaultProblemSize].
	runner problemSize ifNil: [^ self class defaultProblemSize].
	^ runner problemSize! !!SMarkSuite methodsFor: 'benchmarking' stamp: 'ReinoutStevens 12/6/2011 14:31'!processResult: anObject withTimer: aSMarkTimer
	"subclass responsability. You can verify your results here, or do things with the timer."
	^self.! !!SMarkSuite methodsFor: 'benchmarking'!run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !!SMarkSuite methodsFor: 'benchmarking'!runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !!SMarkSuite methodsFor: 'benchmarking'!runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !!SMarkSuite methodsFor: 'benchmarking'!selectedBenchmarks
	^ selectedBenchmarks! !!SMarkSuite methodsFor: 'accessing'!runner
	^ runner! !!SMarkSuite methodsFor: 'accessing'!runner: aRunner
	runner := aRunner.! !!CPBAStarBenchmark methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 15:11'!benchAStar	5 timesRepeat: [		astar 			graph: graph1;			findPath;			reset .		astar			graph: graph2;			findPath;			reset .].! !!CPBAStarBenchmark methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 15:09'!setUp	astar := CPBAStar new .	graph1 := CPBAStarGraph testGraph .	graph2 := CPBAStarGraph testGraph2 .! !!CPBAStarBenchmark methodsFor: 'initialize-release' stamp: 'MP 2/7/2014 15:04'!tearDown	astar := nil .	graph1 := nil .	graph2 := nil .! !!CPBBinaryTreeBenchmark methodsFor: 'testing' stamp: 'MP 1/27/2014 14:10'!benchBinaryTree
	"starts the binary tree benchmark"
	
	self binarytrees: 10 .! !!CPBBinaryTreeBenchmark methodsFor: 'testing' stamp: 'MP 1/15/2014 14:58'!binarytrees: n
   | minDepth maxDepth stretchDepth check longLivedTree iterations |
   minDepth := 4.
   maxDepth := minDepth + 2 max: n.
   stretchDepth := maxDepth + 1.

   check := (CPBTreeNode bottomUpTree: 0 depth: stretchDepth) itemCheck.
  
   longLivedTree := CPBTreeNode bottomUpTree: 0 depth: maxDepth.
   minDepth to: maxDepth by: 2 do: [:depth|
      iterations := 1 bitShift: maxDepth - depth + minDepth.

      check := 0.
      1 to: iterations do: [:i|
         check := check + (CPBTreeNode bottomUpTree: i depth: depth) itemCheck.
         check := check + (CPBTreeNode bottomUpTree: -1*i depth: depth) itemCheck
         ].
      ].! !!CPBBlowfishSuite methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:31'!benchBlowfish
	blowfish longEncryptionTest.
	blowfish longDecryptionTest.! !!CPBBlowfishSuite methodsFor: 'as yet unclassified' stamp: 'BS 1/28/2014 13:31'!setUp
	blowfish := CPBBlowfishProfiling new.! !!CPBChameneosBenchmark methodsFor: 'benchmarking' stamp: 'pre 7/3/2014 10:25'!benchChameneos[
	c1 fork: mp.
	c2 fork: mp.
	c3 fork: mp.
	c4 fork: mp.
	
	c1 wait.
	c2 wait.
	c3 wait.
	c4 wait.
	
	^ c1 meetings + c2 meetings + c3 meetings + c4 meetings] on: Error do: [ :st | SPyVM print: st messageText. SPyVM print: st signalerContext longStack.]! !!CPBChameneosBenchmark methodsFor: 'initialize-release' stamp: 'pre 7/3/2014 10:51'!setUp
	nMeetings := 500000.
	c1 := CPBChameneos color: #blue.
	c2 := CPBChameneos color: #red.
	c3 := CPBChameneos color: #yellow.
	c4 := CPBChameneos color: #blue.
	mp := CPBMeetingPlace forMeetings: nMeetings.! !!CPBDeltaBlueBenchmark methodsFor: 'benchmarking' stamp: 'MP 1/27/2014 14:26'!benchDeltaBlue
	CPBPlanner standardBenchmark.! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:41'!benchMandelbrotIterative1Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42'!benchMandelbrotIterative2Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 2;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42'!benchMandelbrotIterative4Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 4;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42'!benchMandelbrotIterative8Thread
	mandelbrotMorph
		mode: #iterative;
		threadCount: 8;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42'!benchMandelbrotRecursive1Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 1;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42'!benchMandelbrotRecursive2Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 2;
		reCalculateSTM.
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42'!benchMandelbrotRecursive4Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 4;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'benchmarking' stamp: 'hh 6/19/2014 10:42'!benchMandelbrotRecursive8Thread
	mandelbrotMorph
		mode: #recursive;
		threadCount: 8;
		reCalculateSTM .
	! !!CPBMandelbrotBenchmarkSuite methodsFor: 'initialize-release' stamp: 'MP 1/27/2014 14:16'!setUp
	mandelbrotMorph := CPBMandelbrotMorph new.
	mandelbrotMorph
		extent: 50@50;
		depth: 85;
		imageBounds: ((-0.3@ -0.9) corner: (0.0 @ -0.6)).! !!CPBNBodyBenchmark methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:18'!after: dt
   1 to: bodies size do: [:i|
      i+1 to: bodies size do: [:j|                            
         (bodies at: i) and: (bodies at: j) velocityAfter: dt].
   ].   
   bodies do: [:each| each positionAfter: dt]! !!CPBNBodyBenchmark methodsFor: 'nbody' stamp: 'MP 1/27/2014 14:22'!benchNBody
	"helper method to run the n body benchmark"
	
	self runBenchmarkFor: 10000 withStep: 0.01d0 .! !!CPBNBodyBenchmark methodsFor: 'nbody' stamp: 'MP 12/11/2013 21:18'!energy
   | e |
   e := 0.0d0.
   1 to: bodies size do: [:i|       
      e := e + (bodies at: i) kineticEnergy.

      i+1 to: bodies size do: [:j| 
         e := e - ((bodies at: i) potentialEnergy: (bodies at: j))].
   ].
   ^e! !!CPBNBodyBenchmark methodsFor: 'nbody' stamp: 'MP 1/15/2014 14:53'!runBenchmarkFor: iterations withStep: stepSize 
	"helper method to run the n body benchmark"
	
	0 to: iterations
		do: [:i | self after: stepSize]! !!CPBNBodyBenchmark methodsFor: 'initialize-release' stamp: 'MP 1/27/2014 14:22'!setUp
   bodies := OrderedCollection new
      add: CPBBody sun; add: CPBBody jupiter; add: CPBBody saturn;
      add: CPBBody uranus; add: CPBBody neptune; yourself.

   bodies first offsetMomentum:
      (bodies inject: (Array with: 0.0d0 with: 0.0d0 with: 0.0d0)
         into: [:m :each | each addMomentumTo: m])! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35'!benchStmParallel16Thread10000000		| num max |		num := 16.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:35'!benchStmParallel16Thread1000000000		| num max |		num := 16.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35'!benchStmParallel1Thread10000000		| num max |		num := 1.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:35'!benchStmParallel1Thread1000000000		| num max |		num := 1.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35'!benchStmParallel2Thread10000000		| num max |		num := 2.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:35'!benchStmParallel2Thread1000000000		| num max |		num := 2.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:35'!benchStmParallel4Thread10000000		| num max |		num := 4.	max := 10000000.	self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:35'!benchStmParallel4Thread1000000000		| num max |		num := 4.	max := 1000000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:36'!benchStmParallel8Thread10000000		| num max |		num := 8.	max := 10000000.		self class sumWithThreads: num andNumber: max.! !!CPBParallelSumBenchmarkSuite methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 20:36'!benchStmParallel8Thread1000000000		| num max |		num := 8.	max := 1000000000.				self class sumWithThreads: num andNumber: max.! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'BS 2/7/2014 16:48'!benchSplayTree
	"replace a few nodes in the splay tree."
	
	| key greatest |
	
	1 to: kSplayTreeModifications do: [:i|
		key := self insertNewNode.
		greatest := self splayTree findGreatestLessThan: key.
		greatest ifNil: [
			self splayTree remove: key.
		] ifNotNil: [
			self splayTree remove: greatest key.
		].
	].! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:39'!generateKey
	^ (keyCounter := keyCounter + 1)! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:39'!generatePayloadTreeWithDepth: depth andTag: tag
	(depth = 0) ifTrue: [
		^ Dictionary new
			at: #array put: {0. 1. 2. 3. 4. 5. 6. 7. 8. 9};
			at: #string put: 'String for key ', tag, ' in leaf node';
			yourself.
	] ifFalse: [
		^ Dictionary new
			at: #left put: (self generatePayloadTreeWithDepth: depth - 1 andTag: tag);
			at: #right put: (self generatePayloadTreeWithDepth: depth - 1 andTag: tag);
			yourself.
	]! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:38'!insertNewNode
	"insert new node with a unique key"
	
	| key payload | 
	
	key := self generateKey.
	"Transcript show: 'entering insertNewNode key: '.
	Transcript show: key.
	Transcript showln: ''."
	
	[ (self splayTree find: key) isNil ] whileFalse:
	[
		key := self generateKey.
	].

	payload := self generatePayloadTreeWithDepth: self splayTreePayloadDepth andTag: key.
	self splayTree insert: key value: payload.
	^ key.! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:39'!setUp	
	splayTree := nil.
	kSplayTreeSize := 100. "8000"
	kSplayTreeModifications := 80. "80."
	kSplayTreePayloadDepth := 5.
	keyCounter := 0.
	
	"Transcript showln: 'entering SplayTree setup'."
	
	self splayTree: (CPBSplaytree new).
	
	1 to: self splayTreeSize do: [:i |
		self insertNewNode.
	]! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:40'!splayTree
	^ splayTree! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:40'!splayTree: aSplayTree
	splayTree := aSplayTree.! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:40'!splayTreePayloadDepth
	^ kSplayTreePayloadDepth! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'HW 1/25/2014 17:40'!splayTreeSize
	^ kSplayTreeSize! !!CPBSplayTreeBenchmark methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:39'!tearDown
	"allow gc to reclaim the memory
	 used by the splay tree no matter how we exit the tear down function"
	
	| keys length |

	keys := self splayTree exportKeys.
	self splayTree: nil.
	
	"Verify that the splay tree has the right size."
	length := keys size.
	"Transcript show: length.
	Transcript show: '';cr.
	Transcript show: (self splayTreeSize)."
	( length ~= self splayTreeSize ) ifTrue: [
		Error signal: 'Splay tree has wrong size.'.
		Transcript show: 'Splay tree has wrongsize.'; cr .
	].

	"Verify that the splay tree has sorted, unique keys."
	1 to: (length-1) do: [:i|
		( (keys at: i) >= (keys at: ( i + 1) )) ifTrue: [
			Error signal: 'Splay tree not sorted'.
		].
	].
	! !!SMarkSuite class methodsFor: 'defaults'!defaultProblemSize
	^ nil! !!SMarkSuite class methodsFor: 'defaults' stamp: 'StefanMarr 12/30/2011 22:43'!defaultRunner
	^ self onCog: [SMarkCogRunner]
	       else:  [SMarkRunner]! !!SMarkSuite class methodsFor: 'benchmarking'!isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !!SMarkSuite class methodsFor: 'benchmarking'!run
	^ self defaultRunner execute: self new.! !!SMarkSuite class methodsFor: 'benchmarking'!run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !!SMarkSuite class methodsFor: 'platform support' stamp: 'StefanMarr 4/5/2012 22:20'!onCog: cogSpecificBlock else: general
	^ (Smalltalk vm isRunningCogit)
		ifTrue:  [cogSpecificBlock value]
		ifFalse: [general value]! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:22'!profile: aSelector
	^ self profileRunner 
		execute: self new selector: aSelector.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:30'!profile: aSelector iterations: nIterations
	^ self profileRunner 
		execute: self new selector: aSelector iterations: nIterations.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:21'!profileAll
	^ self profileRunner 
		execute: self new.! !!SMarkSuite class methodsFor: 'profiling' stamp: 'CamilloBruni 1/28/2013 18:17'!profileRunner
	^ SMarkProfileRunner! !!CPBParallelSumBenchmarkSuite class methodsFor: 'as yet unclassified' stamp: 'pre 6/22/2014 19:54'!sumWithThreads: threadNumber andNumber: sumNumber            | localSums threads max |	localSums := Array new: threadNumber.		max := sumNumber // threadNumber.		threads := (1 to: threadNumber-1) collect: [ :i |		| sum |		sum := 0. 		 [( ( (i-1) * max) to: ((i * max) - 1)) do: [ :k | 				 sum := sum + k. 				].		localSums at: i put: sum. ] parallelFork ].	threads := threads asOrderedCollection.	threads add: [		| sum |		sum := 0. 		 ((sumNumber-max) to: sumNumber) do: [ :k | 				 sum := sum + k. ].		localSums at: threadNumber put: sum.		] parallelFork.	threads do: [:t | t wait].! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24'!currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54'!reset
	startTime := 0.
	elapsedTime := 0.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24'!start
	startTime := self currentMillis.! !!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25'!stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !!SMarkTimer methodsFor: 'initialization' stamp: 'ReinoutStevens 12/6/2011 14:32'!initialize
	super initialize.
	elapsedTime := 0! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!name
	^name! !!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!name: aString
	name := aString ! !!SMarkTimer methodsFor: 'accessing' stamp: 'hh 6/12/2014 13:20'!totalTime
	^elapsedTime! !!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54'!new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !!SMarkTransporter class methodsFor: 'transporter' stamp: 'StefanMarr 4/5/2012 21:46'!transportersForFileOutMenu
	^ { (Smalltalk at: #Transporter ifAbsent: [^#()])
			forPackage: (PackageInfo named: 'SMark') }! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13'!execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17'!executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43'!innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43'!innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54'!processes
	^ numProcesses! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53'!processes: anInteger
	numProcesses := anInteger! !!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31'!timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43'!initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50'!reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42'!defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20'!benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20'!innerIterations: anInt
	numInnerIterations := anInt! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21'!runner: aRunner
	runner := aRunner! !!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21'!suite: aSuite
	suite := aSuite! !!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22'!run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33'!createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !!SPyRunner class methodsFor: 'tests' stamp: 'lw 6/27/2013 15:24' prior: 42627074!initialize	"self initialize"	super initialize.	KernelTests := self kernelTests.! !!SPyRunner class methodsFor: 'tests' stamp: 'lw 6/27/2013 15:24' prior: 42625693!kernelTests	| suite |	suite := TestSuite named: 'RSqueakVM-Tests'.	"To add later: MethodPragmaTest . WeakMessageSendTest"	{IntegerTest . InstructionClientTest . FractionTest . DelayTest . CompiledMethodTest . BehaviorTest . StopwatchTest . YearTest . TimeTest . AllocationTest . ProcessTest . ClassDescriptionTest . SmallIntegerTest . MethodContextTest . CompiledMethodComparisonTest . YearMonthWeekTest . TimespanTest . DependentsArrayTest . CategorizerTest . IntegerDigitLogicTest . SemaphoreTest . PromiseTest . DateTest . DateAndTimeEpochTest . InstVarRefLocatorTest . DateAndTimeTest . BasicBehaviorClassMetaclassTest . ExtendedNumberParserTest . TrueTest . UndefinedObjectTest . ComplexTest . ScheduleTest . CompiledMethodTrailerTest . LargePositiveIntegerTest . ScaledDecimalTest . ClassBuilderTest . SqNumberParserTest . ProtoObjectTest . NumberParsingTest . RandomTest . DateAndTimeLeapTest . TimespanDoTest . ClassTest . TimespanDoSpanAYearTest . BlockContextTest . TimeStampTest . GradientFillStyleTest . MethodPropertiesTest . WeekTest . ObjectTest . DurationTest . NumberTest . MonthTest . FalseTest . InstructionPrinterTest . MonitorTest . BooleanTest . BlockClosureTest . FloatTest . ProcessSpecificTest . LargeNegativeIntegerTest} do: [ :each | each addToSuiteFromSelectors: suite].	^ suite! !!SPyRunner class methodsFor: 'tests' stamp: 'lw 6/27/2013 15:23' prior: 42625344!nonDestroyingTests	| suite |	suite := KernelTests copy.	suite 		tests: (suite tests 			reject: [ :eachTestCase | 				"Those tests lead to VM-Assertion Errors, etc."				#(testBenchFib testAllNamedFromTo testWaitTimeoutMSecs)					includes: eachTestCase selector]).	^ suite! !!SPyRunner class methodsFor: 'tests' stamp: 'lw 6/27/2013 15:25' prior: 42627244!runKernelTests	"self runKernelTests"	^ self nonDestroyingTests run asString! !!SPyRunner class methodsFor: 'benchmarks' stamp: 'lw 4/29/2013 17:13' prior: 42588908!format: result	"self run"	"runs all the benchmarks and creates a string of csv format with one column per benchmarks"	^ String streamContents: 		[ :aStream |		result keysAndValuesDo: 			[ :key :value | 			aStream << key << ';' << value << String lf]]! !!SPyRunner class methodsFor: 'benchmarks' stamp: 'lw 6/26/2013 19:21' prior: 42619121!run	"self run"	| result result2 |	result := self runShootout.	result2 := self runTinyBenchmarks.	result at: #benchmark put: (result2 at: #benchmark). 	result at: #benchFib put: (result2 at: #benchFib). 	^self format: result.	! !!SPyRunner class methodsFor: 'benchmarks' stamp: 'lw 6/26/2013 21:45' prior: 42623020!runShootout	"self runShootout explore"	| stream times |	stream := (ByteString new: 10000) writeStream.	times := Dictionary new.	{ [ShootoutTests nbody: 200000 "20000000" to: stream].	   [ShootoutTests binarytrees: 17 to: stream].	   "[ShootoutTests chameneosredux: 2600000 to: stream]."	   [ShootoutTests threadring: 100000000 to: stream] } do:			[:block | | benchmark t |		benchmark := (ShootoutTests selectorForSimpleBlock: block) copyUpTo: $:.		"Smalltalk garbageCollect."		times at: benchmark put: (t := Time millisecondsToRun: block)].	^times! !!SPyRunner class methodsFor: 'benchmarks' stamp: 'lw 4/29/2013 17:39' prior: 42603591!runTinyBenchmarks	| t1 t2 r n1 n2 |	n1 := 5200.	t1 := Time millisecondsToRun: [n1 benchmark].	"Note: #benchmark's runtime is about O(n)"	n2 := 42.	t2 := Time millisecondsToRun: [r := n2 benchFib].	"Note: #benchFib's runtime is about O(k^n),		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."	^ Dictionary new 		at: #benchmark put: t1;		at: #benchFib put: t2;		yourself "((n1 * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',	  ((r * 1000) // t2) printString, ' sends/sec'"! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:28' prior: 33558090!primEnter	<primitive: 790>		SPyVM print: 'primEnter failed'.! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:29' prior: 33558233!primLeave	<primitive: 791>		SPyVM print: 'primLeave failed'.! !!STMAtomic methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 23:01' prior: 33567418!value		| result  |		self primEnter.	result := self block value.	self primLeave.	^result	! !!STMAtomic methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:02' prior: 33567584!block	^ block! !!STMAtomic methodsFor: 'accessing' stamp: 'toma 1/16/2014 23:02' prior: 33567669!block: anObject	block := anObject! !!STMAtomic class methodsFor: 'as yet unclassified' stamp: 'toma 1/16/2014 22:36' prior: 33562073!from: aBlock		^ (STMAtomic new)		block: aBlock;		yourself! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:17' prior: 42636506!fork	<primitive: 787>	Transcript show: '* STM Process did not fork *' , Character cr.	self primitiveFailed.	self resume! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:17' prior: 33556280!primWait	<primitive: 789>	SPyVM print: ' Failed to wait for process!! '.	self primitiveFailed.! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:17' prior: 42657216!signal	<primitive: 788>	Transcript show: ' Failed to signal process!! '! !!STMProcess methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:18' prior: 33556598!wait		self primWait! !!STMProcess class methodsFor: 'as yet unclassified' stamp: 'pre 7/22/2014 21:18' prior: 42629513!forContext: t1 priority: t2 	| t3 |	t3 := self new.	t3 suspendedContext: t1.	t3 priority: t2.	^ t3! !SPyRunner initialize!SPyRunner removeSelector: #runShootout!CPBStrength initialize!----End fileIn of C:\Users\C5187727\Desktop\work\mp2014h\images\STMBenchmarks.2.cs----!----QUIT----{22 July 2014 . 10:01:45 pm} Squeak4.5stm4.image priorSource: 79361!----STARTUP----{23 July 2014 . 8:08:15 am} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!----QUIT/NOSAVE----{23 July 2014 . 8:08:41 am} Squeak4.5stm4.image priorSource: 311269!----STARTUP----{2 August 2014 . 10:46:24 am} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!Object subclass: #CPBMandelbrotRowField	instanceVariableNames: 'form mode threadCount depth imageBounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBMandelbrotRowField methodsFor: 'nil' stamp: 'pre 8/2/2014 10:51'!calculateWithThreadsSTM: anInteger	| semaphores |	semaphores := OrderedCollection new.	1 to: anInteger do:[ :i |			semaphores add: (self createThreadSTM: i of: anInteger).		].	semaphores do: [:s| s wait].! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 10:51'!createThreadSTM: threadNumber of: threadCount	^ [ | index maxIndex |	maxIndex := self form width * self form height.	index := threadNumber.	[index < maxIndex] whileTrue: [		self calculateValAt: (self pointForIndex: index).		index := index + threadCount.	] ] parallelFork! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 10:53'!reCalculateSTM	form := nil.	(self threadCount <= 1) ifTrue: [		self calculate.	] ifFalse: [		self calculateWithThreadsSTM: self threadCount.	].	self changed.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 10:53'!calculateValAt: aPoint	| val aComplex |	aComplex := (Complex		real: (aPoint x * (self imageBounds width / self form width) + self imageBounds left) asFloat		imaginary: (aPoint y * (self imageBounds height / self form height) + self imageBounds top) asFloat). 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	self form colorAt: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:00' prior: 33867301!calculateValAt: aPoint	| val aComplex |	aComplex := (Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: ( (aPoint y * (self zoomFactor)) + 0) asFloat). 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	self form colorAt: aPoint put: (self colorForValue: val).! !Object subclass: #CPBMandelbrotRowField	instanceVariableNames: 'zoomFactor mode threadCount depth imageBounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!Object subclass: #CPBMandelbrotRowField	instanceVariableNames: 'zoomFactor mode threadCount depth size'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:01' prior: 33867047!reCalculateSTM		(self threadCount <= 1) ifTrue: [		self calculate.	] ifFalse: [		self calculateWithThreadsSTM: self threadCount.	].	self changed.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:01' prior: 33867945!calculateValAt: aPoint	| val aComplex |	aComplex := (Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: ( (aPoint y * (self zoomFactor)) + 0) asFloat). 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	self field at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:02' prior: 33869175!calculateValAt: aPoint	| val aComplex |	aComplex := (Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: ( (aPoint y * (self zoomFactor)) + 0) asFloat). 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:02'!width	^ self size y! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!zoomFactor	^ zoomFactor! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!zoomFactor: anObject	zoomFactor := anObject! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!mode	^ mode! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!mode: anObject	mode := anObject! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!threadCount	^ threadCount! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!threadCount: anObject	threadCount := anObject! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!depth	^ depth! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!depth: anObject	depth := anObject! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:02'!size: anObject	size := anObject! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:02' prior: 33866679!createThreadSTM: threadNumber of: threadCount	^ [ | index maxIndex |	maxIndex := self width * self height.	index := threadNumber.	[index < maxIndex] whileTrue: [		self calculateValAt: (self pointForIndex: index).		index := index + threadCount.	] ] parallelFork! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:02'!height	^ self size x! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:03'!at: aPoint put: aColor	! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:03' prior: 33871853!at: aPoint put: aColor	(self rows at: aPoint y) at: aPoint x put: aColor! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:03' prior: 33868917!reCalculateSTM		(self threadCount <= 1) ifTrue: [		self calculate.	] ifFalse: [		self calculateWithThreadsSTM: self threadCount.	].! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:04' prior: 33872164!reCalculateSTM		self rows: ((1 to: self height) collect: [ :i | Array new: self width ]).	(self threadCount <= 1) ifTrue: [		self calculate.	] ifFalse: [		self calculateWithThreadsSTM: self threadCount.	].! !Object subclass: #CPBMandelbrotRowField	instanceVariableNames: 'zoomFactor mode threadCount depth size rows'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:06' prior: 33872407!reCalculateSTM		self rows: ((1 to: self height) collect: [ :i | Array new: self width ]).	(self threadCount <= 1) ifTrue: [		self calculate.	] ifFalse: [		self calculateWithThreadsSTM: self threadCount. ].! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:06'!reCalculate		self rows: ((1 to: self height) collect: [ :i | Array new: self width ]).	(self threadCount <= 1) ifTrue: [		self calculate.	] ifFalse: [		self calculateWithThreads: self threadCount. ].! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:07'!calculateWithThreads: anInteger| semaphores |	semaphores := OrderedCollection new.	1 to: anInteger do:[ :i |			semaphores add: (self createThread: i of: anInteger).		].	semaphores do: [:s| s wait].! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:07'!createThread: threadNumber of: threadCount| semaphore |semaphore := Semaphore new.[ | index maxIndex |	maxIndex := self form width * self form height.	index := threadNumber.	[index < maxIndex] whileTrue: [		self calculateValAt: (self pointForIndex: index).		index := index + threadCount.	].	semaphore signal.] fork.^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:07' prior: 33873822!createThread: threadNumber of: threadCount| semaphore |semaphore := Semaphore new.[ | index maxIndex |	maxIndex := self width * self height.	index := threadNumber.	[index < maxIndex] whileTrue: [		self calculateValAt: (self pointForIndex: index).		index := index + threadCount.	].	semaphore signal.] fork.^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:08' prior: 33873529!calculateWithThreads: anInteger| semaphores |	semaphores := OrderedCollection new.	1 to: anInteger do:[ :i |			semaphores add: (self createThread: i of: anInteger). ].	semaphores do: [:s| s wait].! !Object subclass: #CPBMandelbrotRowField	instanceVariableNames: 'zoomFactor mode threadCount depth bounds rows'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:09'!bounds	^ bounds! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:09'!bounds: anObject	bounds := anObject! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:09'!rows	^ rows! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:09'!rows: anObject	rows := anObject! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:09' prior: 33870263!width	^ self bounds y! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 11:09' prior: 33871741!height	^ self bounds x! !CPBMandelbrotRowField removeSelector: #size:!!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 11:11'!pointForIndex: anInteger	| x y |	y := (anInteger / self width) floor.	x := anInteger - (self width * y).		^ x@y.! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 12:46'!colorForValue: val	| r g b |	(val = self depth) ifTrue:[^Color black].	r := (((val+1) * 2) rem: 256)/256.	g := (((val+1) * 3) rem: 256)/256.	b := (((val+1) * 5) rem: 256)/256.	^ Color r: r g: g b: b.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:46' prior: 33871984!at: aPoint put: aColor	(self rows at: aPoint y + 1) at: aPoint x put: aColor! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:46' prior: 33876427!at: aPoint put: aColor	(self rows at: aPoint y + 1) at: aPoint x + 1put: aColor! !(CPBMandelbrotRowField new)	depth: 1;	mode: #iterative;	threadCount: 5;	bounds: 50@50;	zoomFactor: 1;	reCalculate!	reCalculate!(CPBMandelbrotRowField new)	depth: 1;	mode: #iterative;	threadCount: 5;	bounds: 50@50;	zoomFactor: 1;	reCalculate!(CPBMandelbrotRowField new)	depth: 256;	mode: #iterative;	threadCount: 5;	bounds: 50@50;	zoomFactor: 1;	reCalculate!	reCalculate!(CPBMandelbrotRowField new)	depth: 256;	mode: #iterative;	threadCount: 5;	bounds: 50@50;	zoomFactor: 1;	reCalculate!(CPBMandelbrotRowField new)	depth: 256;	mode: #iterative;	threadCount: 5;	bounds: 50@50;	zoomFactor: 2;	reCalculate!(CPBMandelbrotRowField new)	depth: 256;	mode: #iterative;	threadCount: 5;	bounds: 50@50;	zoomFactor: 100;	reCalculate!(CPBMandelbrotRowField new)	depth: 12000;	mode: #iterative;	threadCount: 5;	bounds: 50@50;	zoomFactor: 100;	reCalculate!	reCalculate!(CPBMandelbrotRowField new)	depth: 12000;	mode: #iterative;	threadCount: 5;	bounds: 50@50;	zoomFactor: 100;	reCalculate!!CPBMandelbrotRowField methodsFor: 'nil' stamp: 'pre 8/2/2014 12:50'!calculate	1		to: self  width		do: [:x | 1				to: self  height				do: [:y | self						calculateValAt: x@y]]! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:50' prior: 33877809!calculate	1 to: self  width		do: [:x | 1 to: self  height				do: [:y | self calculateValAt: x@y]]! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:51' prior: 33869730!calculateValAt: aPoint	| val aComplex |	aComplex := (Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: ( (aPoint y * (self zoomFactor)) + 0) asFloat). 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:51' prior: 33876611!at: aPoint put: aColor	(self rows at: aPoint y) at: aPoint x put: aColor! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:53' prior: 33878233!calculateValAt: aPoint	| val aComplex |	aComplex := (Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: (aPoint y * (self zoomFactor)) + 0) asFloat. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:53' prior: 33878985!calculateValAt: aPoint	| val aComplex |	aComplex := (Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: (aPoint y * (self zoomFactor)) + 0) asFloat.	Transcript show: aComplex. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:54' prior: 33879554!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: (aPoint y * (self zoomFactor)) + 0 asFloat.	Transcript show: aComplex. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:54' prior: 33880151!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: (aPoint y * (self zoomFactor)) + 0 asFloat.	Transcript show: aComplex , Character cr. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:54' prior: 33880746!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: (aPoint y * (self zoomFactor)) + 0 asFloat.	Transcript show: aComplex asString , Character cr. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:55' prior: 33759788!calculateAtIterative: aComplex maxIterations: maxIterations
	| current |
	current := CPBInplaceComplex zero.
	0 to: maxIterations do: [:iteration|
		current square.
		current add: aComplex.
		(current absSq >= 4) ifTrue:[
			^iteration.	
		].
	].	self halt.
	^maxIterations.! !!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:56' prior: 33881973!calculateAtIterative: aComplex maxIterations: maxIterations
	| current |
	current := CPBInplaceComplex zero.
	0 to: maxIterations do: [:iteration|
		current square.
		current add: aComplex.
		(current absSq >= 4) ifTrue:[			self halt.
			^iteration.	
		].
	].	self halt.
	^maxIterations.! !!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 12:56' prior: 33882352!calculateAtIterative: aComplex maxIterations: maxIterations
	| current |
	current := CPBInplaceComplex zero.
	0 to: maxIterations do: [:iteration|
		current square.
		current add: aComplex.
		(current absSq >= 4) ifTrue:[			self halt.
			^iteration.	
		].
	].
	^maxIterations.! !self absSq!!CPBMandelbrot class methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:29' prior: 33882745!calculateAtIterative: aComplex maxIterations: maxIterations
	| current |
	current := CPBInplaceComplex zero.
	0 to: maxIterations do: [:iteration|
		current square.
		current add: aComplex.
		(current absSq >= 4) ifTrue:[
			^iteration.	
		].
	].
	^maxIterations.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:29' prior: 33866379!calculateWithThreadsSTM: anInteger	| semaphores |	semaphores := OrderedCollection new.	1 to: anInteger do:[ :i |			semaphores add: (self createThreadSTM: i of: anInteger). ].	semaphores do: [:s| s wait].! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:29' prior: 33762163!calculateWithThreadsSTM: anInteger
| semaphores |
	semaphores := OrderedCollection new.
	1 to: anInteger do:[ :i |
			semaphores add: (self createThreadSTM: i of: anInteger). ].
	semaphores do: [:s| s wait].! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:31' prior: 33881356!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self zoomFactor)) + 0) asFloat		imaginary: (aPoint y * (self zoomFactor)) + 0 asFloat. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:33' prior: 33884132!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self zoomFactor)) + 0.0) asFloat		imaginary: (aPoint y * (self zoomFactor)) + 0.0 asFloat. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !mandelbrotMorph := CPBMandelbrotMorph new.	mandelbrotMorph		extent: 50@50;		depth: 85;		imageBounds: ((-0.3@ -0.9) corner: (0.0 @ -0.6)).				mandelbrotMorph		mode: #iterative;		threadCount: 1;		reCalculateSTM .!!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:36' prior: 33761249!calculateValAt: aPoint
	| val aComplex |
	aComplex := (Complex
		real: (aPoint x * (self imageBounds width / self form width) + self imageBounds left) asFloat
		imaginary: (aPoint y * (self imageBounds height / self form height) + self imageBounds top) asFloat).
 	(self mode = #iterative) ifTrue: [
		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.
	] ifFalse: [
		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.
	].	Transcript show: val.
	self form colorAt: aPoint put: (self colorForValue: val).! !!CPBMandelbrotMorph methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:36' prior: 33885491!calculateValAt: aPoint
	| val aComplex |
	aComplex := (Complex
		real: (aPoint x * (self imageBounds width / self form width) + self imageBounds left) asFloat
		imaginary: (aPoint y * (self imageBounds height / self form height) + self imageBounds top) asFloat).		Transcript show: aComplex asString, Character cr.
 	(self mode = #iterative) ifTrue: [
		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.
	] ifFalse: [
		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.
	].
	self form colorAt: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:37' prior: 33875639!width	^ self bounds width! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:37' prior: 33875768!height	^ self bounds height! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:38'!initialize	self bounds: (5@3 corner: 2@2)! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:38' prior: 33887103!initialize	self bounds:  ((-0.3@ -0.9) corner: (0.0 @ -0.6)).! !(CPBMandelbrotRowField new)	depth: 120;	mode: #iterative;	threadCount: 1;	zoomFactor: 2;	reCalculate.	!(CPBMandelbrotRowField new)	depth: 120;	mode: #iterative;	threadCount: 1;	zoomFactor: 2;	reCalculate.	!(CPBMandelbrotRowField new)	depth: 120;	mode: #iterative;	threadCount: 2;	zoomFactor: 2;	reCalculate.!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:40' prior: 33887252!initialize	self imageBounds:  ((-0.3@ -0.9) corner: (0.0 @ -0.6)).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:40' prior: 33886984!height	^ self bounds x! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:40' prior: 33886851!width	^ self bounds y! !Object subclass: #CPBMandelbrotRowField	instanceVariableNames: 'zoomFactor mode threadCount depth bounds imageBounds rows'	classVariableNames: ''	poolDictionaries: ''	category: 'Cross-Platform-Benchmarks-Mandelbrot'!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:40'!imageHeight	^ self imageBounds x! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:41'!imageWidth	^ self imageBounds width! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:41' prior: 33888393!imageHeight	^ self imageBounds width! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:41' prior: 33888660!imageHeight	^ self imageBounds height! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:41'!imageTop	^ self imageBounds top! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:41'!imageLeft	^ self imageBounds left! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:41' prior: 33884699!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self zoomFactor)) + self imageLeft) asFloat		imaginary: (aPoint y * (self zoomFactor)) + self imageTop asFloat. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:42'!imageBounds	^ imageBounds! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:42'!imageBounds: anObject	imageBounds := anObject! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:42' prior: 33887754!initialize	self imageBounds:  ((-0.3@ -0.9) corner: (0.0 @ -0.6)).	self bounds: 50@50.	self depth: 120.! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:51' prior: 33875919!pointForIndex: anInteger	| x y |	y := (anInteger / self width) top.	x := anInteger - (self width * y).		^ x@y.! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:51' prior: 33890226!pointForIndex: anInteger	| x y |	y := (anInteger / self width) ceiling.	x := anInteger - (self width * y).		^ x@y.! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:51' prior: 33890437!pointForIndex: anInteger	| x y |	y := (anInteger / self width) floor.	x := anInteger - (self width * y).		^ x@(y + 1).! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:55' prior: 33890652!pointForIndex: anInteger	| x y |	x := anInteger // self width.	y := ((anInteger - x) / self width) floor..		^ x@(y + 1).! !11 // 10!11 // 12!3 \\ 10!3 // 10!!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:56' prior: 33890871!pointForIndex: anInteger	| x y |	x := anInteger \\ self width.	y := ((anInteger - x) / self width) floor..		^ x@(y + 1).! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:57' prior: 33891134!pointForIndex: anInteger	| x y base0coord |	base0coord := anInteger - 1.	x := anInteger \\ self width.	y := ((anInteger - x) / self width) floor..		^ (x + 1)@(y + 1).! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:57' prior: 33891355!pointForIndex: anInteger	| x y base0coord |	base0coord := anInteger - 1.	x := base0coord \\ self width.	y := ((anInteger - x) / self width) floor..		^ (x + 1)@(y + 1).! !!CPBMandelbrotRowField methodsFor: 'accessing' stamp: 'pre 8/2/2014 13:57' prior: 33891623!pointForIndex: anInteger	| x y base0coord |	base0coord := anInteger - 1.	x := base0coord \\ self width.	y := ((base0coord - x) / self width) floor..		^ (x + 1)@(y + 1).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 13:59' prior: 33889197!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self zoomFactor)) + self imageLeft) asFloat		imaginary: (aPoint y * (self zoomFactor)) + self imageTop asFloat.	Transcript show: aComplex asString , Character cr. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !(CPBMandelbrotRowField new)	depth: 120;	mode: #iterative;	threadCount: 2;	zoomFactor: 2;	reCalculate.!(CPBMandelbrotRowField new)	depth: 120;	mode: #iterative;	threadCount: 2;	zoomFactor: 2;	reCalculate.!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:01' prior: 33892172!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self imageWidth / self width)) + self imageLeft) asFloat		imaginary: (aPoint y * (self zoomFactor)) + self imageTop asFloat.	Transcript show: aComplex asString , Character cr. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:02' prior: 33893034!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self imageWidth / self width)) + self imageLeft) asFloat		imaginary: (aPoint y * (self imageHeight / self height)) + self imageTop asFloat.	Transcript show: aComplex asString , Character cr. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	Transcript show: val.	self at: aPoint put: (self colorForValue: val).! !(CPBMandelbrotRowField new)	depth: 120;	mode: #iterative;	threadCount: 2;	zoomFactor: 2;	reCalculate.!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:03'!asForm	| resultForm |	resultForm := Form extent: self bounds.	! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:04' prior: 33894456!asForm	| resultForm |	resultForm := Form extent: self bounds.	(1 to: self height) do: [ :y | (1 to: self width) do:  [ :x | resultForm at: x@y put: (self at: x@y) ]].	^ resultForm! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:05'!at: aPoint	^ (self rows at: aPoint y) at: aPoint x! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:05' prior: 33894628!asForm	| resultForm |	resultForm := Form extent: self bounds depth: self depth.	(1 to: self height) do: [ :y | (1 to: self width) do:  [ :x | resultForm at: x@y put: (self at: x@y) ]].	^ resultForm! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:06' prior: 33895060!asForm	| resultForm |	resultForm := Form extent: self bounds depth: 16.	(1 to: self height) do: [ :y | (1 to: self width) do:  [ :x | resultForm at: x@y put: (self at: x@y) ]].	^ resultForm! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:06' prior: 33895368!asForm	| resultForm |	resultForm := Form extent: self bounds depth: 16.	(1 to: self height) do: [ :y | (1 to: self width) do:  [ :x | resultForm colorAt: x@y put: (self at: x@y) ]].	^ resultForm! !(CPBMandelbrotRowField new)	depth: 120;	mode: #iterative;	threadCount: 2;	zoomFactor: 2;	reCalculate!(CPBMandelbrotRowField new)	mode: #iterative;	threadCount: 1;	reCalculate;	asForm!(ImageMorph new) image: self; openInWorld!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:12' prior: 33874267!createThread: threadNumber of: threadCount	| semaphore |	semaphore := Semaphore new.	[ | index maxIndex |		maxIndex := self width * self height.		index := threadNumber.		[index < maxIndex] whileTrue: [			self calculateValAt: (self pointForIndex: index).			index := index + threadCount. ].		semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:12' prior: 33896213!createThread: threadNumber of: threadCount	| semaphore |	semaphore := Semaphore new.	[ 	| index maxIndex |		maxIndex := self width * self height.		index := threadNumber.		[index < maxIndex] whileTrue: [			self calculateValAt: (self pointForIndex: index).			index := index + threadCount. ].		semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:13' prior: 33896657!createThread: threadNumber of: threadCount	| semaphore |	semaphore := Semaphore new.	[ 	| index maxIndex |						maxIndex := self width * self height.		index := threadNumber.		[index < maxIndex] whileTrue: [			self calculateValAt: (self pointForIndex: index).			index := index + threadCount. ].		semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:13' prior: 33897102!createThread: threadNumber of: threadCount	| semaphore stripeHeight |	semaphore := Semaphore new.	[ 	| index maxIndex |		stripeHeight := (self height / threadCount).						maxIndex := self width * self height.		index := threadNumber.		[index < maxIndex] whileTrue: [			self calculateValAt: (self pointForIndex: index).			index := index + threadCount. ].		semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:14' prior: 33897553!createThread: threadNumber of: threadCount	| semaphore stripeHeight baseStripe |	semaphore := Semaphore new.	[ 	| index maxIndex |		stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.				maxIndex := self width * self height.		index := threadNumber.		[index < maxIndex] whileTrue: [			self calculateValAt: (self pointForIndex: index).			index := index + threadCount. ].		semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:16' prior: 33898064!createThread: threadNumber of: threadCount	| semaphore stripeHeight baseStripe |	semaphore := Semaphore new.	[ 			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.				(baseStripe to: baseStripe + stripeHeight) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: x@y]].				semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:16' prior: 33898634!createThread: threadNumber of: threadCount	| semaphore stripeHeight baseStripe |	semaphore := Semaphore new.	[ 			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.				(baseStripe to: baseStripe + stripeHeight) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1)]].				semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:18' prior: 33899123!createThread: threadNumber of: threadCount	| semaphore stripeHeight baseStripe stripeEnd |	semaphore := Semaphore new.	[ 			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.		(threadNumber = threadCount)			ifTrue: [ stripeEnd := self height - 1]			ifFalse: [ stripeEnd := baseStripe + stripeHeight ].				(baseStripe to: baseStripe + stripeHeight) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1)]].				semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:18' prior: 33899624!createThread: threadNumber of: threadCount	| semaphore stripeHeight baseStripe stripeEnd |	semaphore := Semaphore new.	[ 			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.		(threadNumber = threadCount)			ifTrue: [ stripeEnd := self height - 1]			ifFalse: [ stripeEnd := baseStripe + stripeHeight - 1 ].				(baseStripe to: baseStripe + stripeHeight) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1)]].				semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:18' prior: 33900265!createThread: threadNumber of: threadCount	| semaphore stripeHeight baseStripe stripeEnd |	semaphore := Semaphore new.	[ 			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.		(threadNumber = threadCount)			ifTrue: [ stripeEnd := self height - 1]			ifFalse: [ stripeEnd := baseStripe + stripeHeight - 1 ].				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1)]].				semaphore signal. ] fork.	^ semaphore.! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:19' prior: 33900910!createThread: threadNumber of: threadCount	| semaphore stripeHeight baseStripe |	semaphore := Semaphore new.	[ 			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.		"(threadNumber = threadCount)			ifTrue: [ := self height - 1]			ifFalse: [ := baseStripe + stripeHeight - 1 ]."				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1)]].				semaphore signal. ] fork.	^ semaphore.! !(CPBMandelbrotRowField new)	mode: #iterative;	threadCount: 2;	reCalculate;	asForm!(CPBMandelbrotRowField new)	mode: #iterative;	threadCount: 2;	reCalculate;	asForm!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:19'!openAsImageMorphInWorld	(ImageMorph new)		image: self asForm;		openInWorld! !(CPBMandelbrotRowField new)	mode: #iterative;	threadCount: 2;	reCalculate;	asForm;	openAsImageMorphInWorld!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:20' prior: 33890023!initialize	self imageBounds:  ((-0.3@ -0.9) corner: (0.0 @ -0.6)).	self bounds: 64@64.	self depth: 120.! !(CPBMandelbrotRowField new)	mode: #iterative;	threadCount: 2;	reCalculate;	asForm;	openAsImageMorphInWorld!----SNAPSHOT----{2 August 2014 . 2:20:48 pm} Squeak4.5stm4.image priorSource: 311269!!CPBMandelbrotBenchmarkSuite methodsFor: 'initialize-release' stamp: 'pre 8/2/2014 14:21' prior: 33844596!setUp
	mandelbrotMorph := CPBMandelbrotRowField new.
	mandelbrotMorph
		extent: 50@50;
		depth: 85;
		imageBounds: ((-0.3@ -0.9) corner: (0.0 @ -0.6)).! !!CPBMandelbrotBenchmarkSuite methodsFor: 'initialize-release' stamp: 'pre 8/2/2014 14:21' prior: 33903059!setUp
	mandelbrotMorph := CPBMandelbrotRowField new.
	
		! !----SNAPSHOT----{2 August 2014 . 2:21:26 pm} Squeak4.5stm4.image priorSource: 348432!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:21' prior: 33893691!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self imageWidth / self width)) + self imageLeft) asFloat		imaginary: (aPoint y * (self imageHeight / self height)) + self imageTop asFloat. 	(self mode = #iterative) ifTrue: [		val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth.	] ifFalse: [		val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth.	].	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/2/2014 14:22' prior: 33903571!calculateValAt: aPoint	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self imageWidth / self width)) + self imageLeft) asFloat		imaginary: (aPoint y * (self imageHeight / self height)) + self imageTop asFloat. 	(self mode = #iterative) 		ifTrue: [ val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth. ] 		ifFalse: [ val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth. ].	self at: aPoint put: (self colorForValue: val).! !----SNAPSHOT----{2 August 2014 . 2:22:26 pm} Squeak4.5stm4.image priorSource: 348949!----QUIT----{2 August 2014 . 2:22:38 pm} Squeak4.5stm4.image priorSource: 350230!----STARTUP----{2 August 2014 . 2:25:03 pm} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!----SNAPSHOT----{2 August 2014 . 2:25:27 pm} Squeak4.5stm4.image priorSource: 350317!----QUIT----{2 August 2014 . 2:25:35 pm} Squeak4.5stm4.image priorSource: 350516!----STARTUP----{2 August 2014 . 3:01:29 pm} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!Smalltalk removeClassNamed: #CPBMandelbrotField!----SNAPSHOT----{2 August 2014 . 3:06:24 pm} Squeak4.5stm4.image priorSource: 350603!----QUIT----{2 August 2014 . 3:06:51 pm} Squeak4.5stm4.image priorSource: 350852!----STARTUP----{3 August 2014 . 11:01:34 am} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 11:04'!calculateValAt: aPoint in: aRow	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self imageWidth / self width)) + self imageLeft) asFloat		imaginary: (aPoint y * (self imageHeight / self height)) + self imageTop asFloat. 	(self mode = #iterative) 		ifTrue: [ val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth. ] 		ifFalse: [ val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth. ].	self at: aPoint put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 11:04' prior: 33905658!calculateValAt: aPoint in: aRow	| val aComplex |	aComplex := Complex		real: ( (aPoint x * (self imageWidth / self width)) + self imageLeft) asFloat		imaginary: (aPoint y * (self imageHeight / self height)) + self imageTop asFloat. 	(self mode = #iterative) 		ifTrue: [ val := CPBMandelbrot calculateAtIterative: aComplex maxIterations: self depth. ] 		ifFalse: [ val := CPBMandelbrot calculateAtRecursive: aComplex maxIterations: self depth. ].	aRow at: aPoint x put: (self colorForValue: val).! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 13:48' prior: 33871383!createThreadSTM: threadNumber of: threadCount	| baseStripe semaphore stripeHeight |	^ [ 	stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.		"(threadNumber = threadCount)			ifTrue: [ := self height - 1]			ifFalse: [ := baseStripe + stripeHeight - 1 ]."				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1)]].				semaphore signal. ] parallelFork! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 13:49' prior: 33906872!createThreadSTM: threadNumber of: threadCount	| baseStripe semaphore stripeHeight |	^ [ 	stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.		"(threadNumber = threadCount)			ifTrue: [ := self height - 1]			ifFalse: [ := baseStripe + stripeHeight - 1 ]."				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1) in: (self rows at: y + 1)]].				semaphore signal. ] parallelFork! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 13:50' prior: 33907461!createThreadSTM: threadNumber of: threadCount		^ [ 			| baseStripe semaphore stripeHeight |			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.		"(threadNumber = threadCount)			ifTrue: [ := self height - 1]			ifFalse: [ := baseStripe + stripeHeight - 1 ]."				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1) in: (self rows at: y + 1)]].				semaphore signal. ] parallelFork! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 13:50' prior: 33908076!createThreadSTM: threadNumber of: threadCount		^ [ 			| baseStripe stripeHeight |			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.		"(threadNumber = threadCount)			ifTrue: [ := self height - 1]			ifFalse: [ := baseStripe + stripeHeight - 1 ]."				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1) in: (self rows at: y + 1)]]. ] parallelFork! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 13:51' prior: 33908698!createThreadSTM: threadNumber of: threadCount		^ [ 			| baseStripe stripeHeight |			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1) in: (self rows at: y + 1)]]. ] parallelFork! !!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 13:51' prior: 33909287!createThreadSTM: threadNumber of: threadCount		^ [ 	| baseStripe stripeHeight |			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1) in: (self rows at: y + 1)]]. ] parallelFork! !----QUIT----{3 August 2014 . 1:51:25 pm} Squeak4.5stm4.image priorSource: 350939!----STARTUP----{3 August 2014 . 1:52:39 pm} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!!CPBMandelbrotRowField methodsFor: 'as yet unclassified' stamp: 'pre 8/3/2014 13:53' prior: 33901560!createThread: threadNumber of: threadCount	| semaphore stripeHeight baseStripe |	semaphore := Semaphore new.	[ 			stripeHeight := (self height / threadCount).		baseStripe := (threadNumber - 1) * stripeHeight.				(baseStripe to: baseStripe + stripeHeight  - 1) do: [ :y | 			(0 to: self width - 1) do: [ :x | self calculateValAt: (x + 1)@(y + 1)]].				semaphore signal. ] fork.	^ semaphore.! !----QUIT----{3 August 2014 . 1:53:15 pm} Squeak4.5stm4.image priorSource: 355695!----STARTUP----{3 August 2014 . 5:16:37 pm} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!----QUIT----{3 August 2014 . 5:23:44 pm} Squeak4.5stm4.image priorSource: 356400!----STARTUP----{3 August 2014 . 5:28:12 pm} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 8/3/2014 17:28' prior: 33806121!runCPBMandelbrotBenchmarkSuite| writer runner |			runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100. 	runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100. 	runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100. 	runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100. 	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'. 	Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 8/3/2014 17:28' prior: 33806752!runCPBParallelSum		| writer runner |		(CPBParallelSumBenchmarkSuite) sumWithThreads: 1 andNumber: 1000000000.	(CPBParallelSumBenchmarkSuite) sumWithThreads: 2 andNumber: 1000000000.	(CPBParallelSumBenchmarkSuite) sumWithThreads: 4 andNumber: 1000000000.	runner := (CPBParallelSumBenchmarkSuite) run: self \\ 100.	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'.	Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 8/3/2014 17:29' prior: 33911840!runCPBParallelSum		| writer runner |		(CPBParallelSumBenchmarkSuite) sumWithThreads: 1 andNumber: 1000000000.	(CPBParallelSumBenchmarkSuite) sumWithThreads: 2 andNumber: 1000000000.	(CPBParallelSumBenchmarkSuite) sumWithThreads: 4 andNumber: 1000000000.	runner := (CPBParallelSumBenchmarkSuite) run: self \\ 100.	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'.	Smalltalk snapshot: false andQuit: true.! !----QUIT----{3 August 2014 . 5:29:14 pm} Squeak4.5stm4.image priorSource: 356599!----STARTUP----{4 August 2014 . 11:25:26 am} as C:\Users\C5187727\Desktop\work\mp2014h\images\Squeak4.5stm4.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 8/4/2014 11:25' prior: 33912392!runCPBParallelSum		| writer runner |		(CPBParallelSumBenchmarkSuite) run: 1.	runner := (CPBParallelSumBenchmarkSuite) run: self \\ 100.	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'.	Smalltalk snapshot: false andQuit: true.! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 8/4/2014 11:25' prior: 33911315!runCPBMandelbrotBenchmarkSuite| writer runner |			runner := (CPBMandelbrotBenchmarkSuite) run: 1.	runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100. 	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'. 	Smalltalk snapshot: false andQuit: true.! !----QUIT----{4 August 2014 . 11:25:50 am} Squeak4.5stm4.image priorSource: 358427!----STARTUP----{10 August 2014 . 4:31:22 pm} as C:\Users\C5187727\Desktop\work\hpi\mp2014h\images\Squeak4.5stm4.image!!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 8/10/2014 16:31' prior: 33913517!runCPBMandelbrotBenchmarkSuite| writer runner |			[runner := (CPBMandelbrotBenchmarkSuite) run: 1.	runner := (CPBMandelbrotBenchmarkSuite) run: self \\ 100. 	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'. 	Smalltalk snapshot: false andQuit: true.] forkAt: 79! !!Integer methodsFor: '*SPy-Benchmarks' stamp: 'pre 8/10/2014 16:31' prior: 33913144!runCPBParallelSum		| writer runner |		[(CPBParallelSumBenchmarkSuite) run: 2.	runner := (CPBParallelSumBenchmarkSuite) run: self \\ 100.	writer := CPBBenchmarkResultWriter new .	writer writeResult: (runner results) inFile: 'result.txt'.	Smalltalk snapshot: false andQuit: true.] forkAt: 79.! !!CPBParallelSumBenchmarkSuite class methodsFor: 'as yet unclassified' stamp: 'pre 8/10/2014 16:33' prior: 33853343!sumWithThreads: threadNumber andNumber: sumNumber       | localSums threads max semaphores |	max := sumNumber // threadNumber.	localSums := Array new: threadNumber.	semaphores := (1 to: threadNumber) collect: [:i | Semaphore new].	threads := (1 to: threadNumber) collect: [ :i |		 [| sum |		sum := 0. 		(i to: sumNumber by: threadNumber) do: [ :s | sum := sum + s. ].		localSums at: i put: sum.		(semaphores at: i) signal.  ] parallelFork ].	threads do: [:t | t wait].	^ localSums sum	    ! !----QUIT----{10 August 2014 . 4:34:59 pm} Squeak4.5stm4.image priorSource: 359394!